# Покроковий план реалізації "DDD inside, FSD outside" для Next.js

Цей документ описує покроковий план реалізації архітектурного підходу "DDD inside, FSD outside" для фронтенд-проектів на Next.js, де вся функціональна логіка знаходиться в доменному шарі (DDD), а UI компоненти (FSD) є максимально "тонкими".

## Етап 1: Підготовка проекту

### Крок 1.1: Налаштування базової структури проекту
1. Створіть базову структуру папок:
   ```
   src/
   ├── domains/       # DDD - вся функціональна логіка
   ├── features/      # FSD - тільки "тонкі" UI компоненти
   ├── shared/        # Спільні утиліти та інфраструктура
   ├── app/           # Next.js App Router
   └── pages/         # Next.js Pages Router (якщо використовується)
   ```

### Крок 1.2: Налаштування TypeScript
1. Налаштуйте `tsconfig.json` з суворими правилами типізації:
   - `"strict": true`
   - `"noImplicitAny": true`
   - `"strictNullChecks": true`
   - Налаштуйте шляхи імпорту для зручного доступу до доменів та фіч

### Крок 1.3: Встановлення необхідних залежностей
1. Встановіть основні залежності:
   - Zustand для управління станом
   - Zod для валідації
   - React Hook Form для роботи з формами
   - OpenAPI Generator для генерації API клієнтів

## Етап 2: Реалізація доменного шару (DDD)

### Крок 2.1: Визначення доменних меж
1. Ідентифікуйте основні домени вашої системи (наприклад, Client, Order, Item, Wizard)
2. Для кожного домену визначте:
   - Основні сутності (entities)
   - Об'єкти-значення (value objects)
   - Агрегати (aggregates)
   - Репозиторії (repositories)
   - Сервіси (services)
   - Сценарії використання (use cases)

### Крок 2.2: Створення структури доменів
1. Для кожного домену створіть відповідну структуру папок:
   ```
   domains/
   ├── client/
   │   ├── entities/
   │   ├── value-objects/
   │   ├── repositories/
   │   ├── services/
   │   ├── use-cases/
   │   ├── events/
   │   ├── hooks/
   │   ├── store/
   │   ├── schemas/
   │   ├── types/
   │   ├── utils/
   │   └── index.ts
   ```

### Крок 2.3: Реалізація доменних сутностей та об'єктів-значень
1. Визначте інтерфейси та класи для кожної сутності та об'єкта-значення
2. Реалізуйте бізнес-логіку та валідацію всередині цих класів
3. Забезпечте незмінність (immutability) об'єктів

### Крок 2.4: Реалізація репозиторіїв
1. Визначте інтерфейси репозиторіїв для кожного домену
2. Реалізуйте репозиторії, які використовують API клієнти для взаємодії з бекендом
3. Реалізуйте маппінг між API моделями та доменними сутностями

### Крок 2.5: Реалізація сервісів та сценаріїв використання
1. Реалізуйте доменні сервіси для складної бізнес-логіки
2. Реалізуйте сценарії використання, які оркеструють взаємодію між сутностями, репозиторіями та сервісами

### Крок 2.6: Реалізація Zustand сторів
1. Для кожного домену створіть відповідні Zustand сторі
2. Розділіть сторі на логічні слайси для різних аспектів домену
3. Використовуйте middleware для логування та дебагінгу

### Крок 2.7: Реалізація React-хуків
1. Створіть React-хуки, які інкапсулюють доступ до сторів та бізнес-логіки
2. Реалізуйте композиційні хуки для складних сценаріїв використання
3. Забезпечте чіткі інтерфейси для взаємодії з UI компонентами

### Крок 2.8: Реалізація Zod схем
1. Визначте Zod схеми для валідації даних
2. Використовуйте схеми для генерації TypeScript типів
3. Інтегруйте схеми з формами та API

## Етап 3: Реалізація шару фіч (FSD)

### Крок 3.1: Визначення фіч
1. Ідентифікуйте основні фічі вашої системи (наприклад, OrderWizard, ClientManagement)
2. Розбийте фічі на підфічі (наприклад, ClientSelection, ItemWizard)

### Крок 3.2: Створення структури фіч
1. Для кожної фічі створіть відповідну структуру папок:
   ```
   features/
   ├── order-wizard/
   │   ├── client-selection/
   │   │   ├── ui/
   │   │   └── index.ts
   │   ├── itemCatalog-wizard/
   │   │   ├── ui/
   │   │   └── index.ts
   │   └── index.ts
   ```

### Крок 3.3: Реалізація UI компонентів
1. Створіть "тонкі" UI компоненти, які:
   - Отримують дані та обробники подій з доменних хуків
   - Не містять бізнес-логіки або стану
   - Фокусуються тільки на відображенні даних

### Крок 3.4: Інтеграція з доменними хуками
1. Використовуйте доменні хуки в UI компонентах для отримання даних та обробників подій
2. Передавайте необхідні параметри в хуки
3. Реагуйте на зміни стану з доменних хуків

## Етап 4: Реалізація спільного шару (Shared)

### Крок 4.1: Реалізація API клієнтів
1. Згенеруйте API клієнти з OpenAPI специфікації
2. Створіть адаптери для інтеграції з доменним шаром
3. Реалізуйте обробку помилок та аутентифікацію

### Крок 4.2: Реалізація спільних утиліт
1. Створіть утиліти для форматування, валідації, роботи з датами тощо
2. Реалізуйте спільні хуки, які не прив'язані до конкретних доменів
3. Створіть утиліти для логування та дебагінгу

### Крок 4.3: Реалізація спільних UI компонентів
1. Створіть бібліотеку базових UI компонентів (атоми, молекули, організми)
2. Реалізуйте компоненти для відображення помилок, завантаження тощо
3. Створіть компоненти для форм, таблиць, модальних вікон тощо

## Етап 5: Інтеграція з Next.js

### Крок 5.1: Реалізація сторінок
1. Створіть сторінки з використанням App Router або Pages Router
2. Інтегруйте фічі в сторінки
3. Реалізуйте маршрутизацію та навігацію

### Крок 5.2: Реалізація серверних компонентів (для App Router)
1. Визначте, які компоненти повинні бути серверними
2. Адаптуйте доменний шар для роботи з серверними компонентами
3. Реалізуйте взаємодію між клієнтськими та серверними компонентами

### Крок 5.3: Реалізація API маршрутів (для Pages Router)
1. Створіть API маршрути для взаємодії з бекендом
2. Інтегруйте доменний шар з API маршрутами
3. Реалізуйте обробку помилок та аутентифікацію

## Етап 6: Тестування та оптимізація

### Крок 6.1: Тестування доменного шару
1. Напишіть юніт-тести для доменних сутностей, об'єктів-значень, сервісів та сценаріїв використання
2. Напишіть інтеграційні тести для репозиторіїв та API клієнтів
3. Реалізуйте моки для зовнішніх залежностей

### Крок 6.2: Тестування UI компонентів
1. Напишіть юніт-тести для UI компонентів
2. Напишіть інтеграційні тести для взаємодії між UI компонентами та доменними хуками
3. Реалізуйте моки для доменних хуків

### Крок 6.3: Оптимізація продуктивності
1. Оптимізуйте рендеринг UI компонентів (мемоізація, віртуалізація тощо)
2. Оптимізуйте доступ до даних (кешування, пагінація тощо)
3. Оптимізуйте розмір бандла (code splitting, tree shaking тощо)

## Етап 7: Документація та підтримка

### Крок 7.1: Документація архітектури
1. Задокументуйте архітектуру системи
2. Опишіть доменні моделі та їх взаємодію
3. Створіть діаграми для візуалізації архітектури

### Крок 7.2: Документація API
1. Задокументуйте публічні API доменів
2. Опишіть інтерфейси хуків та їх використання
3. Створіть приклади використання

### Крок 7.3: Підготовка до розширення
1. Визначте точки розширення системи
2. Створіть шаблони для нових доменів та фіч
3. Підготуйте інструкції для команди розробників

## Рекомендації щодо імплементації

### 1. Розділення відповідальності

- **Домени (DDD)**: Містять всю бізнес-логіку, валідацію, розрахунки, правила, стан та React-хуки
- **Фічі (FSD)**: Містять тільки UI компоненти, які отримують дані та обробники подій з доменів
- **Shared**: Містить спільні утиліти, API клієнти та UI компоненти

### 2. Строга типізація

- Використовуйте TypeScript з найсуворішими налаштуваннями (`strict: true`)
- Визначайте чіткі інтерфейси між доменами та UI
- Використовуйте Zod для валідації та генерації типів

### 3. Уникнення великих файлів

- Розбивайте логіку на малі, спеціалізовані модулі
- Дотримуйтесь принципу Single Responsibility (SRP)
- Використовуйте композицію для об'єднання функціональності

### 4. Інтеграція з Zustand

- Створюйте окремі сторі для кожної функціональної області в доменному шарі
- Використовуйте middleware для логування та дебагінгу
- Інкапсулюйте доступ до сторів через хуки в доменному шарі

### 5. Використання Zod

- Визначайте схеми в доменному шарі
- Використовуйте схеми для валідації вхідних даних
- Генеруйте типи на основі схем для узгодженості

### 6. Інтеграція з OpenAPI

- Використовуйте генеровані типи з OpenAPI для API клієнтів
- Створюйте адаптери для перетворення API-моделей в доменні сутності
- Інкапсулюйте роботу з API в репозиторіях

### 7. Взаємодія між доменами

- Використовуйте події для комунікації між доменами
- Створюйте чіткі інтерфейси для взаємодії
- Уникайте прямих залежностей між доменами

### 8. Взаємодія між доменами та UI

- UI компоненти отримують дані та обробники подій з доменних хуків
- Доменні хуки інкапсулюють всю логіку роботи з доменом
- UI компоненти не містять бізнес-логіки або стану
