# Правила проекту Aksi-app (Java Spring + Next.js)

## 1. Середовище розгортання
- Проект працює ВИКЛЮЧНО в Docker-середовищі
- Всі сервіси комунікують через Docker-імена (backend, postgres, frontend)
- НЕ використовувати localhost для комунікації між контейнерами

## 2. API шляхи та контекстний шлях
- Spring Boot налаштовано з контекстним шляхом `server.servlet.context-path: /api`
- Всі запити до бекенду ПОВИННІ включати префікс `/api`
- Правильний формат URL: `${SERVER_API_URL}/api/resource_path`
- НЕПРАВИЛЬНИЙ формат URL: `${SERVER_API_URL}/resource_path`
- OpenAPI - у frontend /lib/api
- Ми використовуємо OpenAPI для взаємодії з бекендом

### 2.1. Узгоджений формат URL для ВСІХ типів запитів:

1. Запити з Next.js API роутів до бекенду:
   ```typescript
   import { SERVER_API_URL } from '@/constants/urls';
   const url = `${SERVER_API_URL}/api/clients`;
   ```

2. Запити від клієнтського React коду до Next.js API:
   ```typescript
   import { CLIENT_API_URL } from '@/constants/urls';
   const url = `${CLIENT_API_URL}/clients`;
   ```

## 3. Next.js проксі-конфігурація (next.config.ts)
- Для локальної розробки: destination: 'http://localhost:8080/resource_path'
- Не змінювати на Docker-імена в конфігурації проксі

## 4. URL-константи
- SERVER_API_URL = 'http://backend:8080' - для прямих запитів з Next.js до бекенду
- CLIENT_API_URL = '/api' - для клієнтських запитів, які проксіюються через Next.js
- API_PREFIX = '/api' - контекстний шлях Spring Boot для ручного формування URL

## 5. OpenAPI клієнти в проекті
- Використовуємо автоматично згенеровані API клієнти з `/lib/api/generated`
- Для генерації API клієнтів використовуємо команду `npm run generate-api:docker`
- НЕ МОЖНА імпортувати напряму з `/lib/api/generated` - використовуйте індексні файли

### 5.1. Правильне використання API клієнтів

1. Для клієнтської частини React використовуємо хуки з features:
   ```typescript
   // Правильний імпорт
   import { useClients } from '@/features/clients/api';
   ```

2. Для API роутів використовуємо безпосередні запити до бекенду:
   ```typescript
   // У Next.js API роутах - прямі запити
   const response = await fetch(`${SERVER_API_URL}/api/clients/search`, {
     method: 'POST',
     headers: { ... },
   });
   ```

3. НЕ використовуйте форми з прямою відправкою на URL - завжди використовуйте fetch або API клієнти

## 6. Узгодженість типізації
- Не змішувати різні інтерфейси Client з різних файлів
- Використовувати перевірки на null/undefined для безпечної роботи з властивостями об'єктів
- Використовувати типи та інтерфейси з `/lib/api/generated/models` та `/lib/api/generated/schemas`

## 7. Feature-Sliced Design (FSD)
- Усі модулі організовуємо згідно з FSD архітектурою:
  - `/model` - усі типи, інтерфейси, енуми, функції конверсії
  - `/api` - усі взаємодії з API (хуки, функції запитів)
  - `/ui` - усі React-компоненти
  - `/hooks` - React-хуки для бізнес-логіки
  - `/lib` - утиліти та допоміжний код

## 8. Дата-адаптери
- Використовувати dayjs для обробки дат
- Не використовувати date-fns для обробки дат

## 9. Реальні дані
- Використовувати реальні дані для заповнення полів форм
- Використовувати реальні дані для заповнення відображених полів форм
- У проекті мають використовуватися виключно реальні дані, без різних мокових та фейкових даних

## 10. URL Структура в контролерах
- У контролерах бекенду НЕ додавайте `/api` до маршрутів - контекстний шлях додається автоматично
- Правильно: `@RequestMapping("/clients")` → доступний як `/api/clients`
- НЕПРАВИЛЬНО: `@RequestMapping("/api/clients")` → подвійний префікс `/api/api/clients`

## 11. MUI7 Grid
- Використовуйте MUI7 Grid для розташування компонентів
- НЕ використовувати атрибут `item` (видалено у MUI7)
- Використовувати атрибут `size` замість окремих `xs`, `sm`, `md`, `lg`, `xl`
- Приклад:
```typescript
<Grid size={{ xs: 12, sm: 6 }}>
  {/* Компоненти */}
</Grid>
```

## 12. ESLint та перевірка коду
- Використовувати ESLint для перевірки коду
- Використовувати команду `npm run lint` для перевірки коду
- Виправляти всі помилки та попередження ESLint перед коммітом
- Не ігнорувати помилки типізації та лінтингу

## 13. Обов'язкові бібліотеки для OrderWizard

- Використовувати наступні бібліотеки для розробки OrderWizard:

### 13.1. React Hook Form
- Використовувати для всіх форм у OrderWizard
- Інтегрувати з Zod для валідації даних
- Застосовувати `useFieldArray` для динамічних списків (предмети, дефекти, тощо)

### 13.2. TanStack Query
- Використовувати `useQuery` для всіх GET запитів
- Використовувати `useMutation` для всіх POST/PUT/DELETE запитів
- Застосовувати кешування та інвалідацію для оптимізації

### 13.3. Zustand
- Створити машину станів для всього OrderWizard
- Визначити всі стани та переходи
- Використовувати для навігації між етапами

### 13.4. Принципи інтеграції
- Типізація: використовувати типи, згенеровані з Zod схем
- Зменшення бойлерплейта: уникати ручного копіювання станів
- Тестування: писати тести для машин станів Zustand
- FSD підхід: структура файлів для OrderWizard

### 14

