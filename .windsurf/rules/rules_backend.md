---
trigger: always_on
---

# Інструкція для розробки бекенду проекту "Хімчистка AKSI"

## Технологічний стек бекенду

- **Архітектурний підхід:** Domain-Driven Design (DDD)
- **Фреймворк:** Spring Boot 3.4.4
- **Мова:** Java 21
- **База даних:** PostgreSQL 17
- **ORM:** Hibernate/Spring Data JPA
- **API:** REST (Spring Web)
- **Документація API:** Swagger/OpenAPI
- **Автентифікація:** Spring Security + JWT
- **Валідація:** Jakarta Validation (Hibernate Validator)
- **Маппінг об'єктів:** MapStruct 1.6.3, Lombok 1.18.38
- **Логування:** SLF4J + Logback
- **Тестування:** JUnit 5.12.1, Mockito
- **Міграції БД:** Liquibase 4.31.1
- **PDF Генерація:** iTextPDF 5.5.13.4
- **QR Code:** ZXing 3.5.3
- **Email:** Spring Mail

## Архітектурні принципи DDD для бекенду

### Сутності (Entity)
- **ОБОВ'ЯЗКОВО** мають суфікс "Entity" (ClientEntity, OrderEntity)
- Містять бізнес-логіку, пов'язану з ними
- Об'єднуються в агрегати

### Агрегати (Aggregate)
- Групи об'єктів, які розглядаються як єдине ціле
- Мають кореневу сутність (Aggregate Root)
- Забезпечують узгодженість даних

### Репозиторії (Repository)
- Абстракції для доступу до даних
- Один репозиторій для одного агрегату
- Використовують Spring Data JPA

### Сервіси домену (Domain Services)
- Операції, які не належать до сутностей
- Містять бізнес-логіку, що охоплює декілька сутностей
- Транзакційна логіка

### Об'єкти передачі даних (DTO)
- \*Request класи для вхідних даних
- \*Response класи для вихідних даних
- \*DTO класи для внутрішнього обміну

## Структура бази даних

### Клієнти та комунікація
- **clients** - інформація про клієнтів
- **client_communication_channels** - канали комунікації з клієнтами

### Замовлення та предмети
- **orders** - замовлення клієнтів
- **order_items** - предмети в замовленні
- **order_item_photos** - фотографії предметів

### Ціноутворення та категорії
- **service_categories** - категорії послуг
- **price_list_items** - елементи прайс-листа

### Філії та користувачі
- **branch_locations** - філії хімчистки
- **users** - користувачі системи
- **login** - дані для входу

## Важливі правила для бекенду

### 1. API структура
- Контекстний шлях бекенду: `/api`
- У контролерах не додавати `/api` до маршрутів (додається автоматично)
- Правильно: `@RequestMapping("/clients")`
- **НЕПРАВИЛЬНО**: `@RequestMapping("/api/clients")`

### 2. JPA сутності
- **ОБОВ'ЯЗКОВО** додавати суфікс "Entity" до назв сутностей
- Правильно: `ClientEntity`, `OrderEntity`
- **НЕПРАВИЛЬНО**: `Client`, `Order`
- Це гарантує чітке розмежування типів об'єктів

### 3. Міграції Liquibase
- Завжди створювати нові міграції для змін у БД
- Не змінювати вже застосовані файли міграцій
- Використовувати відповідний формат іменування: `db.changelog-X.Y.yaml`

### 4. DDD найменування доменних об'єктів
- Називати класи відповідно до їх ролі в DDD:
  - Сутності: `*Entity.java`
  - Репозиторії: `*Repository.java`
  - Сервіси: `*Service.java` і `*ServiceImpl.java`
  - DTO: `*Request.java`, `*Response.java`, `*DTO.java`

## Процес додавання нової сутності в DDD

При створенні нових доменних об'єктів дотримуйтесь наступного порядку:

1. **Створення Entity класу** в пакеті відповідного домену
   - Додати JPA анотації
   - Налаштувати зв'язки з іншими сутностями
   - Вказати анотації для валідації

2. **Створення Repository інтерфейсу** для сутності
   - Наслідуватись від JpaRepository

3. **Створення міграції бази даних** з Liquibase
   - Додати новий changeSet

4. **Створення DTO класів** для передачі даних між шарами
   - Визначити класи запитів та відповідей

5. **Створення Mapper інтерфейсу** для конвертації між Entity та DTO
   - Використовувати MapStruct

### Приклад коду

```java
// 1. Entity
@Entity
@Table(name = "products")
public class ProductEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false)
    private String name;

    // інші поля
}

// 2. Repository
public interface ProductRepository extends JpaRepository<ProductEntity, UUID> {
    // додаткові методи пошуку
}
```

## Docker середовище для бекенду

- **backend** - Spring Boot додаток
- **postgres** - PostgreSQL база даних

Взаємодія між контейнерами:
- PostgreSQL доступний для backend як `jdbc:postgresql://postgres:5432/aksi_db`
- Використовувати Docker-імена для комунікації (не localhost)

## Важливі зауваження та запобігання типовим помилкам

- **Завжди синхронізуйте міграції** з Entity класами
- **Не змінюйте існуючі міграції** - створюйте нові для модифікації схеми
- **Перевіряйте міграції** на локальному оточенні перед коммітом
- **Дотримуйтесь naming conventions** - snake_case для таблиць, PascalCase для Java класів
- **Уникайте змішування різних інтерфейсів** для однакових сутностей
- **Не використовуйте неперевірені дані** в SQL запитах для запобігання ін'єкціям