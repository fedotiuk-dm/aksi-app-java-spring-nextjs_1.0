# План рефакторингу сутностей DefectTypeEntity та StainTypeEntity

## Огляд проблеми

У поточній кодовій базі класи `DefectTypeEntity` та `StainTypeEntity` мають практично ідентичну структуру, що призводить до дублювання коду. Вони використовуються для зберігання інформації про типи дефектів та плям відповідно, але мають однакові поля та поведінку.

Аналіз плагіна PMD (Copy-Paste Detector) підтвердив значне дублювання.

## Запропоновані зміни

1. Створити абстрактний базовий клас `AbstractItemIssueEntity`
2. Перенести спільну логіку та поля з `DefectTypeEntity` та `StainTypeEntity` в базовий клас
3. Винести `RiskLevel` enum в окремий файл для централізованого використання
4. Спростити та оновити похідні класи

## Крок за кроком

### Етап 1: Створення базової структури

1. ✅ Створити абстрактний базовий клас `AbstractItemIssueEntity` з анотацією `@MappedSuperclass`
2. ✅ Створити окремий enum `RiskLevel` у пакеті `com.aksi.domain.pricing.enums`
3. ✅ Оновити `DefectTypeEntity` та `StainTypeEntity` для успадкування від базового класу

### Етап 2: Оновлення DTO та маперів (в процесі)

1. Для кожної DTO-сутності оновити використання `RiskLevel`:

   - `DefectTypeDTO`
   - `StainTypeDTO`
   - `DefectTypeResponse`
   - `StainTypeResponse`
   - `DefectTypeRequest`
   - `StainTypeRequest`

2. Оновити мепери для обох типів сутностей:
   - `DefectTypeMapper`
   - `StainTypeMapper`

### Етап 3: Оновлення референсів (в процесі)

Виконати пошук та замінити всі імпорти і використання:

1. `DefectTypeEntity.RiskLevel` -> `com.aksi.domain.pricing.enums.RiskLevel`
2. `StainTypeEntity.RiskLevel` -> `com.aksi.domain.pricing.enums.RiskLevel`

### Етап 4: Оновлення репозиторіїв та запитів (в процесі)

Оновити запити у репозиторіях, де використовуються RiskLevel:

- `DefectTypeRepository`
- `StainTypeRepository`

### Етап 5: Оновлення сервісів та контролерів (в процесі)

Оновити всі реалізації сервісів та контролерів:

- `DefectTypeServiceImpl`
- `StainTypeServiceImpl`
- `DefectTypeController`
- `StainTypeController`
- `ModifierRecommendationServiceImpl`
- `ItemCharacteristicsServiceImpl`

### Етап 6: Міграція даних та тестування (в процесі)

1. Створити DB Liquibase міграцію, якщо потрібні зміни в схемі (у цьому випадку не потрібно)
2. Написати/оновити модульні тести для оновлених класів
3. Перевірити інтеграційні тести

## Переваги рефакторингу

1. **Усунення дублювання коду** - зменшення повторення однакової логіки
2. **Централізована зміна поведінки** - оновлення в одному місці впливає на обидва типи
3. **Дотримання DRY принципу** - один і той же код не повторюється
4. **Легше додавання нових типів проблем** - можна створити нову сутність, успадковуючи базовий клас
5. **Покращена підтримуваність** - зміни потрібно вносити в одному місці

## Майбутні можливості

Після цього рефакторингу можна продовжити покращення архітектури:

1. Розглянути створення спільного інтерфейсу сервісів для цих сутностей
2. Реалізувати шаблон "Стратегія" для специфічної логіки обробки різних типів проблем
3. Створити абстрактний контролер з базовими CRUD операціями
