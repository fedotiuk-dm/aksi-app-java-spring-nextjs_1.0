# Реалізація Order Wizard за допомогою FSD підходу в Next.js

## Загальна архітектура реалізації

Order Wizard реалізовано за допомогою Feature-Sliced Design (FSD) на фронтенді з використанням Next.js та MUI v7, при цьому вся бізнес-логіка (розрахунки цін, обробка даних) знаходиться на бекенді (Java Spring).

## Структура директорій за FSD

StrucКожен компонент та модуль у структурі розроблено відповідно до принципів Feature-Sliced Design, з чітким поділом відповідальності. Нижче наведено докладну структуру директорій з поясненнями:

```
features/                           # Верхній рівень для всіх функціональних можливостей
├── order-wizard/                    # Фіча Order Wizard для оформлення замовлень
│   ├── model.ts                     # Основні типи, інтерфейси та константи для всього Order Wizard
│   │                                # Містить типи OrderWizardState, OrderWizardStep, WizardConfig
│   ├── api.ts                       # Глобальні API-функції для роботи з замовленнями
│   │                                # createOrder, getOrders, finalizeOrder, exportReceipt
│   ├── lib.ts                       # Загальні утиліти та хуки для всіх компонентів OrderWizard
│   │                                # useWizardNavigation, useAutoSave, formatOrderData
│   ├── components/                  # Папка з усіма компонентами Order Wizard
│   │   ├── wizard-container/        # Контейнерний компонент для керування всім візардом
│   │   │   ├── model.ts             # Типи для контейнера: WizardContainerProps, WizardStep
│   │   │   ├── api.ts               # API для роботи зі станом візарда (збереження стану між сесіями)
│   │   │   │                        # saveWizardState, loadWizardState, resetWizardState
│   │   │   ├── lib.ts               # Утиліти для навігації між кроками та валідації всього візарда
│   │   │   │                        # validateWizardStep, calculateStepCompletion, navigateToStep
│   │   │   ├── ui/                  # UI компоненти для контейнера
│   │   │   │   ├── WizardStepIndicator.tsx  # Індикатор поточного кроку та прогресу
│   │   │   │   │                            # Показує номери та назви кроків, поточний активний крок
│   │   │   │   ├── WizardNavigation.tsx     # Кнопки навігації між кроками
│   │   │   │   │                            # Містить кнопки "Назад", "Далі", "Завершити"
│   │   │   ├── index.tsx            # Головний компонент контейнера, інтегрує всі підкомпоненти
│   │   │   │                        # Керує відображенням поточного кроку та навігацією
│   │   │
│   │   ├── client-selection/        # Компонент вибору/створення клієнта (Етап 1.1)
│   │   │   ├── model.ts             # Типи для клієнтів: Client, ClientSearchParams, ContactMethod
│   │   │   │                        # Містить інтерфейси для форм пошуку та створення клієнта
│   │   │   ├── api.ts               # API для пошуку та створення клієнтів
│   │   │   │                        # searchClients, createClient, getClientById
│   │   │   ├── lib.ts               # Утиліти для валідації даних клієнта та форматування
│   │   │   │                        # validateClientData, formatPhone, parseClientData
│   │   │   ├── ui/                  # UI компоненти для роботи з клієнтами
│   │   │   │   ├── ClientSearch.tsx        # Компонент пошуку існуючих клієнтів
│   │   │   │   │                           # Форма з полями для введення прізвища/телефону
│   │   │   │   ├── ClientList.tsx          # Список знайдених клієнтів з можливістю вибору
│   │   │   │   │                           # Відображає результати пошуку клієнтів у табличному вигляді
│   │   │   │   ├── NewClientForm.tsx       # Форма для створення нового клієнта
│   │   │   │   │                           # Містить поля для ПІБ, телефону, email, адреси, способів зв'язку
│   │   │   ├── index.tsx            # Головний компонент, інтегрує пошук і створення клієнта
│   │   │   │                        # Реалізує логіку перемикання між пошуком та створенням
│   │   │
│   │   ├── order-info/              # Компонент базової інформації замовлення (Етап 1.2)
│   │   │   ├── model.ts             # Типи для базової інформації: OrderBasicInfo, ReceptionPoint
│   │   │   │                        # Описує структуру даних для номера квитанції, унікальної мітки
│   │   │   ├── api.ts               # API для роботи з базовою інформацією замовлення
│   │   │   │                        # generateReceiptNumber, getReceptionPoints
│   │   │   ├── lib.ts               # Утиліти для валідації та генерації даних
│   │   │   │                        # validateUniqueTag, generateTagPlaceholder 
│   │   │   ├── ui/                  # UI компоненти для базової інформації
│   │   │   │   ├── OrderBasicInfo.tsx      # Форма для введення базової інформації
│   │   │   │   │                           # Поля для номера квитанції, мітки, пункту прийому
│   │   │   ├── index.tsx            # Головний компонент базової інформації
│   │   │   │                        # Інтегрує всі дані про замовлення та оновлює стан візарда
│   │   │
│   │   ├── item-manager/            # Менеджер предметів замовлення (Етап 2.0)
│   │   │   ├── model.ts             # Типи для управління предметами: OrderItem, ItemAction
│   │   │   │                        # Описує структуру даних для списку предметів та їх відображення
│   │   │   ├── api.ts               # API для роботи зі списком предметів
│   │   │   │                        # getOrderItems, deleteOrderItem, reorderItems
│   │   │   ├── lib.ts               # Утиліти для обчислення загальної вартості та фільтрації
│   │   │   │                        # calculateTotalCost, filterItemsByCategory, sortItems
│   │   │   ├── ui/                  # UI компоненти для менеджера предметів
│   │   │   │   ├── ItemList.tsx            # Таблиця зі списком доданих предметів
│   │   │   │   │                           # Відображає колонки з назвою, кількістю, ціною
│   │   │   │   ├── ItemSummary.tsx         # Компонент з підсумковою інформацією
│   │   │   │   │                           # Показує кількість предметів, загальну вартість
│   │   │   ├── index.tsx            # Головний компонент менеджера предметів
│   │   │   │                        # Інтегрує список та кнопки для додавання/видалення
│   │   │
│   │   ├── item-wizard/             # Підвізард для додавання предмета (Етапи 2.1-2.5)
│   │   │   ├── model.ts             # Типи для предмета: ItemData, Category, Material, Defect
│   │   │   │                        # Описує всі можливі параметри предмета та їх структуру
│   │   │   ├── api.ts               # API для роботи з категоріями, цінами та додаванням предметів
│   │   │   │                        # getCategories, getItemsByCategory, calculateItemPrice
│   │   │   ├── lib.ts               # Утиліти для валідації даних предмета та підрахунку ціни
│   │   │   │                        # validateItemStep, applyPriceModifiers, formatItemData
│   │   │   ├── ui/                  # UI компоненти для кожного кроку підвізарда
│   │   │   │   ├── ItemBasicInfo.tsx       # Крок 2.1: Вибір категорії та найменування
│   │   │   │   │                           # Форма з вибором категорії, найменування, кількості
│   │   │   │   ├── ItemCharacteristics.tsx # Крок 2.2: Вибір характеристик предмета
│   │   │   │   │                           # Форма з вибором матеріалу, кольору, наповнювача
│   │   │   │   ├── ItemDefects.tsx         # Крок 2.3: Вибір забруднень та дефектів
│   │   │   │   │                           # Чекбокси для плям, дефектів, ризиків
│   │   │   │   ├── ItemPriceCalculator.tsx # Крок 2.4: Розрахунок ціни з модифікаторами
│   │   │   │   │                           # Відображає базову ціну та вплив кожного модифікатора
│   │   │   │   ├── ItemPhotoUpload.tsx     # Крок 2.5: Завантаження фото предмета
│   │   │   │   │                           # Інтерфейс для фотографування та анотування
│   │   │   │   ├── ItemSummary.tsx         # Підсумкова інформація про предмет
│   │   │   │   │                           # Показує всі вибрані параметри та ціну
│   │   │   │   ├── WizardStep.tsx          # Обгортка для кожного кроку підвізарда
│   │   │   │   │                           # Забезпечує однакове оформлення кожного кроку
│   │   │   ├── index.tsx            # Головний компонент для додавання предмета
│   │   │   │                        # Керує навігацією між кроками підвізарда
│   │   │
│   │   ├── order-params/            # Компонент загальних параметрів замовлення (Етап 3)
│   │   │   ├── model.ts             # Типи для параметрів: ExecutionParams, DiscountInfo, PaymentInfo
│   │   │   │                        # Описує структуру даних для термінів, знижок, оплати
│   │   │   ├── api.ts               # API для роботи з параметрами замовлення
│   │   │   │                        # calculateOrderTotal, validateDiscount
│   │   │   ├── lib.ts               # Утиліти для обчислення дати виконання та знижок
│   │   │   │                        # calculateExecutionDate, applyDiscount, validatePayment
│   │   │   ├── ui/                  # UI компоненти для параметрів замовлення
│   │   │   │   ├── ExecutionParams.tsx     # Компонент вибору параметрів виконання
│   │   │   │   │                           # Вибір дати та терміновості виконання
│   │   │   │   ├── DiscountSelector.tsx    # Компонент вибору типу знижки
│   │   │   │   │                           # Вибір знижки з урахуванням обмежень
│   │   │   │   ├── PaymentForm.tsx         # Форма для вибору способу оплати
│   │   │   │   │                           # Вибір методу та введення суми передоплати
│   │   │   ├── index.tsx            # Головний компонент параметрів замовлення
│   │   │   │                        # Інтегрує всі параметри та проводить фінальну валідацію
│   │   │
│   │   ├── order-receipt/           # Компонент формування квитанції (Етап 4)
│   │   │   ├── model.ts             # Типи для квитанції: Receipt, ReceiptItem, ExportFormat
│   │   │   │                        # Описує структуру даних для квитанції та експорту
│   │   │   ├── api.ts               # API для роботи з квитанцією
│   │   │   │                        # generateReceipt, finalizeOrder, exportReceipt
│   │   │   ├── lib.ts               # Утиліти для форматування даних квитанції
│   │   │   │                        # formatReceiptData, generatePdfMarkup, prepareExport
│   │   │   ├── ui/                  # UI компоненти для роботи з квитанцією
│   │   │   │   ├── ReceiptPreview.tsx      # Компонент для попереднього перегляду квитанції
│   │   │   │   │                           # Відображає всі розділи квитанції в гарному форматі
│   │   │   │   ├── ReceiptPrintButton.tsx  # Кнопка для друку квитанції
│   │   │   │   │                           # Викликає функцію друку з попереднім переглядом
│   │   │   │   ├── ReceiptExportOptions.tsx # Опції для експорту квитанції
│   │   │   │   │                           # Кнопки для експорту в PDF, DOCX, відправки на email
│   │   │   ├── index.tsx            # Головний компонент для роботи з квитанцією
│   │   │   │                        # Інтегрує перегляд, друк та експорт
│   │   │
│   ├── pages/                       # Сторінки для маршрутизації
│   │   ├── OrderWizardPage.tsx      # Головна сторінка Order Wizard
│   │   │                            # Підключає контейнер та обробляє параметри URL
│   ├── index.ts                     # Експорт публічного API всієї фічі
```

### Особливості структури файлів за FSD підходом:

1. **Модульна структура** - розбиття на маленькі модулі з чіткою відповідальністю
2. **Поділ на шари**:
   - `model.ts` - дані, типи, інтерфейси, константи (модель даних)
   - `api.ts` - взаємодія з бекендом через API-запити
   - `lib.ts` - бізнес-логіка, утиліти, хуки
   - `ui/` - компоненти інтерфейсу
   - `index.tsx` - публічне API модуля
3. **Гарантування чистих залежностей** - батьківські модулі не залежать від дочірніх
4. **Прозорість директорій** - структура директорій відображає логічну структуру додатку

## Реалізація кожного етапу Order Wizard за FSD підходом

### Етап 1: Клієнт та базова інформація замовлення

#### Модуль `client-selection`

**model.ts**
- Інтерфейси для клієнта (`Client`) та пошукового запиту (`ClientSearchParams`)
- Типи для результатів пошуку (`ClientSearchResult`)
- Енуми для способів зв'язку та джерел інформації

**api.ts**
- Функція `searchClients`: Відправляє запит на бекенд для пошуку клієнтів
  - URL: `${SERVER_API_URL}/api/clients/search`
  - Параметри: ім'я, телефон
- Функція `createClient`: Відправляє запит на створення нового клієнта
  - URL: `${SERVER_API_URL}/api/clients`
  - Метод: POST
  - Дані: інформація про клієнта

**lib.ts**
- Допоміжні функції для валідації телефону/email
- Функції для форматування даних клієнта

**ui/**
- `ClientSearch.tsx`: Форма пошуку клієнтів з полями для введення та кнопкою пошуку
- `ClientList.tsx`: Компонент для відображення результатів пошуку клієнтів з можливістю вибору
- `NewClientForm.tsx`: Форма для створення нового клієнта з усіма необхідними полями

**index.tsx**
- Головний компонент, який об'єднує пошук та створення клієнта

#### Модуль `order-info`

**model.ts**
- Інтерфейс для базової інформації про замовлення (`OrderBasicInfo`)
- Типи для пунктів прийому та статусів замовлення

**api.ts**
- Функція `generateReceiptNumber`: Запитує номер квитанції від бекенду
  - URL: `${SERVER_API_URL}/api/orders/generate-receipt-number`
- Функція `getReceptionPoints`: Отримує список пунктів прийому
  - URL: `${SERVER_API_URL}/api/reception-points`

**lib.ts**
- Функції для генерації та валідації унікальної мітки

**ui/**
- `OrderBasicInfo.tsx`: Форма з полями для номера квитанції, унікальної мітки та вибору пункту прийому

**index.tsx**
- Компонент, який об'єднує всі елементи базової інформації замовлення

### Етап 2: Менеджер предметів

#### Модуль `item-manager`

**model.ts**
- Інтерфейс для предмета у таблиці (`OrderItem`)
- Типи для дій з предметами

**api.ts**
- Функція `getOrderItems`: Отримує список предметів у поточному замовленні
  - URL: `${SERVER_API_URL}/api/orders/draft/${draftId}/items`
- Функція `deleteOrderItem`: Видаляє предмет із замовлення
  - URL: `${SERVER_API_URL}/api/orders/draft/${draftId}/items/${itemId}`
  - Метод: DELETE

**lib.ts**
- Функції для обчислення загальної вартості замовлення
- Функції для перетворення даних предметів для відображення

**ui/**
- `ItemList.tsx`: Таблиця зі списком доданих предметів та можливістю редагування/видалення
- `ItemSummary.tsx`: Компонент для відображення загальної вартості та підсумкової інформації

**index.tsx**
- Головний компонент для менеджера предметів, включає список та елементи управління

#### Модуль `item-wizard`

**model.ts**
- Інтерфейси для кожного етапу додавання предмета (`ItemBasicInfo`, `ItemCharacteristics`, тощо)
- Типи для категорій, найменувань та характеристик предметів
- Енуми для матеріалів, кольорів та інших параметрів

**api.ts**
- Функція `getCategories`: Отримує список категорій послуг
  - URL: `${SERVER_API_URL}/api/catalog/categories`
- Функція `getItemsByCategory`: Отримує список предметів для обраної категорії
  - URL: `${SERVER_API_URL}/api/catalog/categories/${categoryId}/items`
- Функція `getMaterialsByCategory`: Отримує список доступних матеріалів для категорії
  - URL: `${SERVER_API_URL}/api/catalog/categories/${categoryId}/materials`
- Функція `calculateItemPrice`: Відправляє запит на розрахунок ціни предмета
  - URL: `${SERVER_API_URL}/api/price-calculations/calculate`
  - Метод: POST
  - Дані: параметри предмета для розрахунку
- Функція `addItemToOrder`: Додає предмет до замовлення
  - URL: `${SERVER_API_URL}/api/orders/draft/${draftId}/items`
  - Метод: POST
  - Дані: інформація про предмет

**lib.ts**
- Функції для управління станом візарда
- Функції для валідації даних на кожному кроці
- Функції для підготовки даних для відправки на бекенд

**ui/**
- `ItemBasicInfo.tsx`: Форма для вибору категорії, найменування та кількості предмета
- `ItemCharacteristics.tsx`: Форма для вибору матеріалу, кольору та інших характеристик
- `ItemDefects.tsx`: Форма для вибору забруднень, дефектів та ризиків
- `ItemPriceCalculator.tsx`: Компонент для відображення розрахунку ціни з модифікаторами
- `ItemPhotoUpload.tsx`: Компонент для завантаження та анотування фотографій
- `ItemSummary.tsx`: Підсумкова інформація про предмет перед додаванням до замовлення
- `WizardStep.tsx`: Компонент-обгортка для кожного кроку підвізарда

**index.tsx**
- Головний компонент, який керує логікою підвізарда та об'єднує всі кроки

### Етап 3: Загальні параметри замовлення

#### Модуль `order-params`

**model.ts**
- Інтерфейси для параметрів виконання (`ExecutionParams`), знижок (`DiscountInfo`) та оплати (`PaymentInfo`)
- Типи для методів оплати та типів знижок

**api.ts**
- Функція `calculateOrderTotal`: Запитує підсумкову вартість замовлення з урахуванням всіх параметрів
  - URL: `${SERVER_API_URL}/api/price-calculations/order-total`
  - Метод: POST
  - Дані: параметри замовлення і знижок
- Функція `validateDiscount`: Перевіряє можливість застосування знижки до замовлення
  - URL: `${SERVER_API_URL}/api/discounts/validate`
  - Метод: POST
  - Дані: ідентифікатор замовлення та тип знижки

**lib.ts**
- Функції для обчислення дати виконання на основі предметів
- Функції для перетворення даних про знижки та оплату

**ui/**
- `ExecutionParams.tsx`: Компонент для вибору дати виконання та терміновості
- `DiscountSelector.tsx`: Компонент для вибору типу знижки
- `PaymentForm.tsx`: Форма для вибору методу оплати та введення суми передоплати

**index.tsx**
- Головний компонент для параметрів замовлення

### Етап 4: Підтвердження та квитанція

#### Модуль `order-receipt`

**model.ts**
- Інтерфейси для квитанції (`Receipt`) та її складових частин
- Типи для форматів експорту

**api.ts**
- Функція `generateReceipt`: Запитує генерацію квитанції на бекенді
  - URL: `${SERVER_API_URL}/api/orders/${orderId}/receipt`
- Функція `finalizeOrder`: Завершує створення замовлення
  - URL: `${SERVER_API_URL}/api/orders/finalize`
  - Метод: POST
  - Дані: ідентифікатор замовлення
- Функція `exportReceipt`: Експортує квитанцію у вибраному форматі
  - URL: `${SERVER_API_URL}/api/orders/${orderId}/receipt/export`
  - Параметри: формат (PDF, DOCX)

**lib.ts**
- Функції для форматування даних квитанції
- Функції для локальної обробки PDF

**ui/**
- `ReceiptPreview.tsx`: Компонент для попереднього перегляду квитанції
- `ReceiptPrintButton.tsx`: Кнопка для друку квитанції
- `ReceiptExportOptions.tsx`: Опції для експорту квитанції у різних форматах

**index.tsx**
- Головний компонент для відображення квитанції та завершення замовлення

## Взаємодія з бекендом та API інтеграція

### Загальний підхід до API інтеграції

1. **Централізація API запитів**:
   - Усі API запити зосереджені у файлах `api.ts` відповідних модулів
   - Використовується константа `SERVER_API_URL` з `constants/urls.ts` для формування URL-адрес
   - Всі запити до бекенду включають префікс `/api` для відповідності контекстному шляху Spring Boot

2. **Обробка автентифікації**:
   - Кожен запит до бекенду включає JWT-токен з HttpOnly cookies
   - Передача токена відбувається автоматично завдяки налаштуванням проксі у Next.js

3. **Обробка помилок**:
   - Кожен API запит обгортається блоком try-catch
   - Помилки обробляються за допомогою зрозумілих повідомлень
   - Структуровані коди помилок мапляться на відповідні повідомлення користувачу

4. **Кешування та оптимізація**:
   - Використання React Query для кешування і управління станом API запитів
   - Оптимізація запитів за допомогою відкладених та пакетних запитів

### Ключові API роути для OrderWizard

| Етап | API маршрут | Опис |
|------|-------------|------|
| 1 | `/api/clients/search` | Пошук клієнтів за критеріями |
| 1 | `/api/clients` | Створення нового клієнта |
| 1 | `/api/orders/draft` | Створення чернетки замовлення |
| 2 | `/api/catalog/categories` | Отримання списку категорій послуг |
| 2 | `/api/catalog/categories/{id}/items` | Отримання списку предметів за категорією |
| 2 | `/api/price-calculations/calculate` | Розрахунок ціни для предмета з модифікаторами |
| 2 | `/api/orders/draft/{id}/items` | Додавання предмета до замовлення |
| 3 | `/api/price-calculations/order-total` | Розрахунок загальної вартості з урахуванням знижок |
| 3 | `/api/discounts/validate` | Перевірка можливості застосування знижки |
| 4 | `/api/orders/finalize` | Завершення створення замовлення |
| 4 | `/api/orders/{id}/receipt` | Генерація квитанції |

## Управління станом

1. **Локальний стан**: 
   - Стан окремих компонентів у межах одного кроку
   - Використовується React useState

2. **Глобальний стан Order Wizard**:
   - Zustand сховище для збереження стану всього візарда
   - Зберігає дані між етапами при навігації
   - Підтримує можливість повернення до попередніх кроків

3. **Серверний стан**:
   - Використання React Query для управління даними з API
   - Дані клієнтів, категорій, прайс-листів та інших сутностей

4. **Збереження стану при навігації**:
   - Автоматичне збереження чернетки замовлення на бекенді
   - Можливість відновлення роботи з чернеткою

## Адаптивний дизайн та UX

1. **Оптимізація для планшетів і тач-інтерфейсів**:
   - Збільшені елементи керування
   - Адаптовані форми з використанням MUI v7
   - Використання Grid Component: `<Grid container spacing={2}><Grid size={{ xs: 12, sm: 6 }}>...</Grid></Grid>`

2. **Поетапна валідація**:
   - Валідація даних на кожному кроці
   - Зрозумілі повідомлення про помилки
   - Візуальне виділення некоректних полів

3. **Оптимізація продуктивності**:
   - Ледаче завантаження компонентів
   - Оптимізація рендерингу з використанням мемоізації
   - Виділення важкої бізнес-логіки на бекенд

## Практична реалізація компонентів за допомогою MUI v7

1. **Файлова структура компонентів**:
   - Кожен візуальний компонент у відповідній папці `/ui`
   - Мінімальні компоненти для полегшення тестування
   - Розподіл відповідальності за FSD принципами

2. **Спільні принципи компонентів**:
   - Використання MUI v7 Grid з правильною структурою: `size` замість `xs`, `sm`, без атрибуту `item`
   - Кожен компонент фокусується лише на одній відповідальності
   - Максимальний розмір файлу компонента - 200-300 рядків

3. **Інтеграція з бекендом**:
   - Всі розрахунки виконуються на бекенді
   - Інтерфейс відображає результати, отримані з API
   - Асинхронне оновлення даних під час взаємодії користувача

## Інтеграція з базою даних

### Структура даних

Вся робота з базою даних відбувається на бекенді, фронтенд отримує вже готові дані через API. За FSD підходом, структура даних відображається у файлах `model.ts` кожного компонента:

#### Модуль `catalog`

**model.ts**
- Інтерфейси та типи для роботи з прайс-листом:
  ```typescript
  // Категорії послуг
  interface ServiceCategory {
    id: number;
    code: string;
    name: string;
    description: string;
  }

  // Елемент прайс-листа
  interface PriceListItem {
    id: number;
    categoryId: number;
    itemNumber: number;
    name: string;
    unit: 'pieces' | 'kg';
    basePrice: number;
    blackColorPrice?: number;
  }
  ```

#### Модуль `order-wizard/lib.ts`

**Підхід до роботи з коефіцієнтами**
- Незважаючи на те, що самі розрахунки виконуються на бекенді, фронтенд містить кеш коефіцієнтів для відображення у UI:
  ```typescript
  // У бекенді коефіцієнти не зберігаються в базі даних, а є частиною бізнес-логіки
  // Фронтенд отримує готові коефіцієнти з API
  const priceModifiers = {
    CHILDREN_CLOTHES: 0.7, // 30% знижка
    MANUAL_CLEANING: 1.2,  // +20% до вартості
    VERY_DIRTY: 1.2,       // +20% до вартості
    // інші коефіцієнти
  };
  ```

### Кеш та оптимізація запитів

#### Модуль `catalog/api.ts`

**Використання React Query для кешування**
- Впровадження кешування категорій та прайс-листів:
  ```typescript
  export const useCatalogCategories = () => {
    return useQuery({
      queryKey: ['catalog', 'categories'],
      queryFn: () => fetchCategories(),
      staleTime: 1000 * 60 * 10, // 10 хвилин
    });
  };

  export const usePriceListByCategory = (categoryId: number) => {
    return useQuery({
      queryKey: ['priceList', categoryId],
      queryFn: () => fetchPriceListItems(categoryId),
      staleTime: 1000 * 60 * 5, // 5 хвилин
      enabled: !!categoryId,
    });
  };
  ```

## Безпека та збереження даних

### Автозбереження та чернетки

#### Модуль `order-wizard` 

**api.ts**
- Функції для роботи з чернетками замовлень:
  ```typescript
  // Створення нової чернетки
  export const createDraftOrder = async (clientId: number) => {
    const response = await fetch(`${SERVER_API_URL}/api/orders/draft`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ clientId }),
    });
    return await response.json();
  };

  // Збереження чернетки
  export const saveDraftOrder = async (draftId: number, draftData: any) => {
    const response = await fetch(`${SERVER_API_URL}/api/orders/draft/${draftId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(draftData),
    });
    return await response.json();
  };
  ```

**lib.ts**
- Функції для автоматичного збереження:
  ```typescript
  // Автоматичне збереження чернетки кожні 30 секунд або при значущих змінах
  export const useAutosave = (draftId: number, draftData: any) => {
    useEffect(() => {
      const autosaveInterval = setInterval(() => {
        if (draftId && draftData) {
          saveDraftOrder(draftId, draftData).catch(console.error);
        }
      }, 30000);
      
      return () => clearInterval(autosaveInterval);
    }, [draftId, draftData]);
  };
  ```

### Валідація даних

#### Модуль `client-selection/lib.ts`

**Функції валідації**
- Впровадження валідації даних перед відправкою на сервер:
  ```typescript
  // Валідація телефону
  export const validatePhone = (phone: string): boolean => {
    // Перевірка на валідний український номер телефону
    const phoneRegex = /^\+?380\d{9}$/;
    return phoneRegex.test(phone);
  };

  // Валідація email
  export const validateEmail = (email: string): boolean => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return email ? emailRegex.test(email) : true; // email необов'язковий
  };
  ```

#### Модуль `item-wizard/lib.ts`

**Валідація даних предмета**
- Функції для валідації даних предмета перед додаванням до замовлення:
  ```typescript
  export const validateItemData = (itemData: ItemData): { isValid: boolean, errors: Record<string, string> } => {
    const errors: Record<string, string> = {};
    
    if (!itemData.categoryId) {
      errors.categoryId = 'Категорія обов\'язкова';
    }
    
    if (!itemData.itemId) {
      errors.itemId = 'Найменування виробу обов\'язкове';
    }
    
    if (!itemData.quantity || itemData.quantity <= 0) {
      errors.quantity = 'Кількість повинна бути більше 0';
    }
    
    // Інші перевірки залежно від вибраної категорії
    
    return {
      isValid: Object.keys(errors).length === 0,
      errors
    };
  };
  ```

## Оптимізація продуктивності

### Поетапне завантаження даних

#### Модуль `order-wizard/item-wizard`

**api.ts**
- Завантаження тільки потрібних даних на кожному етапі:
  ```typescript
  // Завантаження матеріалів тільки після вибору категорії
  export const useMaterialsByCategory = (categoryId: number | null) => {
    return useQuery({
      queryKey: ['materials', categoryId],
      queryFn: () => fetchMaterialsByCategory(categoryId!),
      enabled: !!categoryId, // запит виконується тільки якщо вибрана категорія
      staleTime: 1000 * 60 * 10, // 10 хвилин
    });
  };
  ```

### Оптимізація рендерингу компонентів

#### Модуль `item-wizard/ui/ItemPriceCalculator.tsx`

**Використання мемоізації**
- Мемоізація складних компонентів для запобігання непотрібних перерендерів:
  ```typescript
  const ItemPriceCalculator = React.memo(({ itemData, modifiers, basePrice }) => {
    // Відображення розрахунку ціни
    return (
      // UI компонент
    );
  });
  ```

### Кешування та повторне використання запитів

#### Загальний підхід до оптимізації запитів

1. **Поділ запитів на критичні та некритичні**:
   - Критичні (блокуючі) запити виконуються з відображенням індикатора завантаження
   - Некритичні запити виконуються у фоновому режимі

2. **Стратегії кешування запитів**:
   - Короткострокове кешування (5-10 хвилин) для прайс-листів і каталогів
   - Довгострокове кешування (годину або більше) для рідко змінюваних даних
   - Інвалідація кешу при створенні нових записів

3. **Пакетні запити**:
   - Об'єднання кількох запитів в один для зменшення кількості мережевих запитів
   - Використання API ендпоінтів, оптимізованих для пакетних операцій

## Адаптація для тач-інтерфейсів

### Оптимізація компонентів для планшетів

#### Модуль `order-wizard/ui`

**Адаптивні компоненти**
- Використання MUI v7 Grid для оптимізованого відображення на планшетах:
  ```typescript
  const ItemWizardStep = ({ children }) => {
    return (
      <Grid container spacing={2}>
        <Grid size={{ xs: 12, sm: 8, md: 6 }}>
          {children}
        </Grid>
      </Grid>
    );
  };
  ```

- Збільшені елементи керування для зручності використання на тач-екранах:
  ```typescript
  const TouchFriendlyButton = styled(Button)({
    padding: '16px 24px',
    fontSize: '1.2rem',
    '& .MuiSvgIcon-root': {
      fontSize: '1.5rem',
    },
  });
  ```

## Загальні висновки

Реалізація Order Wizard за FSD підходом забезпечує:
1. Чіткий розподіл відповідальності між компонентами
2. Модульність і гнучкість для оновлення окремих частин
3. Легку підтримку коду та розширення функціоналу
4. Оптимальне використання можливостей Next.js та MUI v7
5. Якісну інтеграцію з бекендом, де зосереджена вся бізнес-логіка
6. Ефективне кешування та оптимізацію продуктивності
7. Адаптивність для різних пристроїв, особливо планшетів
8. Надійну систему автозбереження та валідації даних

При цьому фронтенд відповідає виключно за відображення даних та взаємодію з користувачем, а вся складна бізнес-логіка (розрахунки вартості, правила знижок тощо) реалізована на бекенді.
