/**
 * Generated by orval v7.11.1 üç∫
 * Do not edit manually.
 * AKSI Dry Cleaning Order System API
 * API for dry cleaning order management system with Domain-Driven Design architecture. The system includes 13 domains: Auth, User, Customer, Branch, Employee, Order, OrderItem, Service, Garment, Pricing, Payment, Notification, and Analytics.
 * OpenAPI spec version: 1.0.0
 */
import {
  z as zod
} from 'zod';

/**
 * Authenticate operator and return session cookie
 * @summary Login to system
 */
export const loginBodyUsernameRegExp = new RegExp('^[a-zA-Z0-9_]{3,50}$');
export const loginBodyPasswordMin = 6;

export const loginBodyPasswordMax = 100;

export const loginBodyPasswordRegExp = new RegExp('^[a-zA-Z0-9\\s.,!?-]{1,255}$');


export const loginBody = zod.object({
  "username": zod.string().regex(loginBodyUsernameRegExp).describe('Operator username'),
  "password": zod.string().min(loginBodyPasswordMin).max(loginBodyPasswordMax).regex(loginBodyPasswordRegExp).describe('Password (min 6 chars for dev, 12 for prod)'),
  "rememberMe": zod.boolean().optional().describe('Remember session for 30 days'),
  "branchId": zod.object({
  "present": zod.boolean().optional()
}).optional()
})

export const loginResponseUsernameRegExp = new RegExp('^[a-zA-Z0-9_]{3,50}$');
export const loginResponseFirstNameRegExp = new RegExp('^[a-zA-Zs]{1,50}$');
export const loginResponseLastNameRegExp = new RegExp('^[a-zA-Zs]{1,50}$');
export const loginResponseRolesMax = 10;
export const loginResponsePermissionsItemMin = 0;

export const loginResponsePermissionsItemMax = 50;

export const loginResponsePermissionsItemRegExp = new RegExp('^[A-Z][A-Z_]*$');
export const loginResponsePermissionsMin = 0;

export const loginResponsePermissionsMax = 50;
export const loginResponseAttemptsRemainingMin = 0;


export const loginResponse = zod.object({
  "userId": zod.uuid().describe('User ID'),
  "username": zod.string().regex(loginResponseUsernameRegExp).describe('Username'),
  "firstName": zod.string().regex(loginResponseFirstNameRegExp).optional().describe('First name'),
  "lastName": zod.string().regex(loginResponseLastNameRegExp).optional().describe('Last name'),
  "roles": zod.array(zod.enum(['OPERATOR', 'MANAGER', 'ADMIN', 'CLEANER', 'DRIVER'])).min(1).max(loginResponseRolesMax).describe('User roles'),
  "permissions": zod.array(zod.string().min(loginResponsePermissionsItemMin).max(loginResponsePermissionsItemMax).regex(loginResponsePermissionsItemRegExp)).min(loginResponsePermissionsMin).max(loginResponsePermissionsMax).optional().describe('User permissions'),
  "branchId": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "branchName": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "requiresBranchSelection": zod.boolean().describe('Whether branch selection is required'),
  "isBlocked": zod.boolean().describe('Whether user account is blocked due to failed attempts'),
  "attemptsRemaining": zod.number().min(loginResponseAttemptsRemainingMin).describe('Number of login attempts remaining before lockout'),
  "lockoutExpiresAt": zod.object({
  "present": zod.boolean().optional()
}).optional()
})


/**
 * List all active sessions for current user or specified user (admin only)
 * @summary Get all user sessions
 */
export const getUserSessionsQueryParams = zod.object({
  "userId": zod.uuid().optional().describe('User ID to get sessions for (admin only, defaults to current user)')
})

export const getUserSessionsResponseSessionsItemSessionIdRegExp = new RegExp('^[a-zA-Z0-9\\s.,!?-]{1,255}$');
export const getUserSessionsResponseSessionsItemIpAddressRegExp = new RegExp('^\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}$');
export const getUserSessionsResponseSessionsItemUserAgentRegExp = new RegExp('^[a-zA-Z0-9s/().;-]{1,500}$');
export const getUserSessionsResponseSessionsMin = 0;

export const getUserSessionsResponseSessionsMax = 50;
export const getUserSessionsResponseCurrentSessionIdRegExp = new RegExp('^[a-zA-Z0-9\\s.,!?-]{1,255}$');


export const getUserSessionsResponse = zod.object({
  "sessions": zod.array(zod.object({
  "sessionId": zod.string().regex(getUserSessionsResponseSessionsItemSessionIdRegExp).describe('Session ID'),
  "createdAt": zod.iso.datetime({}).describe('Session creation time'),
  "lastAccessedAt": zod.iso.datetime({}).describe('Last access time'),
  "expiresAt": zod.iso.datetime({}).describe('Session expiration time'),
  "ipAddress": zod.string().regex(getUserSessionsResponseSessionsItemIpAddressRegExp).describe('IP address'),
  "userAgent": zod.string().regex(getUserSessionsResponseSessionsItemUserAgentRegExp).optional().describe('Browser user agent'),
  "location": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "deviceType": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "isCurrentSession": zod.boolean().describe('Is this the current session')
})).min(getUserSessionsResponseSessionsMin).max(getUserSessionsResponseSessionsMax).describe('List of user sessions'),
  "totalCount": zod.number().describe('Total number of sessions'),
  "currentSessionId": zod.string().regex(getUserSessionsResponseCurrentSessionIdRegExp).describe('Current session ID')
})


/**
 * Logout user from all devices except current session
 * @summary Terminate all other sessions
 */
export const terminateOtherSessionsResponseMessageRegExp = new RegExp('^[a-zA-Z0-9\\s.,!?-]{1,255}$');


export const terminateOtherSessionsResponse = zod.object({
  "terminatedCount": zod.number().describe('Number of sessions terminated'),
  "message": zod.string().regex(terminateOtherSessionsResponseMessageRegExp).describe('Success message')
})


/**
 * Information about current user and session
 * @summary Get current session info
 */
export const getCurrentSessionResponseSessionIdRegExp = new RegExp('^[a-zA-Z0-9]{20,64}$');
export const getCurrentSessionResponseUsernameRegExp = new RegExp('^[a-zA-Z0-9_]{3,50}$');
export const getCurrentSessionResponseRolesMin = 0;

export const getCurrentSessionResponseRolesMax = 10;
export const getCurrentSessionResponseCreatedAtRegExp = new RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{3})?Z$');
export const getCurrentSessionResponseLastAccessedAtRegExp = new RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{3})?Z$');
export const getCurrentSessionResponseExpiresAtRegExp = new RegExp('^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{3})?Z$');
export const getCurrentSessionResponseIpAddressRegExp = new RegExp('^\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}$');
export const getCurrentSessionResponseUserAgentRegExp = new RegExp('^[a-zA-Z0-9s/().;-]{1,500}$');


export const getCurrentSessionResponse = zod.object({
  "sessionId": zod.string().regex(getCurrentSessionResponseSessionIdRegExp).describe('Session ID'),
  "userId": zod.uuid().describe('User ID'),
  "username": zod.string().regex(getCurrentSessionResponseUsernameRegExp).describe('Username'),
  "roles": zod.array(zod.enum(['OPERATOR', 'MANAGER', 'ADMIN', 'CLEANER', 'DRIVER'])).min(getCurrentSessionResponseRolesMin).max(getCurrentSessionResponseRolesMax).optional(),
  "branchId": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "branchName": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "createdAt": zod.iso.datetime({}).regex(getCurrentSessionResponseCreatedAtRegExp).describe('Session creation time'),
  "lastAccessedAt": zod.iso.datetime({}).regex(getCurrentSessionResponseLastAccessedAtRegExp).describe('Last access time'),
  "expiresAt": zod.iso.datetime({}).regex(getCurrentSessionResponseExpiresAtRegExp).optional().describe('Session expiration time'),
  "ipAddress": zod.string().regex(getCurrentSessionResponseIpAddressRegExp).optional().describe('IP address'),
  "userAgent": zod.string().regex(getCurrentSessionResponseUserAgentRegExp).optional().describe('Browser user agent')
})


/**
 * Logout user from all devices (admin only)
 * @summary Terminate all sessions for user
 */
export const invalidateAllSessionsQueryParams = zod.object({
  "userId": zod.uuid().describe('User ID to invalidate sessions for')
})


/**
 * Returns current server timestamp for time synchronization between frontend and backend. Used to avoid hydration issues and ensure consistent time across client and server. 
 * @summary Get current server time
 */
export const getServerTimeResponseTimezoneRegExp = new RegExp('^[a-zA-Z0-9\\s.,!?-]{1,255}$');
export const getServerTimeResponseUtcOffsetRegExp = new RegExp('^[a-zA-Z0-9\\s.,!?-]{1,255}$');
export const getServerTimeResponseTimeRegExp = new RegExp('^[a-zA-Z0-9\\s.,!?-]{1,255}$');


export const getServerTimeResponse = zod.object({
  "timestamp": zod.iso.datetime({}).describe('Current server time in ISO 8601 format (UTC)'),
  "epochMillis": zod.number().describe('Current server time as Unix epoch milliseconds'),
  "timezone": zod.string().regex(getServerTimeResponseTimezoneRegExp).describe('Server timezone identifier'),
  "utcOffset": zod.string().regex(getServerTimeResponseUtcOffsetRegExp).describe('UTC offset for server timezone'),
  "date": zod.iso.date().optional().describe('Current server date (YYYY-MM-DD)'),
  "time": zod.string().regex(getServerTimeResponseTimeRegExp).optional().describe('Current server time (HH:mm:ss)')
})


/**
 * Returns JSON Web Key Set (JWKS) containing public keys for JWT verification. Used by external services to verify JWT tokens issued by this auth service. 
 * @summary Get JSON Web Keys
 */
export const getJwksResponseKeysItemKidRegExp = new RegExp('^[a-zA-Z0-9_-]{1,64}$');
export const getJwksResponseKeysItemNRegExp = new RegExp('^[a-zA-Z0-9_-]{342,1024}$');
export const getJwksResponseKeysItemERegExp = new RegExp('^[a-zA-Z0-9_-]{2,6}$');
export const getJwksResponseKeysItemX5cItemRegExp = new RegExp('^[a-zA-Z0-9+/=]{100,2000}$');
export const getJwksResponseKeysItemX5cMax = 5;
export const getJwksResponseKeysItemX5tRegExp = new RegExp('^[a-zA-Z0-9_-]{40,88}$');
export const getJwksResponseKeysItemX5tS256RegExp = new RegExp('^[a-zA-Z0-9_-]{43,88}$');
export const getJwksResponseKeysMax = 10;


export const getJwksResponse = zod.object({
  "keys": zod.array(zod.object({
  "kty": zod.enum(['RSA', 'EC']).describe('Key type (RSA for asymmetric encryption, EC for elliptic curve)'),
  "use": zod.enum(['sig', 'enc']).describe('Public key use (signature verification or encryption)'),
  "kid": zod.string().regex(getJwksResponseKeysItemKidRegExp).describe('Key ID for key identification'),
  "n": zod.string().regex(getJwksResponseKeysItemNRegExp).describe('RSA modulus (base64url encoded)'),
  "e": zod.string().regex(getJwksResponseKeysItemERegExp).describe('RSA public exponent (base64url encoded)'),
  "alg": zod.enum(['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512']).describe('Algorithm used for signing/encryption'),
  "x5c": zod.array(zod.string().regex(getJwksResponseKeysItemX5cItemRegExp)).min(1).max(getJwksResponseKeysItemX5cMax).optional().describe('X.509 certificate chain (base64 encoded). Allows verification of key ownership and trust chain validation'),
  "x5t": zod.string().regex(getJwksResponseKeysItemX5tRegExp).optional().describe('X.509 certificate thumbprint (SHA-1 hash, base64url encoded)'),
  "x5t#S256": zod.string().regex(getJwksResponseKeysItemX5tS256RegExp).optional().describe('X.509 certificate thumbprint with SHA-256 (more secure than x5t)'),
  "iat": zod.number().optional().describe('Issued at time (Unix timestamp) - when key was created'),
  "exp": zod.number().optional().describe('Expiration time (Unix timestamp) - when key expires'),
  "revoked": zod.boolean().optional().describe('Whether this key has been revoked')
})).min(1).max(getJwksResponseKeysMax).describe('Array of JSON Web Keys')
})


/**
 * Terminate a specific user session
 * @summary Terminate specific session
 */
export const terminateSessionPathSessionIdRegExp = new RegExp('^[a-zA-Z0-9\\s.,!?-]{1,255}$');


export const terminateSessionParams = zod.object({
  "sessionId": zod.string().regex(terminateSessionPathSessionIdRegExp).describe('Session ID to terminate')
})
