/**
 * Generated by orval v7.11.1 üç∫
 * Do not edit manually.
 * AKSI Dry Cleaning Order System API
 * API for dry cleaning order management system with Domain-Driven Design architecture. The system includes 13 domains: Auth, User, Customer, Branch, Employee, Order, OrderItem, Service, Garment, Pricing, Payment, Notification, and Analytics.
 * OpenAPI spec version: 1.0.0
 */
import {
  z as zod
} from 'zod';

/**
 * Clear failed login attempts and unlock blocked user (admin only)
 * @summary Unlock blocked user
 */
export const unlockUserParams = zod.object({
  "username": zod.string().describe('Username to unlock')
})


/**
 * Clear failed login attempts and unlock blocked IP address (admin only)
 * @summary Unlock IP address
 */
export const unlockIpParams = zod.object({
  "ipAddress": zod.string().describe('IP address to unlock')
})


/**
 * Authenticate operator and return session cookie
 * @summary Login to system
 */
export const loginBodyUsernameMin = 3;

export const loginBodyUsernameMax = 50;

export const loginBodyUsernameRegExp = new RegExp('^[a-zA-Z0-9_]+$');
export const loginBodyPasswordMin = 6;

export const loginBodyPasswordMax = 100;


export const loginBody = zod.object({
  "username": zod.string().min(loginBodyUsernameMin).max(loginBodyUsernameMax).regex(loginBodyUsernameRegExp).describe('Operator username'),
  "password": zod.string().min(loginBodyPasswordMin).max(loginBodyPasswordMax).describe('Password (min 6 chars for dev, 12 for prod)'),
  "rememberMe": zod.boolean().optional().describe('Remember session for 30 days'),
  "branchId": zod.object({
  "present": zod.boolean().optional()
}).optional()
})

export const loginResponseRolesMax = 2147483647;
export const loginResponseAttemptsRemainingMin = 0;


export const loginResponse = zod.object({
  "userId": zod.uuid().describe('User ID'),
  "username": zod.string().describe('Username'),
  "firstName": zod.string().optional().describe('First name'),
  "lastName": zod.string().optional().describe('Last name'),
  "roles": zod.array(zod.enum(['OPERATOR', 'MANAGER', 'ADMIN', 'CLEANER', 'DRIVER'])).min(1).max(loginResponseRolesMax).describe('User roles'),
  "permissions": zod.array(zod.string()).optional().describe('User permissions'),
  "branchId": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "branchName": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "requiresBranchSelection": zod.boolean().describe('Whether branch selection is required'),
  "isBlocked": zod.boolean().describe('Whether user account is blocked due to failed attempts'),
  "attemptsRemaining": zod.number().min(loginResponseAttemptsRemainingMin).describe('Number of login attempts remaining before lockout'),
  "lockoutExpiresAt": zod.object({
  "present": zod.boolean().optional()
}).optional()
})


/**
 * List all active sessions for current user or specified user (admin only)
 * @summary Get all user sessions
 */
export const getUserSessionsQueryParams = zod.object({
  "userId": zod.uuid().optional().describe('User ID to get sessions for (admin only, defaults to current user)')
})

export const getUserSessionsResponse = zod.object({
  "sessions": zod.array(zod.object({
  "sessionId": zod.string().describe('Session ID'),
  "createdAt": zod.iso.datetime({}).describe('Session creation time'),
  "lastAccessedAt": zod.iso.datetime({}).describe('Last access time'),
  "expiresAt": zod.iso.datetime({}).describe('Session expiration time'),
  "ipAddress": zod.string().describe('IP address'),
  "userAgent": zod.string().optional().describe('Browser user agent'),
  "location": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "deviceType": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "isCurrentSession": zod.boolean().describe('Is this the current session')
})).describe('List of user sessions'),
  "totalCount": zod.number().describe('Total number of sessions'),
  "currentSessionId": zod.string().describe('Current session ID')
})


/**
 * Logout user from all devices except current session
 * @summary Terminate all other sessions
 */
export const terminateOtherSessionsResponse = zod.object({
  "terminatedCount": zod.number().describe('Number of sessions terminated'),
  "message": zod.string().describe('Success message')
})


/**
 * Information about current user and session
 * @summary Get current session info
 */
export const getCurrentSessionResponse = zod.object({
  "sessionId": zod.string().describe('Session ID'),
  "userId": zod.uuid().describe('User ID'),
  "username": zod.string().describe('Username'),
  "roles": zod.array(zod.enum(['OPERATOR', 'MANAGER', 'ADMIN', 'CLEANER', 'DRIVER'])).optional(),
  "branchId": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "branchName": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "createdAt": zod.iso.datetime({}).describe('Session creation time'),
  "lastAccessedAt": zod.iso.datetime({}).describe('Last access time'),
  "expiresAt": zod.iso.datetime({}).optional().describe('Session expiration time'),
  "ipAddress": zod.string().optional().describe('IP address'),
  "userAgent": zod.string().optional().describe('Browser user agent')
})


/**
 * Logout user from all devices (admin only)
 * @summary Terminate all sessions for user
 */
export const invalidateAllSessionsQueryParams = zod.object({
  "userId": zod.uuid().describe('User ID to invalidate sessions for')
})


/**
 * Returns current server timestamp for time synchronization between frontend and backend. Used to avoid hydration issues and ensure consistent time across client and server. 
 * @summary Get current server time
 */
export const getServerTimeResponse = zod.object({
  "timestamp": zod.iso.datetime({}).describe('Current server time in ISO 8601 format (UTC)'),
  "epochMillis": zod.number().describe('Current server time as Unix epoch milliseconds'),
  "timezone": zod.string().describe('Server timezone identifier'),
  "utcOffset": zod.string().describe('UTC offset for server timezone'),
  "date": zod.iso.date().optional().describe('Current server date (YYYY-MM-DD)'),
  "time": zod.string().optional().describe('Current server time (HH:mm:ss)')
})


/**
 * Get current security policy settings (rate limits, password policy, etc.)
 * @summary Get current security policy
 */
export const getSecurityPolicyResponse = zod.object({
  "rateLimiting": zod.object({
  "maxAttemptsPerUser": zod.number().describe('Max failed attempts per user'),
  "maxAttemptsPerIp": zod.number().describe('Max failed attempts per IP'),
  "lockoutDurationMinutes": zod.number().describe('Lockout duration in minutes'),
  "enabled": zod.boolean().describe('Is rate limiting enabled')
}),
  "passwordPolicy": zod.object({
  "minLength": zod.number().describe('Minimum password length'),
  "requireUppercase": zod.boolean().describe('Require uppercase letters'),
  "requireLowercase": zod.boolean().describe('Require lowercase letters'),
  "requireNumbers": zod.boolean().describe('Require numbers'),
  "requireSpecialChars": zod.boolean().describe('Require special characters'),
  "allowedSpecialChars": zod.string().optional().describe('Allowed special characters')
}),
  "sessionPolicy": zod.object({
  "defaultTimeoutMinutes": zod.number().describe('Default session timeout in minutes'),
  "maxConcurrentSessions": zod.number().describe('Max concurrent sessions per user'),
  "rememberMeTimeoutDays": zod.number().describe('Remember me timeout in days'),
  "sessionFixationProtection": zod.boolean().optional().describe('Is session fixation protection enabled')
})
})


/**
 * Get rate limiting and security attempt statistics (admin only)
 * @summary Get login attempt statistics
 */
export const getSecurityAttemptsResponseRecentAttemptsMin = 0;

export const getSecurityAttemptsResponseRecentAttemptsMax = 50;


export const getSecurityAttemptsResponse = zod.object({
  "overview": zod.object({
  "totalFailedAttemptsToday": zod.number().describe('Total failed attempts today'),
  "totalBlockedUsers": zod.number().describe('Currently blocked users count'),
  "totalBlockedIps": zod.number().describe('Currently blocked IPs count'),
  "peakAttemptTime": zod.iso.datetime({}).describe('Time of highest attempt rate today'),
  "averageAttemptsPerHour": zod.number().optional().describe('Average failed attempts per hour')
}),
  "recentAttempts": zod.array(zod.object({
  "timestamp": zod.iso.datetime({}).describe('Attempt timestamp'),
  "username": zod.string().describe('Username attempted'),
  "ipAddress": zod.string().describe('IP address'),
  "userAgent": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "location": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "success": zod.boolean().describe('Whether attempt was successful'),
  "failureReason": zod.object({
  "present": zod.boolean().optional()
}).optional()
})).min(getSecurityAttemptsResponseRecentAttemptsMin).max(getSecurityAttemptsResponseRecentAttemptsMax).describe('Recent login attempts (last 50)'),
  "blockedUsers": zod.array(zod.object({
  "username": zod.string().describe('Blocked username'),
  "failedAttempts": zod.number().describe('Number of failed attempts'),
  "lastAttemptAt": zod.iso.datetime({}).describe('Last failed attempt time'),
  "blockedUntil": zod.iso.datetime({}).describe('When block expires'),
  "lastAttemptIp": zod.string().optional().describe('IP of last attempt')
})).describe('Currently blocked users'),
  "blockedIps": zod.array(zod.object({
  "ipAddress": zod.string().describe('Blocked IP address'),
  "failedAttempts": zod.number().describe('Number of failed attempts'),
  "lastAttemptAt": zod.iso.datetime({}).describe('Last failed attempt time'),
  "blockedUntil": zod.iso.datetime({}).describe('When block expires'),
  "location": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "lastUsername": zod.object({
  "present": zod.boolean().optional()
}).optional()
})).describe('Currently blocked IP addresses')
})


/**
 * Terminate a specific user session
 * @summary Terminate specific session
 */
export const terminateSessionParams = zod.object({
  "sessionId": zod.string().describe('Session ID to terminate')
})
