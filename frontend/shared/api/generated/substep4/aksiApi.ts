/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * AKSI API
 * API –¥–ª—è —Å–∏—Å—Ç–µ–º–∏ –∫–µ—Ä—É–≤–∞–Ω–Ω—è –∫–ª—ñ–Ω—ñ–Ω–≥–æ–≤–æ—é –∫–æ–º–ø–∞–Ω—ñ—î—é AKSI
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AddModifierRequest,
  ErrorResponse,
  InitializeSubstepRequest,
  PriceCalculationResponseDTO,
  PriceDiscountDTO,
  PriceModifierDTO,
  Substep4GetAvailableEvents200Item,
  Substep4GetAvailableModifiersParams,
  Substep4GetRecommendedModifiersParams,
  SubstepResultDTO
} from './aksiApi.schemas';

import orvalFetcher from '../../../../lib/api/orval-fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary –°–∫–∏–¥–∞–Ω–Ω—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const substep4ResetCalculation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/reset/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep4ResetCalculationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4ResetCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4ResetCalculation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep4ResetCalculation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4ResetCalculation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep4ResetCalculation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4ResetCalculationMutationResult = NonNullable<Awaited<ReturnType<typeof substep4ResetCalculation>>>
    
    export type Substep4ResetCalculationMutationError = ErrorResponse

    /**
 * @summary –°–∫–∏–¥–∞–Ω–Ω—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const useSubstep4ResetCalculation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4ResetCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4ResetCalculation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4ResetCalculationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –î–æ–¥–∞–≤–∞–Ω–Ω—è –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –¥–æ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const substep4AddModifier = (
    sessionId: string,
    addModifierRequest: AddModifierRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers/${sessionId}/add`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addModifierRequest, signal
    },
      options);
    }
  


export const getSubstep4AddModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4AddModifier>>, TError,{sessionId: string;data: AddModifierRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4AddModifier>>, TError,{sessionId: string;data: AddModifierRequest}, TContext> => {

const mutationKey = ['substep4AddModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4AddModifier>>, {sessionId: string;data: AddModifierRequest}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  substep4AddModifier(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4AddModifierMutationResult = NonNullable<Awaited<ReturnType<typeof substep4AddModifier>>>
    export type Substep4AddModifierMutationBody = AddModifierRequest
    export type Substep4AddModifierMutationError = ErrorResponse

    /**
 * @summary –î–æ–¥–∞–≤–∞–Ω–Ω—è –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –¥–æ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const useSubstep4AddModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4AddModifier>>, TError,{sessionId: string;data: AddModifierRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4AddModifier>>,
        TError,
        {sessionId: string;data: AddModifierRequest},
        TContext
      > => {

      const mutationOptions = getSubstep4AddModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—ñ–¥–µ—Ç–∞–ø—É 4
 */
export const substep4InitializeSubstep = (
    sessionId: string,
    initializeSubstepRequest: InitializeSubstepRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/initialize/${sessionId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: initializeSubstepRequest, signal
    },
      options);
    }
  


export const getSubstep4InitializeSubstepMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4InitializeSubstep>>, TError,{sessionId: string;data: InitializeSubstepRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4InitializeSubstep>>, TError,{sessionId: string;data: InitializeSubstepRequest}, TContext> => {

const mutationKey = ['substep4InitializeSubstep'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4InitializeSubstep>>, {sessionId: string;data: InitializeSubstepRequest}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  substep4InitializeSubstep(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4InitializeSubstepMutationResult = NonNullable<Awaited<ReturnType<typeof substep4InitializeSubstep>>>
    export type Substep4InitializeSubstepMutationBody = InitializeSubstepRequest
    export type Substep4InitializeSubstepMutationError = ErrorResponse

    /**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—ñ–¥–µ—Ç–∞–ø—É 4
 */
export const useSubstep4InitializeSubstep = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4InitializeSubstep>>, TError,{sessionId: string;data: InitializeSubstepRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4InitializeSubstep>>,
        TError,
        {sessionId: string;data: InitializeSubstepRequest},
        TContext
      > => {

      const mutationOptions = getSubstep4InitializeSubstepMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É —Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –ø—ñ–¥–µ—Ç–∞–ø—É
 */
export const substep4ConfirmCalculation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/confirm/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep4ConfirmCalculationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4ConfirmCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4ConfirmCalculation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep4ConfirmCalculation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4ConfirmCalculation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep4ConfirmCalculation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4ConfirmCalculationMutationResult = NonNullable<Awaited<ReturnType<typeof substep4ConfirmCalculation>>>
    
    export type Substep4ConfirmCalculationMutationError = ErrorResponse

    /**
 * @summary –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É —Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –ø—ñ–¥–µ—Ç–∞–ø—É
 */
export const useSubstep4ConfirmCalculation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4ConfirmCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4ConfirmCalculation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4ConfirmCalculationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ü—ñ–Ω–∏
 */
export const substep4CalculatePrice = (
    priceDiscountDTO: PriceDiscountDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceCalculationResponseDTO>(
      {url: `/v1/order-wizard/stage2/substep4/calculate-price`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: priceDiscountDTO, signal
    },
      options);
    }
  


export const getSubstep4CalculatePriceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculatePrice>>, TError,{data: PriceDiscountDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4CalculatePrice>>, TError,{data: PriceDiscountDTO}, TContext> => {

const mutationKey = ['substep4CalculatePrice'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4CalculatePrice>>, {data: PriceDiscountDTO}> = (props) => {
          const {data} = props ?? {};

          return  substep4CalculatePrice(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4CalculatePriceMutationResult = NonNullable<Awaited<ReturnType<typeof substep4CalculatePrice>>>
    export type Substep4CalculatePriceMutationBody = PriceDiscountDTO
    export type Substep4CalculatePriceMutationError = ErrorResponse

    /**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ü—ñ–Ω–∏
 */
export const useSubstep4CalculatePrice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculatePrice>>, TError,{data: PriceDiscountDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4CalculatePrice>>,
        TError,
        {data: PriceDiscountDTO},
        TContext
      > => {

      const mutationOptions = getSubstep4CalculatePriceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ñ—ñ–Ω–∞–ª—å–Ω–æ—ó —Ü—ñ–Ω–∏ –∑ —É—Å—ñ–º–∞ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞–º–∏
 */
export const substep4CalculateFinalPrice = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/calculate-final-price/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep4CalculateFinalPriceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateFinalPrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateFinalPrice>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep4CalculateFinalPrice'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4CalculateFinalPrice>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep4CalculateFinalPrice(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4CalculateFinalPriceMutationResult = NonNullable<Awaited<ReturnType<typeof substep4CalculateFinalPrice>>>
    
    export type Substep4CalculateFinalPriceMutationError = ErrorResponse

    /**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ñ—ñ–Ω–∞–ª—å–Ω–æ—ó —Ü—ñ–Ω–∏ –∑ —É—Å—ñ–º–∞ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞–º–∏
 */
export const useSubstep4CalculateFinalPrice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateFinalPrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4CalculateFinalPrice>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4CalculateFinalPriceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –±–∞–∑–æ–≤–æ—ó —Ü—ñ–Ω–∏ –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const substep4CalculateBasePrice = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/calculate-base-price/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep4CalculateBasePriceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateBasePrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateBasePrice>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep4CalculateBasePrice'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4CalculateBasePrice>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep4CalculateBasePrice(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4CalculateBasePriceMutationResult = NonNullable<Awaited<ReturnType<typeof substep4CalculateBasePrice>>>
    
    export type Substep4CalculateBasePriceMutationError = ErrorResponse

    /**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –±–∞–∑–æ–≤–æ—ó —Ü—ñ–Ω–∏ –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const useSubstep4CalculateBasePrice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateBasePrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4CalculateBasePrice>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4CalculateBasePriceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const substep4ValidateCurrentState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage2/substep4/validate/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4ValidateCurrentStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/validate/${sessionId}`] as const;
    }

    
export const getSubstep4ValidateCurrentStateQueryOptions = <TData = Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4ValidateCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4ValidateCurrentState>>> = ({ signal }) => substep4ValidateCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4ValidateCurrentStateQueryResult = NonNullable<Awaited<ReturnType<typeof substep4ValidateCurrentState>>>
export type Substep4ValidateCurrentStateQueryError = ErrorResponse


export function useSubstep4ValidateCurrentState<TData = Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateCurrentState<TData = Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateCurrentState<TData = Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */

export function useSubstep4ValidateCurrentState<TData = Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4ValidateCurrentStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –î–µ—Ç–∞–ª—å–Ω–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º
 */
export const substep4ValidateDetailed = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/validate-detailed/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4ValidateDetailedQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/validate-detailed/${sessionId}`] as const;
    }

    
export const getSubstep4ValidateDetailedQueryOptions = <TData = Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4ValidateDetailedQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4ValidateDetailed>>> = ({ signal }) => substep4ValidateDetailed(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4ValidateDetailedQueryResult = NonNullable<Awaited<ReturnType<typeof substep4ValidateDetailed>>>
export type Substep4ValidateDetailedQueryError = ErrorResponse


export function useSubstep4ValidateDetailed<TData = Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateDetailed>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateDetailed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateDetailed<TData = Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateDetailed>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateDetailed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateDetailed<TData = Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –î–µ—Ç–∞–ª—å–Ω–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º
 */

export function useSubstep4ValidateDetailed<TData = Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4ValidateDetailedQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É –ø—ñ–¥–µ—Ç–∞–ø—É
 */
export const substep4GetCurrentState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/state/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4GetCurrentStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/state/${sessionId}`] as const;
    }

    
export const getSubstep4GetCurrentStateQueryOptions = <TData = Awaited<ReturnType<typeof substep4GetCurrentState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetCurrentState>>> = ({ signal }) => substep4GetCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetCurrentStateQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetCurrentState>>>
export type Substep4GetCurrentStateQueryError = ErrorResponse


export function useSubstep4GetCurrentState<TData = Awaited<ReturnType<typeof substep4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentState<TData = Awaited<ReturnType<typeof substep4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentState<TData = Awaited<ReturnType<typeof substep4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É –ø—ñ–¥–µ—Ç–∞–ø—É
 */

export function useSubstep4GetCurrentState<TData = Awaited<ReturnType<typeof substep4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetCurrentStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —ñ—Å–Ω—É–≤–∞–Ω–Ω—è —Å–µ—Å—ñ—ó
 */
export const substep4SessionExists = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage2/substep4/session/${sessionId}/exists`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4SessionExistsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/session/${sessionId}/exists`] as const;
    }

    
export const getSubstep4SessionExistsQueryOptions = <TData = Awaited<ReturnType<typeof substep4SessionExists>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4SessionExistsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4SessionExists>>> = ({ signal }) => substep4SessionExists(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4SessionExistsQueryResult = NonNullable<Awaited<ReturnType<typeof substep4SessionExists>>>
export type Substep4SessionExistsQueryError = ErrorResponse


export function useSubstep4SessionExists<TData = Awaited<ReturnType<typeof substep4SessionExists>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4SessionExists>>,
          TError,
          Awaited<ReturnType<typeof substep4SessionExists>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4SessionExists<TData = Awaited<ReturnType<typeof substep4SessionExists>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4SessionExists>>,
          TError,
          Awaited<ReturnType<typeof substep4SessionExists>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4SessionExists<TData = Awaited<ReturnType<typeof substep4SessionExists>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —ñ—Å–Ω—É–≤–∞–Ω–Ω—è —Å–µ—Å—ñ—ó
 */

export function useSubstep4SessionExists<TData = Awaited<ReturnType<typeof substep4SessionExists>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4SessionExistsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const substep4GetAvailableModifiers = (
    params: Substep4GetAvailableModifiersParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceModifierDTO[]>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSubstep4GetAvailableModifiersQueryKey = (params: Substep4GetAvailableModifiersParams,) => {
    return [`/v1/order-wizard/stage2/substep4/modifiers`, ...(params ? [params]: [])] as const;
    }

    
export const getSubstep4GetAvailableModifiersQueryOptions = <TData = Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError = ErrorResponse>(params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetAvailableModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>> = ({ signal }) => substep4GetAvailableModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetAvailableModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>>
export type Substep4GetAvailableModifiersQueryError = ErrorResponse


export function useSubstep4GetAvailableModifiers<TData = Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableModifiers<TData = Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableModifiers<TData = Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useSubstep4GetAvailableModifiers<TData = Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetAvailableModifiersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤
 */
export const substep4GetRecommendedModifiers = (
    params: Substep4GetRecommendedModifiersParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceModifierDTO[]>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers/recommended`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSubstep4GetRecommendedModifiersQueryKey = (params: Substep4GetRecommendedModifiersParams,) => {
    return [`/v1/order-wizard/stage2/substep4/modifiers/recommended`, ...(params ? [params]: [])] as const;
    }

    
export const getSubstep4GetRecommendedModifiersQueryOptions = <TData = Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError = ErrorResponse>(params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetRecommendedModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>> = ({ signal }) => substep4GetRecommendedModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetRecommendedModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>>
export type Substep4GetRecommendedModifiersQueryError = ErrorResponse


export function useSubstep4GetRecommendedModifiers<TData = Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetRecommendedModifiers<TData = Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetRecommendedModifiers<TData = Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤
 */

export function useSubstep4GetRecommendedModifiers<TData = Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetRecommendedModifiersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –ø–æ–¥—ñ–π –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const substep4GetAvailableEvents = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Substep4GetAvailableEvents200Item[]>(
      {url: `/v1/order-wizard/stage2/substep4/events/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4GetAvailableEventsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/events/${sessionId}`] as const;
    }

    
export const getSubstep4GetAvailableEventsQueryOptions = <TData = Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetAvailableEventsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetAvailableEvents>>> = ({ signal }) => substep4GetAvailableEvents(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetAvailableEventsQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetAvailableEvents>>>
export type Substep4GetAvailableEventsQueryError = ErrorResponse


export function useSubstep4GetAvailableEvents<TData = Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableEvents<TData = Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableEvents<TData = Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –ø–æ–¥—ñ–π –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */

export function useSubstep4GetAvailableEvents<TData = Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetAvailableEventsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–∏—Ö –¥–∞–Ω–∏—Ö —Å–µ—Å—ñ—ó
 */
export const substep4GetCurrentData = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceDiscountDTO>(
      {url: `/v1/order-wizard/stage2/substep4/data/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4GetCurrentDataQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/data/${sessionId}`] as const;
    }

    
export const getSubstep4GetCurrentDataQueryOptions = <TData = Awaited<ReturnType<typeof substep4GetCurrentData>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetCurrentDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetCurrentData>>> = ({ signal }) => substep4GetCurrentData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetCurrentDataQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetCurrentData>>>
export type Substep4GetCurrentDataQueryError = ErrorResponse


export function useSubstep4GetCurrentData<TData = Awaited<ReturnType<typeof substep4GetCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentData>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentData<TData = Awaited<ReturnType<typeof substep4GetCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentData>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentData<TData = Awaited<ReturnType<typeof substep4GetCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–∏—Ö –¥–∞–Ω–∏—Ö —Å–µ—Å—ñ—ó
 */

export function useSubstep4GetCurrentData<TData = Awaited<ReturnType<typeof substep4GetCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetCurrentDataQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –í–∏–¥–∞–ª–µ–Ω–Ω—è —Å–µ—Å—ñ—ó
 */
export const substep4RemoveSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/substep4/session/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getSubstep4RemoveSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep4RemoveSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4RemoveSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep4RemoveSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4RemoveSessionMutationResult = NonNullable<Awaited<ReturnType<typeof substep4RemoveSession>>>
    
    export type Substep4RemoveSessionMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–µ–Ω–Ω—è —Å–µ—Å—ñ—ó
 */
export const useSubstep4RemoveSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4RemoveSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4RemoveSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–¥–∞–ª–µ–Ω–Ω—è –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –∑ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const substep4RemoveModifier = (
    sessionId: string,
    modifierId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers/${sessionId}/${modifierId}`, method: 'DELETE'
    },
      options);
    }
  


export const getSubstep4RemoveModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveModifier>>, TError,{sessionId: string;modifierId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveModifier>>, TError,{sessionId: string;modifierId: string}, TContext> => {

const mutationKey = ['substep4RemoveModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4RemoveModifier>>, {sessionId: string;modifierId: string}> = (props) => {
          const {sessionId,modifierId} = props ?? {};

          return  substep4RemoveModifier(sessionId,modifierId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4RemoveModifierMutationResult = NonNullable<Awaited<ReturnType<typeof substep4RemoveModifier>>>
    
    export type Substep4RemoveModifierMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–µ–Ω–Ω—è –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –∑ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const useSubstep4RemoveModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveModifier>>, TError,{sessionId: string;modifierId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4RemoveModifier>>,
        TError,
        {sessionId: string;modifierId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4RemoveModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
