/**
 * Generated by orval v7.11.1 üç∫
 * Do not edit manually.
 * AKSI Dry Cleaning Order System API
 * API for dry cleaning order management system with Domain-Driven Design architecture. The system includes 13 domains: Auth, User, Customer, Branch, Employee, Order, OrderItem, Service, Garment, Pricing, Payment, Notification, and Analytics.
 * OpenAPI spec version: 1.0.0
 */
import {
  z as zod
} from 'zod';

/**
 * Retrieve detailed information about a specific service type
 * @summary Get service type by ID
 */
export const gamesGetServiceTypeByIdParams = zod.object({
  "serviceTypeId": zod.uuid()
})

export const gamesGetServiceTypeByIdResponseNameMax = 100;
export const gamesGetServiceTypeByIdResponseCodeMax = 50;

export const gamesGetServiceTypeByIdResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesGetServiceTypeByIdResponseDescriptionMin = 0;

export const gamesGetServiceTypeByIdResponseDescriptionMax = 500;
export const gamesGetServiceTypeByIdResponseBaseMultiplierMax = 1000;
export const gamesGetServiceTypeByIdResponseSortOrderMin = 0;


export const gamesGetServiceTypeByIdResponse = zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "name": zod.string().min(1).max(gamesGetServiceTypeByIdResponseNameMax),
  "code": zod.string().min(1).max(gamesGetServiceTypeByIdResponseCodeMax).regex(gamesGetServiceTypeByIdResponseCodeRegExp),
  "description": zod.string().min(gamesGetServiceTypeByIdResponseDescriptionMin).max(gamesGetServiceTypeByIdResponseDescriptionMax).optional(),
  "baseMultiplier": zod.number().min(1).max(gamesGetServiceTypeByIdResponseBaseMultiplierMax).describe('Base multiplier in basis points (100 = 1.0x, 200 = 2.0x)'),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesGetServiceTypeByIdResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Update an existing service type's information
 * @summary Update service type
 */
export const gamesUpdateServiceTypeParams = zod.object({
  "serviceTypeId": zod.uuid()
})

export const gamesUpdateServiceTypeBodyNameMax = 100;
export const gamesUpdateServiceTypeBodyCodeMax = 50;

export const gamesUpdateServiceTypeBodyCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesUpdateServiceTypeBodyDescriptionMin = 0;

export const gamesUpdateServiceTypeBodyDescriptionMax = 500;
export const gamesUpdateServiceTypeBodyBaseMultiplierMax = 1000;
export const gamesUpdateServiceTypeBodySortOrderMin = 0;


export const gamesUpdateServiceTypeBody = zod.object({
  "gameId": zod.uuid().optional(),
  "name": zod.string().min(1).max(gamesUpdateServiceTypeBodyNameMax).optional(),
  "code": zod.string().min(1).max(gamesUpdateServiceTypeBodyCodeMax).regex(gamesUpdateServiceTypeBodyCodeRegExp).optional(),
  "description": zod.string().min(gamesUpdateServiceTypeBodyDescriptionMin).max(gamesUpdateServiceTypeBodyDescriptionMax).optional(),
  "baseMultiplier": zod.number().min(1).max(gamesUpdateServiceTypeBodyBaseMultiplierMax).optional(),
  "sortOrder": zod.number().min(gamesUpdateServiceTypeBodySortOrderMin).optional(),
  "active": zod.boolean().optional()
})

export const gamesUpdateServiceTypeResponseNameMax = 100;
export const gamesUpdateServiceTypeResponseCodeMax = 50;

export const gamesUpdateServiceTypeResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesUpdateServiceTypeResponseDescriptionMin = 0;

export const gamesUpdateServiceTypeResponseDescriptionMax = 500;
export const gamesUpdateServiceTypeResponseBaseMultiplierMax = 1000;
export const gamesUpdateServiceTypeResponseSortOrderMin = 0;


export const gamesUpdateServiceTypeResponse = zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "name": zod.string().min(1).max(gamesUpdateServiceTypeResponseNameMax),
  "code": zod.string().min(1).max(gamesUpdateServiceTypeResponseCodeMax).regex(gamesUpdateServiceTypeResponseCodeRegExp),
  "description": zod.string().min(gamesUpdateServiceTypeResponseDescriptionMin).max(gamesUpdateServiceTypeResponseDescriptionMax).optional(),
  "baseMultiplier": zod.number().min(1).max(gamesUpdateServiceTypeResponseBaseMultiplierMax).describe('Base multiplier in basis points (100 = 1.0x, 200 = 2.0x)'),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesUpdateServiceTypeResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Mark service type as inactive (soft delete)
 * @summary Soft delete service type
 */
export const gamesDeleteServiceTypeParams = zod.object({
  "serviceTypeId": zod.uuid()
})


/**
 * Retrieve detailed information about a specific price configuration
 * @summary Get price configuration by ID
 */
export const gamesGetPriceConfigurationByIdParams = zod.object({
  "configId": zod.uuid()
})

export const gamesGetPriceConfigurationByIdResponseBasePriceMin = 0;
export const gamesGetPriceConfigurationByIdResponsePricePerLevelMin = 0;
export const gamesGetPriceConfigurationByIdResponseSortOrderMin = 0;


export const gamesGetPriceConfigurationByIdResponse = zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "difficultyLevelId": zod.uuid(),
  "serviceTypeId": zod.uuid(),
  "basePrice": zod.number().min(gamesGetPriceConfigurationByIdResponseBasePriceMin).describe('Base price in cents (e.g., 100 = $1.00)'),
  "pricePerLevel": zod.number().min(gamesGetPriceConfigurationByIdResponsePricePerLevelMin).optional().describe('Price per level in cents'),
  "currency": zod.string().optional(),
  "calculationType": zod.enum(['LINEAR', 'RANGE', 'FORMULA', 'TIME_BASED']),
  "calculationFormula": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesGetPriceConfigurationByIdResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Update an existing price configuration's information
 * @summary Update price configuration
 */
export const gamesUpdatePriceConfigurationParams = zod.object({
  "configId": zod.uuid()
})

export const gamesUpdatePriceConfigurationBodyBasePriceMin = 0;
export const gamesUpdatePriceConfigurationBodyPricePerLevelMin = 0;
export const gamesUpdatePriceConfigurationBodySortOrderMin = 0;


export const gamesUpdatePriceConfigurationBody = zod.object({
  "gameId": zod.uuid(),
  "difficultyLevelId": zod.uuid(),
  "serviceTypeId": zod.uuid(),
  "basePrice": zod.number().min(gamesUpdatePriceConfigurationBodyBasePriceMin).optional().describe('Base price in cents'),
  "pricePerLevel": zod.number().min(gamesUpdatePriceConfigurationBodyPricePerLevelMin).optional().describe('Price per level in cents'),
  "currency": zod.string().optional(),
  "calculationType": zod.enum(['LINEAR', 'RANGE', 'FORMULA', 'TIME_BASED']).optional(),
  "calculationFormula": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "sortOrder": zod.number().min(gamesUpdatePriceConfigurationBodySortOrderMin).optional(),
  "active": zod.boolean().optional()
})

export const gamesUpdatePriceConfigurationResponseBasePriceMin = 0;
export const gamesUpdatePriceConfigurationResponsePricePerLevelMin = 0;
export const gamesUpdatePriceConfigurationResponseSortOrderMin = 0;


export const gamesUpdatePriceConfigurationResponse = zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "difficultyLevelId": zod.uuid(),
  "serviceTypeId": zod.uuid(),
  "basePrice": zod.number().min(gamesUpdatePriceConfigurationResponseBasePriceMin).describe('Base price in cents (e.g., 100 = $1.00)'),
  "pricePerLevel": zod.number().min(gamesUpdatePriceConfigurationResponsePricePerLevelMin).optional().describe('Price per level in cents'),
  "currency": zod.string().optional(),
  "calculationType": zod.enum(['LINEAR', 'RANGE', 'FORMULA', 'TIME_BASED']),
  "calculationFormula": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesUpdatePriceConfigurationResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Permanently delete a price configuration from the system
 * @summary Delete price configuration
 */
export const gamesDeletePriceConfigurationParams = zod.object({
  "configId": zod.uuid()
})


/**
 * Retrieve a specific game modifier by its ID
 * @summary Get game modifier by ID
 */
export const getGameModifierParams = zod.object({
  "modifierId": zod.uuid().describe('Game modifier ID')
})

export const getGameModifierResponsePriorityMin = 0;

export const getGameModifierResponsePriorityMax = 100;


export const getGameModifierResponse = zod.object({
  "id": zod.uuid().describe('Modifier ID'),
  "code": zod.string().describe('Unique modifier code within game'),
  "name": zod.string().describe('Modifier display name'),
  "description": zod.string().optional().describe('Detailed description'),
  "type": zod.enum(['TIMING', 'SUPPORT', 'MODE', 'QUALITY', 'EXTRA', 'PROMOTIONAL', 'SEASONAL', 'SPELLS', 'RANK', 'PROGRESSION', 'COSMETIC', 'SOCIAL', 'GUIDANCE', 'ACHIEVEMENT', 'SERVICE']),
  "operation": zod.enum(['ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE']),
  "value": zod.number().describe('Modifier value: - For ADD/SUBTRACT: amount in cents (e.g., 5000 = $50.00) - For MULTIPLY: multiplier * 100 (e.g., 150 = 1.5x, 200 = 2.0x) - For DIVIDE: divisor * 100 (e.g., 200 = divide by 2.0) '),
  "gameCode": zod.string().describe('Game this modifier belongs to'),
  "serviceTypeCodes": zod.array(zod.string()).optional().describe('Service types this modifier applies to'),
  "active": zod.boolean().describe('Is modifier active and available'),
  "sortOrder": zod.number().optional().describe('Display order'),
  "icon": zod.string().optional().describe('Icon identifier for UI'),
  "color": zod.string().optional().describe('Color code for UI'),
  "priority": zod.number().min(getGameModifierResponsePriorityMin).max(getGameModifierResponsePriorityMax).optional().describe('Priority for applying multiple modifiers (higher = applied later)'),
  "maxUses": zod.number().min(1).optional().describe('Maximum number of times this modifier can be used (null = unlimited)'),
  "effectiveDate": zod.iso.datetime({}).optional().describe('Date when modifier becomes effective'),
  "expirationDate": zod.iso.datetime({}).optional().describe('Date when modifier expires'),
  "conditions": zod.string().optional().describe('JSON conditions for applying modifier'),
  "createdAt": zod.iso.datetime({}).optional().describe('Creation timestamp'),
  "updatedAt": zod.iso.datetime({}).optional().describe('Last update timestamp')
})


/**
 * Update an existing game modifier
 * @summary Update game modifier
 */
export const updateGameModifierParams = zod.object({
  "modifierId": zod.uuid().describe('Game modifier ID')
})

export const updateGameModifierBody = zod.object({
  "name": zod.string().optional().describe('Modifier display name'),
  "description": zod.string().optional().describe('Detailed description'),
  "type": zod.enum(['TIMING', 'SUPPORT', 'MODE', 'QUALITY', 'EXTRA', 'PROMOTIONAL', 'SEASONAL', 'SPELLS', 'RANK', 'PROGRESSION', 'COSMETIC', 'SOCIAL', 'GUIDANCE', 'ACHIEVEMENT', 'SERVICE']).optional(),
  "operation": zod.enum(['ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE']).optional(),
  "value": zod.number().optional().describe('Modifier value'),
  "serviceTypeCodes": zod.array(zod.string()).optional().describe('Applicable service types'),
  "active": zod.boolean().optional().describe('Is modifier active'),
  "sortOrder": zod.number().optional().describe('Display order'),
  "icon": zod.string().optional().describe('Icon identifier'),
  "color": zod.string().optional().describe('Color code')
})

export const updateGameModifierResponsePriorityMin = 0;

export const updateGameModifierResponsePriorityMax = 100;


export const updateGameModifierResponse = zod.object({
  "id": zod.uuid().describe('Modifier ID'),
  "code": zod.string().describe('Unique modifier code within game'),
  "name": zod.string().describe('Modifier display name'),
  "description": zod.string().optional().describe('Detailed description'),
  "type": zod.enum(['TIMING', 'SUPPORT', 'MODE', 'QUALITY', 'EXTRA', 'PROMOTIONAL', 'SEASONAL', 'SPELLS', 'RANK', 'PROGRESSION', 'COSMETIC', 'SOCIAL', 'GUIDANCE', 'ACHIEVEMENT', 'SERVICE']),
  "operation": zod.enum(['ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE']),
  "value": zod.number().describe('Modifier value: - For ADD/SUBTRACT: amount in cents (e.g., 5000 = $50.00) - For MULTIPLY: multiplier * 100 (e.g., 150 = 1.5x, 200 = 2.0x) - For DIVIDE: divisor * 100 (e.g., 200 = divide by 2.0) '),
  "gameCode": zod.string().describe('Game this modifier belongs to'),
  "serviceTypeCodes": zod.array(zod.string()).optional().describe('Service types this modifier applies to'),
  "active": zod.boolean().describe('Is modifier active and available'),
  "sortOrder": zod.number().optional().describe('Display order'),
  "icon": zod.string().optional().describe('Icon identifier for UI'),
  "color": zod.string().optional().describe('Color code for UI'),
  "priority": zod.number().min(updateGameModifierResponsePriorityMin).max(updateGameModifierResponsePriorityMax).optional().describe('Priority for applying multiple modifiers (higher = applied later)'),
  "maxUses": zod.number().min(1).optional().describe('Maximum number of times this modifier can be used (null = unlimited)'),
  "effectiveDate": zod.iso.datetime({}).optional().describe('Date when modifier becomes effective'),
  "expirationDate": zod.iso.datetime({}).optional().describe('Date when modifier expires'),
  "conditions": zod.string().optional().describe('JSON conditions for applying modifier'),
  "createdAt": zod.iso.datetime({}).optional().describe('Creation timestamp'),
  "updatedAt": zod.iso.datetime({}).optional().describe('Last update timestamp')
})


/**
 * Delete a game modifier by ID
 * @summary Delete game modifier
 */
export const deleteGameModifierParams = zod.object({
  "modifierId": zod.uuid().describe('Game modifier ID')
})


/**
 * Retrieve detailed information about a specific difficulty level
 * @summary Get difficulty level by ID
 */
export const gamesGetDifficultyLevelByIdParams = zod.object({
  "difficultyLevelId": zod.uuid()
})

export const gamesGetDifficultyLevelByIdResponseNameMax = 100;
export const gamesGetDifficultyLevelByIdResponseCodeMax = 50;

export const gamesGetDifficultyLevelByIdResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesGetDifficultyLevelByIdResponseLevelValueMax = 1000;
export const gamesGetDifficultyLevelByIdResponseDescriptionMin = 0;

export const gamesGetDifficultyLevelByIdResponseDescriptionMax = 500;
export const gamesGetDifficultyLevelByIdResponseSortOrderMin = 0;


export const gamesGetDifficultyLevelByIdResponse = zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "name": zod.string().min(1).max(gamesGetDifficultyLevelByIdResponseNameMax),
  "code": zod.string().min(1).max(gamesGetDifficultyLevelByIdResponseCodeMax).regex(gamesGetDifficultyLevelByIdResponseCodeRegExp),
  "levelValue": zod.number().min(1).max(gamesGetDifficultyLevelByIdResponseLevelValueMax),
  "description": zod.string().min(gamesGetDifficultyLevelByIdResponseDescriptionMin).max(gamesGetDifficultyLevelByIdResponseDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesGetDifficultyLevelByIdResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Update an existing difficulty level's information
 * @summary Update difficulty level
 */
export const gamesUpdateDifficultyLevelParams = zod.object({
  "difficultyLevelId": zod.uuid()
})

export const gamesUpdateDifficultyLevelBodyNameMax = 100;
export const gamesUpdateDifficultyLevelBodyCodeMax = 50;

export const gamesUpdateDifficultyLevelBodyCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesUpdateDifficultyLevelBodyLevelValueMax = 1000;
export const gamesUpdateDifficultyLevelBodyDescriptionMin = 0;

export const gamesUpdateDifficultyLevelBodyDescriptionMax = 500;
export const gamesUpdateDifficultyLevelBodySortOrderMin = 0;


export const gamesUpdateDifficultyLevelBody = zod.object({
  "gameId": zod.uuid().optional(),
  "name": zod.string().min(1).max(gamesUpdateDifficultyLevelBodyNameMax).optional(),
  "code": zod.string().min(1).max(gamesUpdateDifficultyLevelBodyCodeMax).regex(gamesUpdateDifficultyLevelBodyCodeRegExp).optional(),
  "levelValue": zod.number().min(1).max(gamesUpdateDifficultyLevelBodyLevelValueMax).optional(),
  "description": zod.string().min(gamesUpdateDifficultyLevelBodyDescriptionMin).max(gamesUpdateDifficultyLevelBodyDescriptionMax).optional(),
  "sortOrder": zod.number().min(gamesUpdateDifficultyLevelBodySortOrderMin).optional(),
  "active": zod.boolean().optional()
})

export const gamesUpdateDifficultyLevelResponseNameMax = 100;
export const gamesUpdateDifficultyLevelResponseCodeMax = 50;

export const gamesUpdateDifficultyLevelResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesUpdateDifficultyLevelResponseLevelValueMax = 1000;
export const gamesUpdateDifficultyLevelResponseDescriptionMin = 0;

export const gamesUpdateDifficultyLevelResponseDescriptionMax = 500;
export const gamesUpdateDifficultyLevelResponseSortOrderMin = 0;


export const gamesUpdateDifficultyLevelResponse = zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "name": zod.string().min(1).max(gamesUpdateDifficultyLevelResponseNameMax),
  "code": zod.string().min(1).max(gamesUpdateDifficultyLevelResponseCodeMax).regex(gamesUpdateDifficultyLevelResponseCodeRegExp),
  "levelValue": zod.number().min(1).max(gamesUpdateDifficultyLevelResponseLevelValueMax),
  "description": zod.string().min(gamesUpdateDifficultyLevelResponseDescriptionMin).max(gamesUpdateDifficultyLevelResponseDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesUpdateDifficultyLevelResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Permanently delete a difficulty level from the system
 * @summary Delete difficulty level
 */
export const gamesDeleteDifficultyLevelParams = zod.object({
  "difficultyLevelId": zod.uuid()
})


/**
 * Retrieve detailed information about a specific game
 * @summary Get game by ID
 */
export const gamesGetGameByIdParams = zod.object({
  "gameId": zod.uuid()
})

export const gamesGetGameByIdResponseNameMax = 100;
export const gamesGetGameByIdResponseCodeMax = 50;

export const gamesGetGameByIdResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesGetGameByIdResponseDescriptionMin = 0;

export const gamesGetGameByIdResponseDescriptionMax = 1000;
export const gamesGetGameByIdResponseSortOrderMin = 0;


export const gamesGetGameByIdResponse = zod.object({
  "id": zod.uuid(),
  "name": zod.string().min(1).max(gamesGetGameByIdResponseNameMax),
  "code": zod.string().min(1).max(gamesGetGameByIdResponseCodeMax).regex(gamesGetGameByIdResponseCodeRegExp),
  "category": zod.enum(['MMORPG', 'FPS', 'MOBA', 'BATTLE_ROYALE', 'STRATEGY', 'ACTION', 'SIMULATION', 'SPORTS', 'RACING', 'PUZZLE', 'OTHER']),
  "description": zod.string().min(gamesGetGameByIdResponseDescriptionMin).max(gamesGetGameByIdResponseDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesGetGameByIdResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Update an existing game's information
 * @summary Update game
 */
export const gamesUpdateGameParams = zod.object({
  "gameId": zod.uuid()
})

export const gamesUpdateGameBodyNameMax = 100;
export const gamesUpdateGameBodyCodeMax = 50;

export const gamesUpdateGameBodyCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesUpdateGameBodyDescriptionMin = 0;

export const gamesUpdateGameBodyDescriptionMax = 1000;
export const gamesUpdateGameBodySortOrderMin = 0;


export const gamesUpdateGameBody = zod.object({
  "name": zod.string().min(1).max(gamesUpdateGameBodyNameMax).optional(),
  "code": zod.string().min(1).max(gamesUpdateGameBodyCodeMax).regex(gamesUpdateGameBodyCodeRegExp).optional(),
  "category": zod.enum(['MMORPG', 'FPS', 'MOBA', 'BATTLE_ROYALE', 'STRATEGY', 'ACTION', 'SIMULATION', 'SPORTS', 'RACING', 'PUZZLE', 'OTHER']).optional(),
  "description": zod.string().min(gamesUpdateGameBodyDescriptionMin).max(gamesUpdateGameBodyDescriptionMax).optional(),
  "sortOrder": zod.number().min(gamesUpdateGameBodySortOrderMin).optional(),
  "active": zod.boolean().optional()
})

export const gamesUpdateGameResponseNameMax = 100;
export const gamesUpdateGameResponseCodeMax = 50;

export const gamesUpdateGameResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesUpdateGameResponseDescriptionMin = 0;

export const gamesUpdateGameResponseDescriptionMax = 1000;
export const gamesUpdateGameResponseSortOrderMin = 0;


export const gamesUpdateGameResponse = zod.object({
  "id": zod.uuid(),
  "name": zod.string().min(1).max(gamesUpdateGameResponseNameMax),
  "code": zod.string().min(1).max(gamesUpdateGameResponseCodeMax).regex(gamesUpdateGameResponseCodeRegExp),
  "category": zod.enum(['MMORPG', 'FPS', 'MOBA', 'BATTLE_ROYALE', 'STRATEGY', 'ACTION', 'SIMULATION', 'SPORTS', 'RACING', 'PUZZLE', 'OTHER']),
  "description": zod.string().min(gamesUpdateGameResponseDescriptionMin).max(gamesUpdateGameResponseDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesUpdateGameResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Permanently delete a game from the system
 * @summary Delete game
 */
export const gamesDeleteGameParams = zod.object({
  "gameId": zod.uuid()
})


/**
 * Retrieve detailed information about a specific booster
 * @summary Get booster by ID
 */
export const gamesGetBoosterByIdParams = zod.object({
  "boosterId": zod.uuid()
})

export const gamesGetBoosterByIdResponseDiscordUsernameMax = 100;
export const gamesGetBoosterByIdResponseDisplayNameMax = 50;
export const gamesGetBoosterByIdResponsePhoneNumberRegExp = new RegExp('^\\+?[1-9]\\d{1,14}$');
export const gamesGetBoosterByIdResponseRatingMin = 0;

export const gamesGetBoosterByIdResponseRatingMax = 500;
export const gamesGetBoosterByIdResponseTotalOrdersMin = 0;
export const gamesGetBoosterByIdResponseSuccessRateMin = 0;

export const gamesGetBoosterByIdResponseSuccessRateMax = 10000;
export const gamesGetBoosterByIdResponseAverageCompletionTimeMin = 0;


export const gamesGetBoosterByIdResponse = zod.object({
  "id": zod.uuid(),
  "discordUsername": zod.string().min(1).max(gamesGetBoosterByIdResponseDiscordUsernameMax),
  "displayName": zod.string().min(1).max(gamesGetBoosterByIdResponseDisplayNameMax),
  "contactEmail": zod.email().optional(),
  "phoneNumber": zod.string().regex(gamesGetBoosterByIdResponsePhoneNumberRegExp).optional(),
  "rating": zod.number().min(gamesGetBoosterByIdResponseRatingMin).max(gamesGetBoosterByIdResponseRatingMax).describe('Rating in basis points (100 = 1.0 star, 500 = 5.0 stars)'),
  "totalOrders": zod.number().min(gamesGetBoosterByIdResponseTotalOrdersMin),
  "successRate": zod.number().min(gamesGetBoosterByIdResponseSuccessRateMin).max(gamesGetBoosterByIdResponseSuccessRateMax).describe('Success rate in basis points (10000 = 100.00%)'),
  "averageCompletionTime": zod.number().min(gamesGetBoosterByIdResponseAverageCompletionTimeMin).optional().describe('Average completion time in minutes'),
  "active": zod.boolean(),
  "verified": zod.boolean(),
  "lastActive": zod.iso.datetime({}).optional(),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Update an existing booster's information
 * @summary Update booster
 */
export const gamesUpdateBoosterParams = zod.object({
  "boosterId": zod.uuid()
})

export const gamesUpdateBoosterBodyDiscordUsernameMax = 100;
export const gamesUpdateBoosterBodyDisplayNameMax = 50;
export const gamesUpdateBoosterBodyPhoneNumberRegExp = new RegExp('^\\+?[1-9]\\d{1,14}$');


export const gamesUpdateBoosterBody = zod.object({
  "discordUsername": zod.string().min(1).max(gamesUpdateBoosterBodyDiscordUsernameMax).optional(),
  "displayName": zod.string().min(1).max(gamesUpdateBoosterBodyDisplayNameMax).optional(),
  "contactEmail": zod.email().optional(),
  "phoneNumber": zod.string().regex(gamesUpdateBoosterBodyPhoneNumberRegExp).optional(),
  "active": zod.boolean().optional(),
  "verified": zod.boolean().optional()
})

export const gamesUpdateBoosterResponseDiscordUsernameMax = 100;
export const gamesUpdateBoosterResponseDisplayNameMax = 50;
export const gamesUpdateBoosterResponsePhoneNumberRegExp = new RegExp('^\\+?[1-9]\\d{1,14}$');
export const gamesUpdateBoosterResponseRatingMin = 0;

export const gamesUpdateBoosterResponseRatingMax = 500;
export const gamesUpdateBoosterResponseTotalOrdersMin = 0;
export const gamesUpdateBoosterResponseSuccessRateMin = 0;

export const gamesUpdateBoosterResponseSuccessRateMax = 10000;
export const gamesUpdateBoosterResponseAverageCompletionTimeMin = 0;


export const gamesUpdateBoosterResponse = zod.object({
  "id": zod.uuid(),
  "discordUsername": zod.string().min(1).max(gamesUpdateBoosterResponseDiscordUsernameMax),
  "displayName": zod.string().min(1).max(gamesUpdateBoosterResponseDisplayNameMax),
  "contactEmail": zod.email().optional(),
  "phoneNumber": zod.string().regex(gamesUpdateBoosterResponsePhoneNumberRegExp).optional(),
  "rating": zod.number().min(gamesUpdateBoosterResponseRatingMin).max(gamesUpdateBoosterResponseRatingMax).describe('Rating in basis points (100 = 1.0 star, 500 = 5.0 stars)'),
  "totalOrders": zod.number().min(gamesUpdateBoosterResponseTotalOrdersMin),
  "successRate": zod.number().min(gamesUpdateBoosterResponseSuccessRateMin).max(gamesUpdateBoosterResponseSuccessRateMax).describe('Success rate in basis points (10000 = 100.00%)'),
  "averageCompletionTime": zod.number().min(gamesUpdateBoosterResponseAverageCompletionTimeMin).optional().describe('Average completion time in minutes'),
  "active": zod.boolean(),
  "verified": zod.boolean(),
  "lastActive": zod.iso.datetime({}).optional(),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Permanently delete a booster from the system
 * @summary Delete booster
 */
export const gamesDeleteBoosterParams = zod.object({
  "boosterId": zod.uuid()
})


/**
 * Get paginated list of games with optional filtering by active status
 * @summary Get all games
 */
export const gamesListGamesQueryPageDefault = 0;
export const gamesListGamesQueryPageMin = 0;
export const gamesListGamesQuerySizeDefault = 20;
export const gamesListGamesQuerySizeMax = 100;
export const gamesListGamesQuerySearchRegExp = new RegExp('^[\\w\\s\\p{L}\\p{M}\\p{N}\\p{P}\\p{S}]{0,255}$');


export const gamesListGamesQueryParams = zod.object({
  "page": zod.number().min(gamesListGamesQueryPageMin).optional().describe('Page number (0-based)'),
  "size": zod.number().min(1).max(gamesListGamesQuerySizeMax).default(gamesListGamesQuerySizeDefault).describe('Page size (number of items per page)'),
  "search": zod.string().regex(gamesListGamesQuerySearchRegExp).optional().describe('Free text search'),
  "active": zod.boolean().optional().describe('Filter by active status')
})

export const gamesListGamesResponseDataItemNameMax = 100;
export const gamesListGamesResponseDataItemCodeMax = 50;

export const gamesListGamesResponseDataItemCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesListGamesResponseDataItemDescriptionMin = 0;

export const gamesListGamesResponseDataItemDescriptionMax = 1000;
export const gamesListGamesResponseDataItemSortOrderMin = 0;


export const gamesListGamesResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid(),
  "name": zod.string().min(1).max(gamesListGamesResponseDataItemNameMax),
  "code": zod.string().min(1).max(gamesListGamesResponseDataItemCodeMax).regex(gamesListGamesResponseDataItemCodeRegExp),
  "category": zod.enum(['MMORPG', 'FPS', 'MOBA', 'BATTLE_ROYALE', 'STRATEGY', 'ACTION', 'SIMULATION', 'SPORTS', 'RACING', 'PUZZLE', 'OTHER']),
  "description": zod.string().min(gamesListGamesResponseDataItemDescriptionMin).max(gamesListGamesResponseDataItemDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesListGamesResponseDataItemSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})).describe('Page content'),
  "totalElements": zod.number().describe('Total number of elements'),
  "totalPages": zod.number().describe('Total number of pages'),
  "size": zod.number().describe('Page size'),
  "number": zod.number().describe('Page number (0-based)'),
  "numberOfElements": zod.number().describe('Number of elements in current page'),
  "first": zod.boolean().describe('Is first page'),
  "last": zod.boolean().describe('Is last page'),
  "empty": zod.boolean().describe('Is empty')
})


/**
 * Create a new game entry in the system
 * @summary Create new game
 */
export const gamesCreateGameBodyNameMax = 100;
export const gamesCreateGameBodyCodeMax = 50;

export const gamesCreateGameBodyCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesCreateGameBodyDescriptionMin = 0;

export const gamesCreateGameBodyDescriptionMax = 1000;
export const gamesCreateGameBodySortOrderMin = 0;


export const gamesCreateGameBody = zod.object({
  "name": zod.string().min(1).max(gamesCreateGameBodyNameMax),
  "code": zod.string().min(1).max(gamesCreateGameBodyCodeMax).regex(gamesCreateGameBodyCodeRegExp),
  "category": zod.enum(['MMORPG', 'FPS', 'MOBA', 'BATTLE_ROYALE', 'STRATEGY', 'ACTION', 'SIMULATION', 'SPORTS', 'RACING', 'PUZZLE', 'OTHER']),
  "description": zod.string().min(gamesCreateGameBodyDescriptionMin).max(gamesCreateGameBodyDescriptionMax).optional(),
  "sortOrder": zod.number().min(gamesCreateGameBodySortOrderMin).optional()
})


/**
 * Get paginated list of service types with optional filtering
 * @summary Get service types
 */
export const gamesListServiceTypesQueryPageDefault = 0;
export const gamesListServiceTypesQueryPageMin = 0;
export const gamesListServiceTypesQuerySizeDefault = 20;
export const gamesListServiceTypesQuerySizeMax = 100;


export const gamesListServiceTypesQueryParams = zod.object({
  "page": zod.number().min(gamesListServiceTypesQueryPageMin).optional().describe('Page number (0-based)'),
  "size": zod.number().min(1).max(gamesListServiceTypesQuerySizeMax).default(gamesListServiceTypesQuerySizeDefault).describe('Page size (number of items per page)'),
  "gameId": zod.uuid().optional().describe('Filter by game ID'),
  "active": zod.boolean().optional().describe('Filter by active status')
})

export const gamesListServiceTypesResponseDataItemNameMax = 100;
export const gamesListServiceTypesResponseDataItemCodeMax = 50;

export const gamesListServiceTypesResponseDataItemCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesListServiceTypesResponseDataItemDescriptionMin = 0;

export const gamesListServiceTypesResponseDataItemDescriptionMax = 500;
export const gamesListServiceTypesResponseDataItemBaseMultiplierMax = 1000;
export const gamesListServiceTypesResponseDataItemSortOrderMin = 0;


export const gamesListServiceTypesResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "name": zod.string().min(1).max(gamesListServiceTypesResponseDataItemNameMax),
  "code": zod.string().min(1).max(gamesListServiceTypesResponseDataItemCodeMax).regex(gamesListServiceTypesResponseDataItemCodeRegExp),
  "description": zod.string().min(gamesListServiceTypesResponseDataItemDescriptionMin).max(gamesListServiceTypesResponseDataItemDescriptionMax).optional(),
  "baseMultiplier": zod.number().min(1).max(gamesListServiceTypesResponseDataItemBaseMultiplierMax).describe('Base multiplier in basis points (100 = 1.0x, 200 = 2.0x)'),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesListServiceTypesResponseDataItemSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})).describe('Page content'),
  "totalElements": zod.number().describe('Total number of elements'),
  "totalPages": zod.number().describe('Total number of pages'),
  "size": zod.number().describe('Page size'),
  "number": zod.number().describe('Page number (0-based)'),
  "numberOfElements": zod.number().describe('Number of elements in current page'),
  "first": zod.boolean().describe('Is first page'),
  "last": zod.boolean().describe('Is last page'),
  "empty": zod.boolean().describe('Is empty')
})


/**
 * Create a new service type in the system
 * @summary Create service type
 */
export const gamesCreateServiceTypeBodyNameMax = 100;
export const gamesCreateServiceTypeBodyCodeMax = 50;

export const gamesCreateServiceTypeBodyCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesCreateServiceTypeBodyDescriptionMin = 0;

export const gamesCreateServiceTypeBodyDescriptionMax = 500;
export const gamesCreateServiceTypeBodyBaseMultiplierMax = 1000;
export const gamesCreateServiceTypeBodySortOrderMin = 0;


export const gamesCreateServiceTypeBody = zod.object({
  "gameId": zod.uuid(),
  "name": zod.string().min(1).max(gamesCreateServiceTypeBodyNameMax),
  "code": zod.string().min(1).max(gamesCreateServiceTypeBodyCodeMax).regex(gamesCreateServiceTypeBodyCodeRegExp),
  "description": zod.string().min(gamesCreateServiceTypeBodyDescriptionMin).max(gamesCreateServiceTypeBodyDescriptionMax).optional(),
  "baseMultiplier": zod.number().min(1).max(gamesCreateServiceTypeBodyBaseMultiplierMax),
  "sortOrder": zod.number().min(gamesCreateServiceTypeBodySortOrderMin).optional(),
  "active": zod.boolean().optional()
})


/**
 * Get paginated list of price configurations with optional filtering
 * @summary Get price configurations
 */
export const gamesListPriceConfigurationsQueryPageDefault = 0;
export const gamesListPriceConfigurationsQueryPageMin = 0;
export const gamesListPriceConfigurationsQuerySizeDefault = 20;
export const gamesListPriceConfigurationsQuerySizeMax = 100;


export const gamesListPriceConfigurationsQueryParams = zod.object({
  "page": zod.number().min(gamesListPriceConfigurationsQueryPageMin).optional().describe('Page number (0-based)'),
  "size": zod.number().min(1).max(gamesListPriceConfigurationsQuerySizeMax).default(gamesListPriceConfigurationsQuerySizeDefault).describe('Page size (number of items per page)'),
  "gameId": zod.uuid().optional().describe('Filter by game ID'),
  "serviceTypeId": zod.uuid().optional().describe('Filter by service type ID'),
  "difficultyLevelId": zod.uuid().optional().describe('Filter by difficulty level ID'),
  "active": zod.boolean().optional().describe('Filter by active status')
})

export const gamesListPriceConfigurationsResponseDataItemBasePriceMin = 0;
export const gamesListPriceConfigurationsResponseDataItemPricePerLevelMin = 0;
export const gamesListPriceConfigurationsResponseDataItemSortOrderMin = 0;


export const gamesListPriceConfigurationsResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "difficultyLevelId": zod.uuid(),
  "serviceTypeId": zod.uuid(),
  "basePrice": zod.number().min(gamesListPriceConfigurationsResponseDataItemBasePriceMin).describe('Base price in cents (e.g., 100 = $1.00)'),
  "pricePerLevel": zod.number().min(gamesListPriceConfigurationsResponseDataItemPricePerLevelMin).optional().describe('Price per level in cents'),
  "currency": zod.string().optional(),
  "calculationType": zod.enum(['LINEAR', 'RANGE', 'FORMULA', 'TIME_BASED']),
  "calculationFormula": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesListPriceConfigurationsResponseDataItemSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})).describe('Page content'),
  "totalElements": zod.number().describe('Total number of elements'),
  "totalPages": zod.number().describe('Total number of pages'),
  "size": zod.number().describe('Page size'),
  "number": zod.number().describe('Page number (0-based)'),
  "numberOfElements": zod.number().describe('Number of elements in current page'),
  "first": zod.boolean().describe('Is first page'),
  "last": zod.boolean().describe('Is last page'),
  "empty": zod.boolean().describe('Is empty')
})


/**
 * Create a new price configuration in the system
 * @summary Create price configuration
 */
export const gamesCreatePriceConfigurationBodyBasePriceMin = 0;
export const gamesCreatePriceConfigurationBodyPricePerLevelMin = 0;
export const gamesCreatePriceConfigurationBodySortOrderMin = 0;


export const gamesCreatePriceConfigurationBody = zod.object({
  "gameId": zod.uuid(),
  "difficultyLevelId": zod.uuid(),
  "serviceTypeId": zod.uuid(),
  "basePrice": zod.number().min(gamesCreatePriceConfigurationBodyBasePriceMin).describe('Base price in cents'),
  "pricePerLevel": zod.number().min(gamesCreatePriceConfigurationBodyPricePerLevelMin).optional().describe('Price per level in cents'),
  "currency": zod.string().optional(),
  "calculationType": zod.enum(['LINEAR', 'RANGE', 'FORMULA', 'TIME_BASED']),
  "calculationFormula": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "sortOrder": zod.number().min(gamesCreatePriceConfigurationBodySortOrderMin).optional(),
  "active": zod.boolean().optional()
})


/**
 * Retrieve a list of all game modifiers with optional filtering
 * @summary Get all game modifiers
 */
export const listGameModifiersQueryPageDefault = 0;
export const listGameModifiersQueryPageMin = 0;
export const listGameModifiersQuerySizeDefault = 20;
export const listGameModifiersQuerySizeMax = 100;
export const listGameModifiersQuerySortByRegExp = new RegExp('^[a-zA-Z0-9\\s.,!?-]{1,255}$');
export const listGameModifiersQuerySortOrderDefault = "ASC";export const listGameModifiersQuerySearchRegExp = new RegExp('^[\\w\\s\\p{L}\\p{M}\\p{N}\\p{P}\\p{S}]{0,255}$');


export const listGameModifiersQueryParams = zod.object({
  "page": zod.number().min(listGameModifiersQueryPageMin).optional().describe('Page number (0-based)'),
  "size": zod.number().min(1).max(listGameModifiersQuerySizeMax).default(listGameModifiersQuerySizeDefault).describe('Page size (number of items per page)'),
  "sortBy": zod.string().regex(listGameModifiersQuerySortByRegExp).optional().describe('Field to sort by (domain-specific). If not provided, server default is used'),
  "sortOrder": zod.enum(['ASC', 'DESC']).default(listGameModifiersQuerySortOrderDefault).describe('Sort direction'),
  "search": zod.string().regex(listGameModifiersQuerySearchRegExp).optional().describe('Free text search'),
  "gameCode": zod.string().optional().describe('Filter by game code'),
  "type": zod.enum(['TIMING', 'SUPPORT', 'MODE', 'QUALITY', 'EXTRA', 'PROMOTIONAL', 'SEASONAL', 'SPELLS', 'RANK', 'PROGRESSION', 'COSMETIC', 'SOCIAL', 'GUIDANCE', 'ACHIEVEMENT', 'SERVICE']).optional().describe('Filter by modifier type'),
  "operation": zod.enum(['ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE']).optional().describe('Filter by operation type'),
  "active": zod.boolean().optional().describe('Filter by active status'),
  "serviceTypeCode": zod.string().optional().describe('Filter by service type')
})

export const listGameModifiersResponseModifiersItemPriorityMin = 0;

export const listGameModifiersResponseModifiersItemPriorityMax = 100;


export const listGameModifiersResponse = zod.object({
  "modifiers": zod.array(zod.object({
  "id": zod.uuid().describe('Modifier ID'),
  "code": zod.string().describe('Unique modifier code within game'),
  "name": zod.string().describe('Modifier display name'),
  "description": zod.string().optional().describe('Detailed description'),
  "type": zod.enum(['TIMING', 'SUPPORT', 'MODE', 'QUALITY', 'EXTRA', 'PROMOTIONAL', 'SEASONAL', 'SPELLS', 'RANK', 'PROGRESSION', 'COSMETIC', 'SOCIAL', 'GUIDANCE', 'ACHIEVEMENT', 'SERVICE']),
  "operation": zod.enum(['ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE']),
  "value": zod.number().describe('Modifier value: - For ADD/SUBTRACT: amount in cents (e.g., 5000 = $50.00) - For MULTIPLY: multiplier * 100 (e.g., 150 = 1.5x, 200 = 2.0x) - For DIVIDE: divisor * 100 (e.g., 200 = divide by 2.0) '),
  "gameCode": zod.string().describe('Game this modifier belongs to'),
  "serviceTypeCodes": zod.array(zod.string()).optional().describe('Service types this modifier applies to'),
  "active": zod.boolean().describe('Is modifier active and available'),
  "sortOrder": zod.number().optional().describe('Display order'),
  "icon": zod.string().optional().describe('Icon identifier for UI'),
  "color": zod.string().optional().describe('Color code for UI'),
  "priority": zod.number().min(listGameModifiersResponseModifiersItemPriorityMin).max(listGameModifiersResponseModifiersItemPriorityMax).optional().describe('Priority for applying multiple modifiers (higher = applied later)'),
  "maxUses": zod.number().min(1).optional().describe('Maximum number of times this modifier can be used (null = unlimited)'),
  "effectiveDate": zod.iso.datetime({}).optional().describe('Date when modifier becomes effective'),
  "expirationDate": zod.iso.datetime({}).optional().describe('Date when modifier expires'),
  "conditions": zod.string().optional().describe('JSON conditions for applying modifier'),
  "createdAt": zod.iso.datetime({}).optional().describe('Creation timestamp'),
  "updatedAt": zod.iso.datetime({}).optional().describe('Last update timestamp')
})).describe('List of game modifiers'),
  "totalCount": zod.number().optional().describe('Total number of modifiers'),
  "activeCount": zod.number().optional().describe('Number of active modifiers')
})


/**
 * Create a new game modifier for a specific game
 * @summary Create a new game modifier
 */
export const createGameModifierBody = zod.object({
  "code": zod.string().describe('Unique modifier code'),
  "name": zod.string().describe('Modifier display name'),
  "description": zod.string().optional().describe('Detailed description'),
  "type": zod.enum(['TIMING', 'SUPPORT', 'MODE', 'QUALITY', 'EXTRA', 'PROMOTIONAL', 'SEASONAL', 'SPELLS', 'RANK', 'PROGRESSION', 'COSMETIC', 'SOCIAL', 'GUIDANCE', 'ACHIEVEMENT', 'SERVICE']),
  "operation": zod.enum(['ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE']),
  "value": zod.number().describe('Modifier value'),
  "gameCode": zod.string().describe('Game code'),
  "serviceTypeCodes": zod.array(zod.string()).optional().describe('Applicable service types'),
  "sortOrder": zod.number().optional().describe('Display order'),
  "icon": zod.string().optional().describe('Icon identifier'),
  "color": zod.string().optional().describe('Color code')
})


/**
 * Deactivate a game modifier by ID
 * @summary Deactivate game modifier
 */
export const deactivateGameModifierParams = zod.object({
  "modifierId": zod.uuid().describe('Game modifier ID')
})

export const deactivateGameModifierResponsePriorityMin = 0;

export const deactivateGameModifierResponsePriorityMax = 100;


export const deactivateGameModifierResponse = zod.object({
  "id": zod.uuid().describe('Modifier ID'),
  "code": zod.string().describe('Unique modifier code within game'),
  "name": zod.string().describe('Modifier display name'),
  "description": zod.string().optional().describe('Detailed description'),
  "type": zod.enum(['TIMING', 'SUPPORT', 'MODE', 'QUALITY', 'EXTRA', 'PROMOTIONAL', 'SEASONAL', 'SPELLS', 'RANK', 'PROGRESSION', 'COSMETIC', 'SOCIAL', 'GUIDANCE', 'ACHIEVEMENT', 'SERVICE']),
  "operation": zod.enum(['ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE']),
  "value": zod.number().describe('Modifier value: - For ADD/SUBTRACT: amount in cents (e.g., 5000 = $50.00) - For MULTIPLY: multiplier * 100 (e.g., 150 = 1.5x, 200 = 2.0x) - For DIVIDE: divisor * 100 (e.g., 200 = divide by 2.0) '),
  "gameCode": zod.string().describe('Game this modifier belongs to'),
  "serviceTypeCodes": zod.array(zod.string()).optional().describe('Service types this modifier applies to'),
  "active": zod.boolean().describe('Is modifier active and available'),
  "sortOrder": zod.number().optional().describe('Display order'),
  "icon": zod.string().optional().describe('Icon identifier for UI'),
  "color": zod.string().optional().describe('Color code for UI'),
  "priority": zod.number().min(deactivateGameModifierResponsePriorityMin).max(deactivateGameModifierResponsePriorityMax).optional().describe('Priority for applying multiple modifiers (higher = applied later)'),
  "maxUses": zod.number().min(1).optional().describe('Maximum number of times this modifier can be used (null = unlimited)'),
  "effectiveDate": zod.iso.datetime({}).optional().describe('Date when modifier becomes effective'),
  "expirationDate": zod.iso.datetime({}).optional().describe('Date when modifier expires'),
  "conditions": zod.string().optional().describe('JSON conditions for applying modifier'),
  "createdAt": zod.iso.datetime({}).optional().describe('Creation timestamp'),
  "updatedAt": zod.iso.datetime({}).optional().describe('Last update timestamp')
})


/**
 * Activate a game modifier by ID
 * @summary Activate game modifier
 */
export const activateGameModifierParams = zod.object({
  "modifierId": zod.uuid().describe('Game modifier ID')
})

export const activateGameModifierResponsePriorityMin = 0;

export const activateGameModifierResponsePriorityMax = 100;


export const activateGameModifierResponse = zod.object({
  "id": zod.uuid().describe('Modifier ID'),
  "code": zod.string().describe('Unique modifier code within game'),
  "name": zod.string().describe('Modifier display name'),
  "description": zod.string().optional().describe('Detailed description'),
  "type": zod.enum(['TIMING', 'SUPPORT', 'MODE', 'QUALITY', 'EXTRA', 'PROMOTIONAL', 'SEASONAL', 'SPELLS', 'RANK', 'PROGRESSION', 'COSMETIC', 'SOCIAL', 'GUIDANCE', 'ACHIEVEMENT', 'SERVICE']),
  "operation": zod.enum(['ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE']),
  "value": zod.number().describe('Modifier value: - For ADD/SUBTRACT: amount in cents (e.g., 5000 = $50.00) - For MULTIPLY: multiplier * 100 (e.g., 150 = 1.5x, 200 = 2.0x) - For DIVIDE: divisor * 100 (e.g., 200 = divide by 2.0) '),
  "gameCode": zod.string().describe('Game this modifier belongs to'),
  "serviceTypeCodes": zod.array(zod.string()).optional().describe('Service types this modifier applies to'),
  "active": zod.boolean().describe('Is modifier active and available'),
  "sortOrder": zod.number().optional().describe('Display order'),
  "icon": zod.string().optional().describe('Icon identifier for UI'),
  "color": zod.string().optional().describe('Color code for UI'),
  "priority": zod.number().min(activateGameModifierResponsePriorityMin).max(activateGameModifierResponsePriorityMax).optional().describe('Priority for applying multiple modifiers (higher = applied later)'),
  "maxUses": zod.number().min(1).optional().describe('Maximum number of times this modifier can be used (null = unlimited)'),
  "effectiveDate": zod.iso.datetime({}).optional().describe('Date when modifier becomes effective'),
  "expirationDate": zod.iso.datetime({}).optional().describe('Date when modifier expires'),
  "conditions": zod.string().optional().describe('JSON conditions for applying modifier'),
  "createdAt": zod.iso.datetime({}).optional().describe('Creation timestamp'),
  "updatedAt": zod.iso.datetime({}).optional().describe('Last update timestamp')
})


/**
 * Get paginated list of difficulty levels with optional filtering
 * @summary Get difficulty levels
 */
export const gamesListDifficultyLevelsQueryPageDefault = 0;
export const gamesListDifficultyLevelsQueryPageMin = 0;
export const gamesListDifficultyLevelsQuerySizeDefault = 20;
export const gamesListDifficultyLevelsQuerySizeMax = 100;


export const gamesListDifficultyLevelsQueryParams = zod.object({
  "page": zod.number().min(gamesListDifficultyLevelsQueryPageMin).optional().describe('Page number (0-based)'),
  "size": zod.number().min(1).max(gamesListDifficultyLevelsQuerySizeMax).default(gamesListDifficultyLevelsQuerySizeDefault).describe('Page size (number of items per page)'),
  "gameId": zod.uuid().optional().describe('Filter by game ID'),
  "active": zod.boolean().optional().describe('Filter by active status')
})

export const gamesListDifficultyLevelsResponseDataItemNameMax = 100;
export const gamesListDifficultyLevelsResponseDataItemCodeMax = 50;

export const gamesListDifficultyLevelsResponseDataItemCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesListDifficultyLevelsResponseDataItemLevelValueMax = 1000;
export const gamesListDifficultyLevelsResponseDataItemDescriptionMin = 0;

export const gamesListDifficultyLevelsResponseDataItemDescriptionMax = 500;
export const gamesListDifficultyLevelsResponseDataItemSortOrderMin = 0;


export const gamesListDifficultyLevelsResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "name": zod.string().min(1).max(gamesListDifficultyLevelsResponseDataItemNameMax),
  "code": zod.string().min(1).max(gamesListDifficultyLevelsResponseDataItemCodeMax).regex(gamesListDifficultyLevelsResponseDataItemCodeRegExp),
  "levelValue": zod.number().min(1).max(gamesListDifficultyLevelsResponseDataItemLevelValueMax),
  "description": zod.string().min(gamesListDifficultyLevelsResponseDataItemDescriptionMin).max(gamesListDifficultyLevelsResponseDataItemDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesListDifficultyLevelsResponseDataItemSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})).describe('Page content'),
  "totalElements": zod.number().describe('Total number of elements'),
  "totalPages": zod.number().describe('Total number of pages'),
  "size": zod.number().describe('Page size'),
  "number": zod.number().describe('Page number (0-based)'),
  "numberOfElements": zod.number().describe('Number of elements in current page'),
  "first": zod.boolean().describe('Is first page'),
  "last": zod.boolean().describe('Is last page'),
  "empty": zod.boolean().describe('Is empty')
})


/**
 * Create a new difficulty level in the system
 * @summary Create difficulty level
 */
export const gamesCreateDifficultyLevelBodyNameMax = 100;
export const gamesCreateDifficultyLevelBodyCodeMax = 50;

export const gamesCreateDifficultyLevelBodyCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesCreateDifficultyLevelBodyLevelValueMax = 1000;
export const gamesCreateDifficultyLevelBodyDescriptionMin = 0;

export const gamesCreateDifficultyLevelBodyDescriptionMax = 500;
export const gamesCreateDifficultyLevelBodySortOrderMin = 0;


export const gamesCreateDifficultyLevelBody = zod.object({
  "gameId": zod.uuid(),
  "name": zod.string().min(1).max(gamesCreateDifficultyLevelBodyNameMax),
  "code": zod.string().min(1).max(gamesCreateDifficultyLevelBodyCodeMax).regex(gamesCreateDifficultyLevelBodyCodeRegExp),
  "levelValue": zod.number().min(1).max(gamesCreateDifficultyLevelBodyLevelValueMax),
  "description": zod.string().min(gamesCreateDifficultyLevelBodyDescriptionMin).max(gamesCreateDifficultyLevelBodyDescriptionMax).optional(),
  "sortOrder": zod.number().min(gamesCreateDifficultyLevelBodySortOrderMin).optional()
})


/**
 * Universal endpoint for price calculation with any supported formula type and full context
 * @summary [UNIVERSAL] Calculate price using any formula type
 */
export const calculateWithFormulaParams = zod.object({
  "formulaType": zod.string().describe('Type of formula to calculate with (LINEAR, RANGE, FORMULA, TIME_BASED)')
})

export const calculateWithFormulaBody = zod.object({
  "formula": zod.object({
  "present": zod.boolean().optional()
}).optional(),
  "context": zod.object({
  "gameCode": zod.string().optional(),
  "serviceTypeCode": zod.string().optional(),
  "difficultyLevelCode": zod.string().optional(),
  "startLevel": zod.number().min(1).optional(),
  "targetLevel": zod.number().min(1).optional(),
  "modifiers": zod.array(zod.string()).optional().describe('Modifier codes'),
  "additionalParameters": zod.record(zod.string(), zod.number()).optional().describe('Any additional calculation parameters (values as integers)')
}).describe('Complete calculation context')
}).describe('Request schema for universal calculation endpoint')

export const calculateWithFormulaResponse = zod.object({
  "finalPrice": zod.number().describe('Final price in cents'),
  "currency": zod.string().optional(),
  "status": zod.enum(['SUCCESS', 'FAILED', 'FALLBACK']),
  "breakdown": zod.object({
  "baseCalculation": zod.number().describe('Base formula calculation in cents'),
  "modifierAdjustments": zod.array(zod.object({
  "modifierCode": zod.string().optional(),
  "adjustment": zod.number().optional().describe('Price adjustment in cents'),
  "type": zod.enum(['PERCENTAGE', 'FIXED', 'MULTIPLIER']).optional()
})),
  "totalAdjustment": zod.number().describe('Total adjustment in cents'),
  "finalPrice": zod.number().describe('Final calculated price in cents')
}).describe('Complete calculation breakdown'),
  "formulaType": zod.enum(['LINEAR', 'RANGE', 'FORMULA', 'TIME_BASED']),
  "metadata": zod.object({
  "calculationTimeMs": zod.number().optional().describe('Time taken for calculation'),
  "formulaVersion": zod.string().optional().describe('Version of formula used'),
  "appliedModifiersCount": zod.number().optional().describe('Number of modifiers applied'),
  "levelDifference": zod.number().optional().describe('Difference between target and start level')
}).optional().describe('Calculation metadata')
}).describe('Response schema for universal calculation endpoint')


/**
 * Get paginated list of boosters with optional filtering
 * @summary Get all boosters
 */
export const gamesListBoostersQueryPageDefault = 0;
export const gamesListBoostersQueryPageMin = 0;
export const gamesListBoostersQuerySizeDefault = 20;
export const gamesListBoostersQuerySizeMax = 100;
export const gamesListBoostersQuerySearchRegExp = new RegExp('^[\\w\\s\\p{L}\\p{M}\\p{N}\\p{P}\\p{S}]{0,255}$');


export const gamesListBoostersQueryParams = zod.object({
  "page": zod.number().min(gamesListBoostersQueryPageMin).optional().describe('Page number (0-based)'),
  "size": zod.number().min(1).max(gamesListBoostersQuerySizeMax).default(gamesListBoostersQuerySizeDefault).describe('Page size (number of items per page)'),
  "search": zod.string().regex(gamesListBoostersQuerySearchRegExp).optional().describe('Free text search'),
  "active": zod.boolean().optional().describe('Filter by active status')
})

export const gamesListBoostersResponseDataItemDiscordUsernameMax = 100;
export const gamesListBoostersResponseDataItemDisplayNameMax = 50;
export const gamesListBoostersResponseDataItemPhoneNumberRegExp = new RegExp('^\\+?[1-9]\\d{1,14}$');
export const gamesListBoostersResponseDataItemRatingMin = 0;

export const gamesListBoostersResponseDataItemRatingMax = 500;
export const gamesListBoostersResponseDataItemTotalOrdersMin = 0;
export const gamesListBoostersResponseDataItemSuccessRateMin = 0;

export const gamesListBoostersResponseDataItemSuccessRateMax = 10000;
export const gamesListBoostersResponseDataItemAverageCompletionTimeMin = 0;


export const gamesListBoostersResponse = zod.object({
  "data": zod.array(zod.object({
  "id": zod.uuid(),
  "discordUsername": zod.string().min(1).max(gamesListBoostersResponseDataItemDiscordUsernameMax),
  "displayName": zod.string().min(1).max(gamesListBoostersResponseDataItemDisplayNameMax),
  "contactEmail": zod.email().optional(),
  "phoneNumber": zod.string().regex(gamesListBoostersResponseDataItemPhoneNumberRegExp).optional(),
  "rating": zod.number().min(gamesListBoostersResponseDataItemRatingMin).max(gamesListBoostersResponseDataItemRatingMax).describe('Rating in basis points (100 = 1.0 star, 500 = 5.0 stars)'),
  "totalOrders": zod.number().min(gamesListBoostersResponseDataItemTotalOrdersMin),
  "successRate": zod.number().min(gamesListBoostersResponseDataItemSuccessRateMin).max(gamesListBoostersResponseDataItemSuccessRateMax).describe('Success rate in basis points (10000 = 100.00%)'),
  "averageCompletionTime": zod.number().min(gamesListBoostersResponseDataItemAverageCompletionTimeMin).optional().describe('Average completion time in minutes'),
  "active": zod.boolean(),
  "verified": zod.boolean(),
  "lastActive": zod.iso.datetime({}).optional(),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})).describe('Page content'),
  "totalElements": zod.number().describe('Total number of elements'),
  "totalPages": zod.number().describe('Total number of pages'),
  "size": zod.number().describe('Page size'),
  "number": zod.number().describe('Page number (0-based)'),
  "numberOfElements": zod.number().describe('Number of elements in current page'),
  "first": zod.boolean().describe('Is first page'),
  "last": zod.boolean().describe('Is last page'),
  "empty": zod.boolean().describe('Is empty')
})


/**
 * Create a new booster in the system
 * @summary Create new booster
 */
export const gamesCreateBoosterBodyDiscordUsernameMax = 100;
export const gamesCreateBoosterBodyDisplayNameMax = 50;
export const gamesCreateBoosterBodyPhoneNumberRegExp = new RegExp('^\\+?[1-9]\\d{1,14}$');


export const gamesCreateBoosterBody = zod.object({
  "discordUsername": zod.string().min(1).max(gamesCreateBoosterBodyDiscordUsernameMax),
  "displayName": zod.string().min(1).max(gamesCreateBoosterBodyDisplayNameMax),
  "contactEmail": zod.email(),
  "phoneNumber": zod.string().regex(gamesCreateBoosterBodyPhoneNumberRegExp).optional(),
  "verified": zod.boolean().optional()
})


/**
 * Update the active status of a service type
 * @summary Set service type active status
 */
export const gamesSetServiceTypeActiveParams = zod.object({
  "serviceTypeId": zod.uuid()
})

export const gamesSetServiceTypeActiveQueryParams = zod.object({
  "active": zod.boolean().describe('Active status')
})

export const gamesSetServiceTypeActiveResponseNameMax = 100;
export const gamesSetServiceTypeActiveResponseCodeMax = 50;

export const gamesSetServiceTypeActiveResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesSetServiceTypeActiveResponseDescriptionMin = 0;

export const gamesSetServiceTypeActiveResponseDescriptionMax = 500;
export const gamesSetServiceTypeActiveResponseBaseMultiplierMax = 1000;
export const gamesSetServiceTypeActiveResponseSortOrderMin = 0;


export const gamesSetServiceTypeActiveResponse = zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "name": zod.string().min(1).max(gamesSetServiceTypeActiveResponseNameMax),
  "code": zod.string().min(1).max(gamesSetServiceTypeActiveResponseCodeMax).regex(gamesSetServiceTypeActiveResponseCodeRegExp),
  "description": zod.string().min(gamesSetServiceTypeActiveResponseDescriptionMin).max(gamesSetServiceTypeActiveResponseDescriptionMax).optional(),
  "baseMultiplier": zod.number().min(1).max(gamesSetServiceTypeActiveResponseBaseMultiplierMax).describe('Base multiplier in basis points (100 = 1.0x, 200 = 2.0x)'),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesSetServiceTypeActiveResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Mark a difficulty level as inactive and unavailable
 * @summary Deactivate difficulty level
 */
export const gamesDeactivateDifficultyLevelParams = zod.object({
  "difficultyLevelId": zod.uuid()
})

export const gamesDeactivateDifficultyLevelResponseNameMax = 100;
export const gamesDeactivateDifficultyLevelResponseCodeMax = 50;

export const gamesDeactivateDifficultyLevelResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesDeactivateDifficultyLevelResponseLevelValueMax = 1000;
export const gamesDeactivateDifficultyLevelResponseDescriptionMin = 0;

export const gamesDeactivateDifficultyLevelResponseDescriptionMax = 500;
export const gamesDeactivateDifficultyLevelResponseSortOrderMin = 0;


export const gamesDeactivateDifficultyLevelResponse = zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "name": zod.string().min(1).max(gamesDeactivateDifficultyLevelResponseNameMax),
  "code": zod.string().min(1).max(gamesDeactivateDifficultyLevelResponseCodeMax).regex(gamesDeactivateDifficultyLevelResponseCodeRegExp),
  "levelValue": zod.number().min(1).max(gamesDeactivateDifficultyLevelResponseLevelValueMax),
  "description": zod.string().min(gamesDeactivateDifficultyLevelResponseDescriptionMin).max(gamesDeactivateDifficultyLevelResponseDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesDeactivateDifficultyLevelResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Mark a difficulty level as active and available
 * @summary Activate difficulty level
 */
export const gamesActivateDifficultyLevelParams = zod.object({
  "difficultyLevelId": zod.uuid()
})

export const gamesActivateDifficultyLevelResponseNameMax = 100;
export const gamesActivateDifficultyLevelResponseCodeMax = 50;

export const gamesActivateDifficultyLevelResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesActivateDifficultyLevelResponseLevelValueMax = 1000;
export const gamesActivateDifficultyLevelResponseDescriptionMin = 0;

export const gamesActivateDifficultyLevelResponseDescriptionMax = 500;
export const gamesActivateDifficultyLevelResponseSortOrderMin = 0;


export const gamesActivateDifficultyLevelResponse = zod.object({
  "id": zod.uuid(),
  "gameId": zod.uuid(),
  "name": zod.string().min(1).max(gamesActivateDifficultyLevelResponseNameMax),
  "code": zod.string().min(1).max(gamesActivateDifficultyLevelResponseCodeMax).regex(gamesActivateDifficultyLevelResponseCodeRegExp),
  "levelValue": zod.number().min(1).max(gamesActivateDifficultyLevelResponseLevelValueMax),
  "description": zod.string().min(gamesActivateDifficultyLevelResponseDescriptionMin).max(gamesActivateDifficultyLevelResponseDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesActivateDifficultyLevelResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Mark a game as active and available for boosting
 * @summary Activate game
 */
export const gamesActivateGameParams = zod.object({
  "gameId": zod.uuid()
})

export const gamesActivateGameResponseNameMax = 100;
export const gamesActivateGameResponseCodeMax = 50;

export const gamesActivateGameResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesActivateGameResponseDescriptionMin = 0;

export const gamesActivateGameResponseDescriptionMax = 1000;
export const gamesActivateGameResponseSortOrderMin = 0;


export const gamesActivateGameResponse = zod.object({
  "id": zod.uuid(),
  "name": zod.string().min(1).max(gamesActivateGameResponseNameMax),
  "code": zod.string().min(1).max(gamesActivateGameResponseCodeMax).regex(gamesActivateGameResponseCodeRegExp),
  "category": zod.enum(['MMORPG', 'FPS', 'MOBA', 'BATTLE_ROYALE', 'STRATEGY', 'ACTION', 'SIMULATION', 'SPORTS', 'RACING', 'PUZZLE', 'OTHER']),
  "description": zod.string().min(gamesActivateGameResponseDescriptionMin).max(gamesActivateGameResponseDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesActivateGameResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Mark a game as inactive and unavailable for boosting
 * @summary Deactivate game
 */
export const gamesDeactivateGameParams = zod.object({
  "gameId": zod.uuid()
})

export const gamesDeactivateGameResponseNameMax = 100;
export const gamesDeactivateGameResponseCodeMax = 50;

export const gamesDeactivateGameResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesDeactivateGameResponseDescriptionMin = 0;

export const gamesDeactivateGameResponseDescriptionMax = 1000;
export const gamesDeactivateGameResponseSortOrderMin = 0;


export const gamesDeactivateGameResponse = zod.object({
  "id": zod.uuid(),
  "name": zod.string().min(1).max(gamesDeactivateGameResponseNameMax),
  "code": zod.string().min(1).max(gamesDeactivateGameResponseCodeMax).regex(gamesDeactivateGameResponseCodeRegExp),
  "category": zod.enum(['MMORPG', 'FPS', 'MOBA', 'BATTLE_ROYALE', 'STRATEGY', 'ACTION', 'SIMULATION', 'SPORTS', 'RACING', 'PUZZLE', 'OTHER']),
  "description": zod.string().min(gamesDeactivateGameResponseDescriptionMin).max(gamesDeactivateGameResponseDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesDeactivateGameResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Retrieve game information using game code
 * @summary Get game by code
 */
export const gamesGetGameByCodeParams = zod.object({
  "code": zod.string()
})

export const gamesGetGameByCodeResponseNameMax = 100;
export const gamesGetGameByCodeResponseCodeMax = 50;

export const gamesGetGameByCodeResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesGetGameByCodeResponseDescriptionMin = 0;

export const gamesGetGameByCodeResponseDescriptionMax = 1000;
export const gamesGetGameByCodeResponseSortOrderMin = 0;


export const gamesGetGameByCodeResponse = zod.object({
  "id": zod.uuid(),
  "name": zod.string().min(1).max(gamesGetGameByCodeResponseNameMax),
  "code": zod.string().min(1).max(gamesGetGameByCodeResponseCodeMax).regex(gamesGetGameByCodeResponseCodeRegExp),
  "category": zod.enum(['MMORPG', 'FPS', 'MOBA', 'BATTLE_ROYALE', 'STRATEGY', 'ACTION', 'SIMULATION', 'SPORTS', 'RACING', 'PUZZLE', 'OTHER']),
  "description": zod.string().min(gamesGetGameByCodeResponseDescriptionMin).max(gamesGetGameByCodeResponseDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesGetGameByCodeResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})


/**
 * Retrieve list of all currently active games
 * @summary Get all active games
 */
export const gamesGetAllActiveGamesResponseNameMax = 100;
export const gamesGetAllActiveGamesResponseCodeMax = 50;

export const gamesGetAllActiveGamesResponseCodeRegExp = new RegExp('^[A-Z0-9_-]+$');
export const gamesGetAllActiveGamesResponseDescriptionMin = 0;

export const gamesGetAllActiveGamesResponseDescriptionMax = 1000;
export const gamesGetAllActiveGamesResponseSortOrderMin = 0;


export const gamesGetAllActiveGamesResponseItem = zod.object({
  "id": zod.uuid(),
  "name": zod.string().min(1).max(gamesGetAllActiveGamesResponseNameMax),
  "code": zod.string().min(1).max(gamesGetAllActiveGamesResponseCodeMax).regex(gamesGetAllActiveGamesResponseCodeRegExp),
  "category": zod.enum(['MMORPG', 'FPS', 'MOBA', 'BATTLE_ROYALE', 'STRATEGY', 'ACTION', 'SIMULATION', 'SPORTS', 'RACING', 'PUZZLE', 'OTHER']),
  "description": zod.string().min(gamesGetAllActiveGamesResponseDescriptionMin).max(gamesGetAllActiveGamesResponseDescriptionMax).optional(),
  "active": zod.boolean(),
  "sortOrder": zod.number().min(gamesGetAllActiveGamesResponseSortOrderMin),
  "createdAt": zod.iso.datetime({}).optional(),
  "updatedAt": zod.iso.datetime({}).optional()
})
export const gamesGetAllActiveGamesResponse = zod.array(gamesGetAllActiveGamesResponseItem)


/**
 * Permanently delete a service type from the database (admin operation)
 * @summary Force delete service type
 */
export const gamesForceDeleteServiceTypeParams = zod.object({
  "serviceTypeId": zod.uuid()
})
