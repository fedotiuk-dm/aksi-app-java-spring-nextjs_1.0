/**
 * Generated by orval v7.9.0 游꽄
 * Do not edit manually.
 * AKSI API
 * API 햢햩혪 혜햦혜혝햣햪햦 햨햣혞쒫썛쫧쫨 햨햩혰햫혰햫햡쮏쒫쮐 햨쮏쨿햟햫혰혮혩 AKSI
 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AdaptersInfo,
  AddModifierRequest,
  AddPhotoBody,
  AdditionalInfoDTO,
  AdditionalRequirementsRequest,
  ApplyDiscount1200,
  ApplyPayment200,
  BasicOrderInfoDTO,
  BranchLocationCreateRequest,
  BranchLocationDTO,
  BranchLocationUpdateRequest,
  CalculateCompletionDate200,
  CalculatePayment200,
  CancelOrder204,
  ClientPageResponse,
  ClientResponse,
  ClientSearchCriteriaDTO,
  ClientSearchRequest,
  ClientSearchResultDTO,
  CloseSession200,
  CompleteApiMap,
  CompleteSubstep2200,
  CompletionDateCalculationRequest,
  CreateCategory200,
  CreateClientRequest,
  CreateModifier200,
  CreateOrderRequest,
  CreatePriceListItem200,
  CreateStainType200,
  CustomerSignatureRequest,
  CustomerSignatureResponse,
  DeactivateModifier200,
  DefectTypeDTO,
  DeleteBranchLocation204,
  DeleteClient204,
  DeleteOrderItem204,
  DeletePhoto204,
  DeleteStainType200,
  DiscountConfigurationDTO,
  DownloadPdfReceipt200,
  EmailReceipt200,
  EmailReceiptRequest,
  EmailReceiptResponse,
  EnterQuantityParams,
  ErrorResponse,
  ExecutionParamsDTO,
  FinalizeOrder200,
  GeneratePdfReceipt200,
  GenerateReceipt200,
  GenerateReceiptNumber1200,
  GenerateReceiptNumber1500,
  GenerateReceiptNumber1Params,
  GenerateReceiptNumberParams,
  GetAllActiveCategories200,
  GetAllBranchLocationsParams,
  GetAllCategories200,
  GetAllClientsParams,
  GetAllModifiers200,
  GetAvailableEvents200Item,
  GetAvailableModifiersForCategory200,
  GetAvailableModifiersForCategoryParams,
  GetAvailableModifiersParams,
  GetAvailableUnitsOfMeasure200,
  GetBasePrice200,
  GetBasePriceParams,
  GetBasicOrderInfoState200,
  GetCategoryByCode1200,
  GetCategoryByCode200,
  GetCategoryById1200,
  GetCategoryById200,
  GetClientSearchState200,
  GetCurrentState200,
  GetCurrentState2200,
  GetDefectTypeByCode200,
  GetDefectTypeById200,
  GetDefectTypesParams,
  GetFile200,
  GetItemById200,
  GetItemNamesByCategory200,
  GetItemsByCategory200,
  GetItemsByCategoryCode200,
  GetMaterialsParams,
  GetModifierByCode1200,
  GetModifierByCode200,
  GetModifierById200,
  GetModifiersByCategory1200,
  GetModifiersByCategory200,
  GetModifiersByCategoryParams,
  GetModifiersByCodes200,
  GetModifiersForServiceCategory1200,
  GetModifiersForServiceCategory200,
  GetNewClientFormState200,
  GetNextSubstep200,
  GetOrderDiscount200,
  GetOrderPayment200,
  GetOrderReceipt200,
  GetOrderReceiptParams,
  GetOrderSummary200,
  GetRecommendedModifiers1200,
  GetRecommendedModifiers1Params,
  GetRecommendedModifiersForDefectsParams,
  GetRecommendedModifiersForStainsParams,
  GetRecommendedModifiersParams,
  GetRecommendedUnitOfMeasureParams,
  GetRequirements200,
  GetRiskWarnings200,
  GetRiskWarningsForItemParams,
  GetRiskWarningsParams,
  GetSessionContext200,
  GetSessionState200,
  GetStainTypeByCode200,
  GetStainTypeById200,
  GetStainTypesParams,
  GoBackParams,
  HealthCheck200,
  HealthStatus,
  InitializeStage4200,
  InitializeSubstep2Params,
  InitializeSubstepRequest,
  IsUnitSupportedForItemParams,
  ItemBasicInfoDTO,
  ItemCharacteristicsDTO,
  ItemManagerDTO,
  LegalAcceptanceDTO,
  Login200,
  LoginRequest,
  ModifierRecommendationDTO,
  NewClientFormDTO,
  OrderCompletionDTO,
  OrderCompletionUpdateRequest,
  OrderConfirmationDTO,
  OrderDTO,
  OrderDetailedSummaryResponse,
  OrderDiscountRequest,
  OrderFinalizationRequest,
  OrderItemAddRequest,
  OrderItemDTO,
  OrderItemPhotoDTO,
  PaymentCalculationRequest,
  PaymentConfigurationDTO,
  PdfReceiptResponse,
  PhotoDocumentationDTO,
  PriceCalculationRequestDTO,
  PriceCalculationResponseDTO,
  PriceDiscountDTO,
  PriceListItemDTO,
  PriceModifierDTO,
  ProcessDefectNotesParams,
  ProcessDefectSelectionParams,
  ProcessStainSelectionParams,
  ReceiptConfigurationDTO,
  ReceiptDTO,
  ReceiptGenerationRequest,
  RefreshToken200,
  Register200,
  RegisterRequest,
  RemoveDiscount200,
  SaveSignature200,
  SearchClients1Params,
  SearchClientsByPhoneParams,
  SelectBranchParams,
  SelectClientParams,
  SelectColorParams,
  SelectFillerParams,
  SelectMaterialParams,
  SelectPriceListItemParams,
  SelectServiceCategoryParams,
  SelectWearLevelParams,
  ServiceCategoryDTO,
  SetActiveStatusParams,
  SetUniqueTagParams,
  Stage3Context,
  StageInfo,
  StageMethods,
  StageStatus,
  StagesStatus,
  StainTypeDTO,
  StainsDefectsContext,
  SubstepResultDTO,
  SystemStats,
  TestResponse,
  UpdateCategory200,
  UpdateClientRequest,
  UpdateLegalAcceptance200,
  UpdateModifier200,
  UpdateOrderCompletion1200,
  UpdateOrderCompletion200,
  UpdateOrderConfirmation200,
  UpdatePhotoAnnotationsParams,
  UpdatePriceListItem200,
  UpdateReceiptConfiguration200,
  UpdateRequirements200,
  UpdateStainType200,
  UploadPhotoBody,
  UploadPhotoParams,
  ValidateBasicOrderInfo200,
  ValidateComplete200,
  ValidateLegalAcceptance200,
  ValidateNewClientForm200,
  ValidateOrderCompletion200,
  ValidateOrderConfirmation200,
  ValidateReceiptConfiguration200,
  ValidationResult,
  WorkflowMap
} from './aksiApi.schemas';

import orvalFetcher from '../../../../lib/api/orval-fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary 뤯쫧쮏쒫쟴햦 햨쮏쫨혰햡혞햟혡혰혩 쮏햩햟혝햦
 */
export const updatePaymentConfig = (
    sessionId: string,
    paymentConfigurationDTO: PaymentConfigurationDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/payment-config`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: paymentConfigurationDTO
    },
      options);
    }
  


export const getUpdatePaymentConfigMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaymentConfig>>, TError,{sessionId: string;data: PaymentConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePaymentConfig>>, TError,{sessionId: string;data: PaymentConfigurationDTO}, TContext> => {

const mutationKey = ['updatePaymentConfig'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePaymentConfig>>, {sessionId: string;data: PaymentConfigurationDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updatePaymentConfig(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePaymentConfigMutationResult = NonNullable<Awaited<ReturnType<typeof updatePaymentConfig>>>
    export type UpdatePaymentConfigMutationBody = PaymentConfigurationDTO
    export type UpdatePaymentConfigMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 햨쮏쫨혰햡혞햟혡혰혩 쮏햩햟혝햦
 */
export const useUpdatePaymentConfig = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaymentConfig>>, TError,{sessionId: string;data: PaymentConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePaymentConfig>>,
        TError,
        {sessionId: string;data: PaymentConfigurationDTO},
        TContext
      > => {

      const mutationOptions = getUpdatePaymentConfigMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쫧쮏쒫쟴햦 햟햟햪햣혝햦 쒫쟳쥃쮏쫧썛쫧쫨
 */
export const updateExecutionParams = (
    sessionId: string,
    executionParamsDTO: ExecutionParamsDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/execution-params`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: executionParamsDTO
    },
      options);
    }
  


export const getUpdateExecutionParamsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateExecutionParams>>, TError,{sessionId: string;data: ExecutionParamsDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateExecutionParams>>, TError,{sessionId: string;data: ExecutionParamsDTO}, TContext> => {

const mutationKey = ['updateExecutionParams'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExecutionParams>>, {sessionId: string;data: ExecutionParamsDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateExecutionParams(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateExecutionParamsMutationResult = NonNullable<Awaited<ReturnType<typeof updateExecutionParams>>>
    export type UpdateExecutionParamsMutationBody = ExecutionParamsDTO
    export type UpdateExecutionParamsMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 햟햟햪햣혝햦 쒫쟳쥃쮏쫧썛쫧쫨
 */
export const useUpdateExecutionParams = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateExecutionParams>>, TError,{sessionId: string;data: ExecutionParamsDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateExecutionParams>>,
        TError,
        {sessionId: string;data: ExecutionParamsDTO},
        TContext
      > => {

      const mutationOptions = getUpdateExecutionParamsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쫧쮏쒫쟴햦 햨쮏쫨혰햡혞햟혡혰혩 향햫햦햤쮏
 */
export const updateDiscountConfig = (
    sessionId: string,
    discountConfigurationDTO: DiscountConfigurationDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/discount-config`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: discountConfigurationDTO
    },
      options);
    }
  


export const getUpdateDiscountConfigMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDiscountConfig>>, TError,{sessionId: string;data: DiscountConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateDiscountConfig>>, TError,{sessionId: string;data: DiscountConfigurationDTO}, TContext> => {

const mutationKey = ['updateDiscountConfig'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDiscountConfig>>, {sessionId: string;data: DiscountConfigurationDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateDiscountConfig(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDiscountConfigMutationResult = NonNullable<Awaited<ReturnType<typeof updateDiscountConfig>>>
    export type UpdateDiscountConfigMutationBody = DiscountConfigurationDTO
    export type UpdateDiscountConfigMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 햨쮏쫨혰햡혞햟혡혰혩 향햫햦햤쮏
 */
export const useUpdateDiscountConfig = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDiscountConfig>>, TError,{sessionId: string;data: DiscountConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDiscountConfig>>,
        TError,
        {sessionId: string;data: DiscountConfigurationDTO},
        TContext
      > => {

      const mutationOptions = getUpdateDiscountConfigMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쫧쮏쒫쟴햦 햢쮏얧썜햨쮏쒬 혰햫혟쮐햪햟혡혰혩
 */
export const updateAdditionalInfo = (
    sessionId: string,
    additionalInfoDTO: AdditionalInfoDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/additional-info`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: additionalInfoDTO
    },
      options);
    }
  


export const getUpdateAdditionalInfoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdditionalInfo>>, TError,{sessionId: string;data: AdditionalInfoDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAdditionalInfo>>, TError,{sessionId: string;data: AdditionalInfoDTO}, TContext> => {

const mutationKey = ['updateAdditionalInfo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdditionalInfo>>, {sessionId: string;data: AdditionalInfoDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateAdditionalInfo(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdditionalInfoMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdditionalInfo>>>
    export type UpdateAdditionalInfoMutationBody = AdditionalInfoDTO
    export type UpdateAdditionalInfoMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 햢쮏얧썜햨쮏쒬 혰햫혟쮐햪햟혡혰혩
 */
export const useUpdateAdditionalInfo = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdditionalInfo>>, TError,{sessionId: string;data: AdditionalInfoDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdditionalInfo>>,
        TError,
        {sessionId: string;data: AdditionalInfoDTO},
        TContext
      > => {

      const mutationOptions = getUpdateAdditionalInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쫧쮏쒫혩혮 혰혜햫혞혩혢햦햧 햣햢햪햣혝 향햟햪쮏쒫햣햫햫혪 (향 혰햢쒬뒗햟햢햟)
 */
export const updateItemInOrder = (
    sessionId: string,
    itemId: string,
    orderItemDTO: OrderItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/items/${sessionId}/${itemId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: orderItemDTO
    },
      options);
    }
  


export const getUpdateItemInOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateItemInOrder>>, TError,{sessionId: string;itemId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateItemInOrder>>, TError,{sessionId: string;itemId: string;data: OrderItemDTO}, TContext> => {

const mutationKey = ['updateItemInOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateItemInOrder>>, {sessionId: string;itemId: string;data: OrderItemDTO}> = (props) => {
          const {sessionId,itemId,data} = props ?? {};

          return  updateItemInOrder(sessionId,itemId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateItemInOrderMutationResult = NonNullable<Awaited<ReturnType<typeof updateItemInOrder>>>
    export type UpdateItemInOrderMutationBody = OrderItemDTO
    export type UpdateItemInOrderMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫혩혮 혰혜햫혞혩혢햦햧 햣햢햪햣혝 향햟햪쮏쒫햣햫햫혪 (향 혰햢쒬뒗햟햢햟)
 */
export const useUpdateItemInOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateItemInOrder>>, TError,{sessionId: string;itemId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateItemInOrder>>,
        TError,
        {sessionId: string;itemId: string;data: OrderItemDTO},
        TContext
      > => {

      const mutationOptions = getUpdateItemInOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳얧썛혪혮 햣햢햪햣혝 향 향햟햪쮏쒫햣햫햫혪
 */
export const deleteItemFromOrder = (
    sessionId: string,
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/items/${sessionId}/${itemId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteItemFromOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteItemFromOrder>>, TError,{sessionId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteItemFromOrder>>, TError,{sessionId: string;itemId: string}, TContext> => {

const mutationKey = ['deleteItemFromOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteItemFromOrder>>, {sessionId: string;itemId: string}> = (props) => {
          const {sessionId,itemId} = props ?? {};

          return  deleteItemFromOrder(sessionId,itemId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteItemFromOrderMutationResult = NonNullable<Awaited<ReturnType<typeof deleteItemFromOrder>>>
    
    export type DeleteItemFromOrderMutationError = ErrorResponse

    /**
 * @summary 뉋쟳얧썛혪혮 햣햢햪햣혝 향 향햟햪쮏쒫햣햫햫혪
 */
export const useDeleteItemFromOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteItemFromOrder>>, TError,{sessionId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteItemFromOrder>>,
        TError,
        {sessionId: string;itemId: string},
        TContext
      > => {

      const mutationOptions = getDeleteItemFromOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫혰 햢햟햫혰 혟쮐햪햦
 */
export const getCurrentNewClientForm = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<NewClientFormDTO>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/data`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCurrentNewClientFormQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/new-client/session/${sessionId}/data`] as const;
    }

    
export const getGetCurrentNewClientFormInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentNewClientForm>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentNewClientFormQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentNewClientForm>>> = ({ signal }) => getCurrentNewClientForm(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentNewClientFormInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentNewClientForm>>>
export type GetCurrentNewClientFormInfiniteQueryError = ErrorResponse


export function useGetCurrentNewClientFormInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentNewClientForm>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentNewClientForm>>,
          TError,
          Awaited<ReturnType<typeof getCurrentNewClientForm>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentNewClientFormInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentNewClientForm>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentNewClientForm>>,
          TError,
          Awaited<ReturnType<typeof getCurrentNewClientForm>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentNewClientFormInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentNewClientForm>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫혰 햢햟햫혰 혟쮐햪햦
 */

export function useGetCurrentNewClientFormInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentNewClientForm>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentNewClientFormInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentNewClientFormQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentNewClientFormQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentNewClientForm>>> = ({ signal }) => getCurrentNewClientForm(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentNewClientFormQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentNewClientForm>>>
export type GetCurrentNewClientFormQueryError = ErrorResponse


export function useGetCurrentNewClientForm<TData = Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentNewClientForm>>,
          TError,
          Awaited<ReturnType<typeof getCurrentNewClientForm>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentNewClientForm<TData = Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentNewClientForm>>,
          TError,
          Awaited<ReturnType<typeof getCurrentNewClientForm>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentNewClientForm<TData = Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫혰 햢햟햫혰 혟쮐햪햦
 */

export function useGetCurrentNewClientForm<TData = Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentNewClientForm>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentNewClientFormQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤯쫧쮏쒫혩혮 햢햟햫혰 혟쮐햪햦 햨햩혰혮햫혝햟
 */
export const updateNewClientData = (
    sessionId: string,
    newClientFormDTO: NewClientFormDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/data`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: newClientFormDTO
    },
      options);
    }
  


export const getUpdateNewClientDataMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNewClientData>>, TError,{sessionId: string;data: NewClientFormDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNewClientData>>, TError,{sessionId: string;data: NewClientFormDTO}, TContext> => {

const mutationKey = ['updateNewClientData'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNewClientData>>, {sessionId: string;data: NewClientFormDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateNewClientData(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateNewClientDataMutationResult = NonNullable<Awaited<ReturnType<typeof updateNewClientData>>>
    export type UpdateNewClientDataMutationBody = NewClientFormDTO
    export type UpdateNewClientDataMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫혩혮 햢햟햫혰 혟쮐햪햦 햨햩혰혮햫혝햟
 */
export const useUpdateNewClientData = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNewClientData>>, TError,{sessionId: string;data: NewClientFormDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateNewClientData>>,
        TError,
        {sessionId: string;data: NewClientFormDTO},
        TContext
      > => {

      const mutationOptions = getUpdateNewClientDataMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫혞 햠햟향쮏쒬 혰햫혟쮐햪햟혡혰혩
 */
export const getCurrentBasicOrderInfo = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<BasicOrderInfoDTO>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/data`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCurrentBasicOrderInfoQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/basic-order/session/${sessionId}/data`] as const;
    }

    
export const getGetCurrentBasicOrderInfoInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentBasicOrderInfoQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>> = ({ signal }) => getCurrentBasicOrderInfo(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentBasicOrderInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>>
export type GetCurrentBasicOrderInfoInfiniteQueryError = ErrorResponse


export function useGetCurrentBasicOrderInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>,
          TError,
          Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentBasicOrderInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>,
          TError,
          Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentBasicOrderInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫혞 햠햟향쮏쒬 혰햫혟쮐햪햟혡혰혩
 */

export function useGetCurrentBasicOrderInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentBasicOrderInfoInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentBasicOrderInfoQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentBasicOrderInfoQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>> = ({ signal }) => getCurrentBasicOrderInfo(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentBasicOrderInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>>
export type GetCurrentBasicOrderInfoQueryError = ErrorResponse


export function useGetCurrentBasicOrderInfo<TData = Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>,
          TError,
          Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentBasicOrderInfo<TData = Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>,
          TError,
          Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentBasicOrderInfo<TData = Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫혞 햠햟향쮏쒬 혰햫혟쮐햪햟혡혰혩
 */

export function useGetCurrentBasicOrderInfo<TData = Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentBasicOrderInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentBasicOrderInfoQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤯쫧쮏쒫혩혮 햠햟향쮏쒬 혰햫혟쮐햪햟혡혰혩
 */
export const updateBasicOrderInfo = (
    sessionId: string,
    basicOrderInfoDTO: BasicOrderInfoDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/data`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: basicOrderInfoDTO
    },
      options);
    }
  


export const getUpdateBasicOrderInfoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBasicOrderInfo>>, TError,{sessionId: string;data: BasicOrderInfoDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateBasicOrderInfo>>, TError,{sessionId: string;data: BasicOrderInfoDTO}, TContext> => {

const mutationKey = ['updateBasicOrderInfo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBasicOrderInfo>>, {sessionId: string;data: BasicOrderInfoDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateBasicOrderInfo(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBasicOrderInfoMutationResult = NonNullable<Awaited<ReturnType<typeof updateBasicOrderInfo>>>
    export type UpdateBasicOrderInfoMutationBody = BasicOrderInfoDTO
    export type UpdateBasicOrderInfoMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫혩혮 햠햟향쮏쒬 혰햫혟쮐햪햟혡혰혩
 */
export const useUpdateBasicOrderInfo = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBasicOrderInfo>>, TError,{sessionId: string;data: BasicOrderInfoDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBasicOrderInfo>>,
        TError,
        {sessionId: string;data: BasicOrderInfoDTO},
        TContext
      > => {

      const mutationOptions = getUpdateBasicOrderInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혝햦 햩혪햪햦 향햟 쒫쥃썛햟햫햦햪 혰햢햣햫혝햦혟혰햨햟혝쮐쮏
 * @summary 뤰햦햪햟혝햦 혝햦 햩혪햪햦 향햟 ID
 */
export const getStainTypeById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetStainTypeById200>(
      {url: `/stain-types/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStainTypeByIdQueryKey = (id: string,) => {
    return [`/stain-types/${id}`] as const;
    }

    
export const getGetStainTypeByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeById>>> = ({ signal }) => getStainTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeById>>>
export type GetStainTypeByIdInfiniteQueryError = ErrorResponse


export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦 햩혪햪햦 향햟 ID
 */

export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeById>>> = ({ signal }) => getStainTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeById>>>
export type GetStainTypeByIdQueryError = ErrorResponse


export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦 햩혪햪햦 향햟 ID
 */

export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 뤯쫧쮏쒫혩혮 혰혜햫혞혩혢햦햧 혝햦 햩혪햪햦 향햟 쒫쥃썛햟햫햦햪 혰햢햣햫혝햦혟혰햨햟혝쮐쮏
 * @summary 뤯쫧쮏쒫쟴햦 혝햦 햩혪햪햦
 */
export const updateStainType = (
    id: string,
    stainTypeDTO: StainTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdateStainType200>(
      {url: `/stain-types/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: stainTypeDTO
    },
      options);
    }
  


export const getUpdateStainTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStainType>>, TError,{id: string;data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateStainType>>, TError,{id: string;data: StainTypeDTO}, TContext> => {

const mutationKey = ['updateStainType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateStainType>>, {id: string;data: StainTypeDTO}> = (props) => {
          const {id,data} = props ?? {};

          return  updateStainType(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateStainTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateStainType>>>
    export type UpdateStainTypeMutationBody = StainTypeDTO
    export type UpdateStainTypeMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 혝햦 햩혪햪햦
 */
export const useUpdateStainType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStainType>>, TError,{id: string;data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateStainType>>,
        TError,
        {id: string;data: StainTypeDTO},
        TContext
      > => {

      const mutationOptions = getUpdateStainTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뉋쟳얧썛혪혮 혝햦 햩혪햪햦 향햟 쒫쥃썛햟햫햦햪 혰햢햣햫혝햦혟혰햨햟혝쮐쮏
 * @summary 뉋쟳얧썛햦혝햦 혝햦 햩혪햪햦
 */
export const deleteStainType = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeleteStainType200>(
      {url: `/stain-types/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteStainTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStainType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteStainType>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteStainType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteStainType>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteStainType(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteStainTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStainType>>>
    
    export type DeleteStainTypeMutationError = ErrorResponse

    /**
 * @summary 뉋쟳얧썛햦혝햦 혝햦 햩혪햪햦
 */
export const useDeleteStainType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStainType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteStainType>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteStainTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐 향햟 ID
 */
export const getModifierById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifierById200>(
      {url: `/price-modifiers/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifierByIdQueryKey = (id: string,) => {
    return [`/price-modifiers/${id}`] as const;
    }

    
export const getGetModifierByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierById>>> = ({ signal }) => getModifierById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierById>>>
export type GetModifierByIdInfiniteQueryError = ErrorResponse


export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐 향햟 ID
 */

export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifierByIdQueryOptions = <TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierById>>> = ({ signal }) => getModifierById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierById>>>
export type GetModifierByIdQueryError = ErrorResponse


export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐 향햟 ID
 */

export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤯쫧쮏쒫쟴햦 혰혜햫혞혩혢햦햧 햪쮏얧쟴혰햨햟혝쮐 혡혰햫햦
 */
export const updateModifier = (
    id: string,
    priceModifierDTO: PriceModifierDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdateModifier200>(
      {url: `/price-modifiers/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: priceModifierDTO
    },
      options);
    }
  


export const getUpdateModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModifier>>, TError,{id: string;data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateModifier>>, TError,{id: string;data: PriceModifierDTO}, TContext> => {

const mutationKey = ['updateModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateModifier>>, {id: string;data: PriceModifierDTO}> = (props) => {
          const {id,data} = props ?? {};

          return  updateModifier(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateModifierMutationResult = NonNullable<Awaited<ReturnType<typeof updateModifier>>>
    export type UpdateModifierMutationBody = PriceModifierDTO
    export type UpdateModifierMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 혰혜햫혞혩혢햦햧 햪쮏얧쟴혰햨햟혝쮐 혡혰햫햦
 */
export const useUpdateModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModifier>>, TError,{id: string;data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateModifier>>,
        TError,
        {id: string;data: PriceModifierDTO},
        TContext
      > => {

      const mutationOptions = getUpdateModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햆햣햟햨혝햦쒬쒫썜햦 햪쮏얧쟴혰햨햟혝쮐 혡혰햫햦
 */
export const deactivateModifier = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeactivateModifier200>(
      {url: `/price-modifiers/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeactivateModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateModifier>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deactivateModifier>>, TError,{id: string}, TContext> => {

const mutationKey = ['deactivateModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deactivateModifier>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deactivateModifier(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeactivateModifierMutationResult = NonNullable<Awaited<ReturnType<typeof deactivateModifier>>>
    
    export type DeactivateModifierMutationError = ErrorResponse

    /**
 * @summary 햆햣햟햨혝햦쒬쒫썜햦 햪쮏얧쟴혰햨햟혝쮐 혡혰햫햦
 */
export const useDeactivateModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateModifier>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deactivateModifier>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeactivateModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤰햦햪햟혝햦 햣햩햣햪햣햫혝 햟햧혜-햩햦혜혝햟 향햟 ID
 */
export const getItemById = (
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemById200>(
      {url: `/price-list/item/${itemId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemByIdQueryKey = (itemId: string,) => {
    return [`/price-list/item/${itemId}`] as const;
    }

    
export const getGetItemByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemByIdQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemById>>> = ({ signal }) => getItemById(itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemById>>>
export type GetItemByIdInfiniteQueryError = ErrorResponse


export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햣햩햣햪햣햫혝 햟햧혜-햩햦혜혝햟 향햟 ID
 */

export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemByIdInfiniteQueryOptions(itemId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemByIdQueryOptions = <TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemByIdQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemById>>> = ({ signal }) => getItemById(itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getItemById>>>
export type GetItemByIdQueryError = ErrorResponse


export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햣햩햣햪햣햫혝 햟햧혜-햩햦혜혝햟 향햟 ID
 */

export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemByIdQueryOptions(itemId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤯쫧쮏쒫쟴햦 햣햩햣햪햣햫혝 햟햧혜-햩햦혜혝햟
 */
export const updatePriceListItem = (
    itemId: string,
    priceListItemDTO: PriceListItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdatePriceListItem200>(
      {url: `/price-list/item/${itemId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: priceListItemDTO
    },
      options);
    }
  


export const getUpdatePriceListItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePriceListItem>>, TError,{itemId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePriceListItem>>, TError,{itemId: string;data: PriceListItemDTO}, TContext> => {

const mutationKey = ['updatePriceListItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePriceListItem>>, {itemId: string;data: PriceListItemDTO}> = (props) => {
          const {itemId,data} = props ?? {};

          return  updatePriceListItem(itemId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePriceListItemMutationResult = NonNullable<Awaited<ReturnType<typeof updatePriceListItem>>>
    export type UpdatePriceListItemMutationBody = PriceListItemDTO
    export type UpdatePriceListItemMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 햣햩햣햪햣햫혝 햟햧혜-햩햦혜혝햟
 */
export const useUpdatePriceListItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePriceListItem>>, TError,{itemId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePriceListItem>>,
        TError,
        {itemId: string;data: PriceListItemDTO},
        TContext
      > => {

      const mutationOptions = getUpdatePriceListItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쫧쮏쒫쟴햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡
 */
export const updateCategory = (
    categoryId: string,
    serviceCategoryDTO: ServiceCategoryDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdateCategory200>(
      {url: `/price-list/category/${categoryId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: serviceCategoryDTO
    },
      options);
    }
  


export const getUpdateCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: ServiceCategoryDTO}, TContext> => {

const mutationKey = ['updateCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCategory>>, {categoryId: string;data: ServiceCategoryDTO}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  updateCategory(categoryId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategory>>>
    export type UpdateCategoryMutationBody = ServiceCategoryDTO
    export type UpdateCategoryMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡
 */
export const useUpdateCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCategory>>,
        TError,
        {categoryId: string;data: ServiceCategoryDTO},
        TContext
      > => {

      const mutationOptions = getUpdateCategoryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 햣햢햪햣혝 향햟햪쮏쒫햣햫햫혪 향햟 햧쮏 ID
 * @summary 뤰햦햪햟혝햦 햨쮏쫧쥄햣혝햫햦햧 햣햢햪햣혝 향햟햪쮏쒫햣햫햫혪
 */
export const getOrderItem = (
    orderId: string,
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderItemDTO>(
      {url: `/orders/${orderId}/items/${itemId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderItemQueryKey = (orderId: string,
    itemId: string,) => {
    return [`/orders/${orderId}/items/${itemId}`] as const;
    }

    
export const getGetOrderItemInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderItem>>>, TError = ErrorResponse>(orderId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderItemQueryKey(orderId,itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderItem>>> = ({ signal }) => getOrderItem(orderId,itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId && itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderItemInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderItem>>>
export type GetOrderItemInfiniteQueryError = ErrorResponse


export function useGetOrderItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItem>>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItem>>,
          TError,
          Awaited<ReturnType<typeof getOrderItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItem>>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItem>>,
          TError,
          Awaited<ReturnType<typeof getOrderItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItem>>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨쮏쫧쥄햣혝햫햦햧 햣햢햪햣혝 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItem>>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderItemInfiniteQueryOptions(orderId,itemId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderItemQueryOptions = <TData = Awaited<ReturnType<typeof getOrderItem>>, TError = ErrorResponse>(orderId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderItemQueryKey(orderId,itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderItem>>> = ({ signal }) => getOrderItem(orderId,itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId && itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderItemQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderItem>>>
export type GetOrderItemQueryError = ErrorResponse


export function useGetOrderItem<TData = Awaited<ReturnType<typeof getOrderItem>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItem>>,
          TError,
          Awaited<ReturnType<typeof getOrderItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItem<TData = Awaited<ReturnType<typeof getOrderItem>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItem>>,
          TError,
          Awaited<ReturnType<typeof getOrderItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItem<TData = Awaited<ReturnType<typeof getOrderItem>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨쮏쫧쥄햣혝햫햦햧 햣햢햪햣혝 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderItem<TData = Awaited<ReturnType<typeof getOrderItem>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderItemQueryOptions(orderId,itemId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 뤯쫧쮏쒫혩혮 혰혜햫혞혩혢햦햧 햣햢햪햣혝 혞 향햟햪쮏쒫햣햫햫혰
 * @summary 뤯쫧쮏쒫쟴햦 햣햢햪햣혝 향햟햪쮏쒫햣햫햫혪
 */
export const updateOrderItem = (
    orderId: string,
    itemId: string,
    orderItemDTO: OrderItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderItemDTO>(
      {url: `/orders/${orderId}/items/${itemId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: orderItemDTO
    },
      options);
    }
  


export const getUpdateOrderItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderItem>>, TError,{orderId: string;itemId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateOrderItem>>, TError,{orderId: string;itemId: string;data: OrderItemDTO}, TContext> => {

const mutationKey = ['updateOrderItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOrderItem>>, {orderId: string;itemId: string;data: OrderItemDTO}> = (props) => {
          const {orderId,itemId,data} = props ?? {};

          return  updateOrderItem(orderId,itemId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateOrderItemMutationResult = NonNullable<Awaited<ReturnType<typeof updateOrderItem>>>
    export type UpdateOrderItemMutationBody = OrderItemDTO
    export type UpdateOrderItemMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 햣햢햪햣혝 향햟햪쮏쒫햣햫햫혪
 */
export const useUpdateOrderItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderItem>>, TError,{orderId: string;itemId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateOrderItem>>,
        TError,
        {orderId: string;itemId: string;data: OrderItemDTO},
        TContext
      > => {

      const mutationOptions = getUpdateOrderItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뉋쟳얧썛혪혮 햣햢햪햣혝 혰향 향햟햪쮏쒫햣햫햫혪
 * @summary 뉋쟳얧썛햦혝햦 햣햢햪햣혝 향햟햪쮏쒫햣햫햫혪
 */
export const deleteOrderItem = (
    orderId: string,
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeleteOrderItem204>(
      {url: `/orders/${orderId}/items/${itemId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteOrderItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOrderItem>>, TError,{orderId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteOrderItem>>, TError,{orderId: string;itemId: string}, TContext> => {

const mutationKey = ['deleteOrderItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteOrderItem>>, {orderId: string;itemId: string}> = (props) => {
          const {orderId,itemId} = props ?? {};

          return  deleteOrderItem(orderId,itemId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteOrderItemMutationResult = NonNullable<Awaited<ReturnType<typeof deleteOrderItem>>>
    
    export type DeleteOrderItemMutationError = ErrorResponse

    /**
 * @summary 뉋쟳얧썛햦혝햦 햣햢햪햣혝 향햟햪쮏쒫햣햫햫혪
 */
export const useDeleteOrderItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOrderItem>>, TError,{orderId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteOrderItem>>,
        TError,
        {orderId: string;itemId: string},
        TContext
      > => {

      const mutationOptions = getDeleteOrderItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뤯쫧쮏쒫혩혮 혜혝햟혝혞혜 향햟햪쮏쒫햣햫햫혪
 * @summary 뤯쫧쮏쒫쟴햦 혜혝햟혝혞혜 향햟햪쮏쒫햣햫햫혪
 */
export const updateOrderStatus = (
    id: string,
    status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED',
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}/status/${status}`, method: 'PUT'
    },
      options);
    }
  


export const getUpdateOrderStatusMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderStatus>>, TError,{id: string;status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED'}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateOrderStatus>>, TError,{id: string;status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED'}, TContext> => {

const mutationKey = ['updateOrderStatus'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOrderStatus>>, {id: string;status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED'}> = (props) => {
          const {id,status} = props ?? {};

          return  updateOrderStatus(id,status,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateOrderStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateOrderStatus>>>
    
    export type UpdateOrderStatusMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 혜혝햟혝혞혜 향햟햪쮏쒫햣햫햫혪
 */
export const useUpdateOrderStatus = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderStatus>>, TError,{id: string;status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED'}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateOrderStatus>>,
        TError,
        {id: string;status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED'},
        TContext
      > => {

      const mutationOptions = getUpdateOrderStatusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 햆쮏얧썜 햣햣햢쮏햩햟혝혞 햢 향햟햪쮏쒫햣햫햫혪
 * @summary 햆쮏얧썜햦 햣햣햢쮏햩햟혝혞
 */
export const addPrepayment = (
    id: string,
    amount: number,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}/prepayment/${amount}`, method: 'PUT'
    },
      options);
    }
  


export const getAddPrepaymentMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPrepayment>>, TError,{id: string;amount: number}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof addPrepayment>>, TError,{id: string;amount: number}, TContext> => {

const mutationKey = ['addPrepayment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPrepayment>>, {id: string;amount: number}> = (props) => {
          const {id,amount} = props ?? {};

          return  addPrepayment(id,amount,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddPrepaymentMutationResult = NonNullable<Awaited<ReturnType<typeof addPrepayment>>>
    
    export type AddPrepaymentMutationError = ErrorResponse

    /**
 * @summary 햆쮏얧썜햦 햣햣햢쮏햩햟혝혞
 */
export const useAddPrepayment = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPrepayment>>, TError,{id: string;amount: number}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addPrepayment>>,
        TError,
        {id: string;amount: number},
        TContext
      > => {

      const mutationOptions = getAddPrepaymentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 행햟혜혝쮐쮏쒬혮 향햫햦햤햨혞 햢 향햟햪쮏쒫햣햫햫혪
 * @summary 행햟혜혝쮐혞쒫썜햦 향햫햦햤햨혞
 */
export const applyDiscount = (
    id: string,
    amount: number,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}/discount/${amount}`, method: 'PUT'
    },
      options);
    }
  


export const getApplyDiscountMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyDiscount>>, TError,{id: string;amount: number}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof applyDiscount>>, TError,{id: string;amount: number}, TContext> => {

const mutationKey = ['applyDiscount'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof applyDiscount>>, {id: string;amount: number}> = (props) => {
          const {id,amount} = props ?? {};

          return  applyDiscount(id,amount,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApplyDiscountMutationResult = NonNullable<Awaited<ReturnType<typeof applyDiscount>>>
    
    export type ApplyDiscountMutationError = ErrorResponse

    /**
 * @summary 행햟혜혝쮐혞쒫썜햦 향햫햦햤햨혞
 */
export const useApplyDiscount = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyDiscount>>, TError,{id: string;amount: number}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof applyDiscount>>,
        TError,
        {id: string;amount: number},
        TContext
      > => {

      const mutationOptions = getApplyDiscountMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 햣햣혝쒫쮐혩혮 혢햣햫햣혝햨혞 햫햟 햟햨혝햦쒫쫧 향햟햪쮏쒫햣햫햫혪
 * @summary 햣햣혝쒫쮐햦혝햦 혢햣햫햣혝햨혞 햫햟 향햟햪쮏쒫햣햫햫혪
 */
export const convertDraftToOrder = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}/convert-draft`, method: 'PUT'
    },
      options);
    }
  


export const getConvertDraftToOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof convertDraftToOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof convertDraftToOrder>>, TError,{id: string}, TContext> => {

const mutationKey = ['convertDraftToOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof convertDraftToOrder>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  convertDraftToOrder(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConvertDraftToOrderMutationResult = NonNullable<Awaited<ReturnType<typeof convertDraftToOrder>>>
    
    export type ConvertDraftToOrderMutationError = ErrorResponse

    /**
 * @summary 햣햣혝쒫쮐햦혝햦 혢햣햫햣혝햨혞 햫햟 향햟햪쮏쒫햣햫햫혪
 */
export const useConvertDraftToOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof convertDraftToOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof convertDraftToOrder>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getConvertDraftToOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뉌뒗얧햫햟혢햟혮 향햟햪쮏쒫햣햫햫혪 혪햨 쒫쟳쥃쮏쫧썛쫧
 * @summary 뉌뒗얧햫햟혢햦혝햦 향햟햪쮏쒫햣햫햫혪 혪햨 쒫쟳쥃쮏쫧썛쫧
 */
export const completeOrder = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}/complete`, method: 'PUT'
    },
      options);
    }
  


export const getCompleteOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof completeOrder>>, TError,{id: string}, TContext> => {

const mutationKey = ['completeOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeOrder>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  completeOrder(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteOrderMutationResult = NonNullable<Awaited<ReturnType<typeof completeOrder>>>
    
    export type CompleteOrderMutationError = ErrorResponse

    /**
 * @summary 뉌뒗얧햫햟혢햦혝햦 향햟햪쮏쒫햣햫햫혪 혪햨 쒫쟳쥃쮏쫧썛쫧
 */
export const useCompleteOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeOrder>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getCompleteOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뤯쫧쮏쒫혩혮 혝햦 혝햣햪혰햫쮏쒫쮐혝혰 혝햟 쮐혰햨혞쒫썛쫨 햢햟혝혞 향햟쒫왐혣햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 * @summary 뤯쫧쮏쒫쟴햦 햟햟햪햣혝햦 쒫쟳쥃쮏쫧썛쫧쫨 향햟햪쮏쒫햣햫햫혪
 */
export const updateOrderCompletion = (
    orderCompletionUpdateRequest: OrderCompletionUpdateRequest,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdateOrderCompletion200>(
      {url: `/orders/completion/update`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: orderCompletionUpdateRequest
    },
      options);
    }
  


export const getUpdateOrderCompletionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderCompletion>>, TError,{data: OrderCompletionUpdateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateOrderCompletion>>, TError,{data: OrderCompletionUpdateRequest}, TContext> => {

const mutationKey = ['updateOrderCompletion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOrderCompletion>>, {data: OrderCompletionUpdateRequest}> = (props) => {
          const {data} = props ?? {};

          return  updateOrderCompletion(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateOrderCompletionMutationResult = NonNullable<Awaited<ReturnType<typeof updateOrderCompletion>>>
    export type UpdateOrderCompletionMutationBody = OrderCompletionUpdateRequest
    export type UpdateOrderCompletionMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 햟햟햪햣혝햦 쒫쟳쥃쮏쫧썛쫧쫨 향햟햪쮏쒫햣햫햫혪
 */
export const useUpdateOrderCompletion = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderCompletion>>, TError,{data: OrderCompletionUpdateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateOrderCompletion>>,
        TError,
        {data: OrderCompletionUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateOrderCompletionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뤯쫧쮏쒫혩혮 햟햫쮐햟혡혰혱 (쮏햫햟혢햨햦) 혝햟 쮏햦혜 햢햩혪 쒫쥃썛햟햫쮐 혟쮐쮏햟혟혰혱
 * @summary 뤯쫧쮏쒫쟴햦 햟햫쮐햟혡혰혱 혟쮐쮏햟혟혰혱
 */
export const updatePhotoAnnotations = (
    itemId: string,
    photoId: string,
    params: UpdatePhotoAnnotationsParams,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderItemPhotoDTO>(
      {url: `/order-items/${itemId}/photos/${photoId}/annotations`, method: 'PUT',
        params
    },
      options);
    }
  


export const getUpdatePhotoAnnotationsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePhotoAnnotations>>, TError,{itemId: string;photoId: string;params: UpdatePhotoAnnotationsParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePhotoAnnotations>>, TError,{itemId: string;photoId: string;params: UpdatePhotoAnnotationsParams}, TContext> => {

const mutationKey = ['updatePhotoAnnotations'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePhotoAnnotations>>, {itemId: string;photoId: string;params: UpdatePhotoAnnotationsParams}> = (props) => {
          const {itemId,photoId,params} = props ?? {};

          return  updatePhotoAnnotations(itemId,photoId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePhotoAnnotationsMutationResult = NonNullable<Awaited<ReturnType<typeof updatePhotoAnnotations>>>
    
    export type UpdatePhotoAnnotationsMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 햟햫쮐햟혡혰혱 혟쮐쮏햟혟혰혱
 */
export const useUpdatePhotoAnnotations = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePhotoAnnotations>>, TError,{itemId: string;photoId: string;params: UpdatePhotoAnnotationsParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePhotoAnnotations>>,
        TError,
        {itemId: string;photoId: string;params: UpdatePhotoAnnotationsParams},
        TContext
      > => {

      const mutationOptions = getUpdatePhotoAnnotationsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혝햦 햢햣혟햣햨혝혞 향햟 쒫쥃썛햟햫햦햪 혰햢햣햫혝햦혟혰햨햟혝쮐쮏
 * @summary 뤰햦햪햟혝햦 혝햦 햢햣혟햣햨혝혞 향햟 ID
 */
export const getDefectTypeById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetDefectTypeById200>(
      {url: `/defect-types/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectTypeByIdQueryKey = (id: string,) => {
    return [`/defect-types/${id}`] as const;
    }

    
export const getGetDefectTypeByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeById>>> = ({ signal }) => getDefectTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeById>>>
export type GetDefectTypeByIdInfiniteQueryError = ErrorResponse


export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦 햢햣혟햣햨혝혞 향햟 ID
 */

export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectTypeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeById>>> = ({ signal }) => getDefectTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeById>>>
export type GetDefectTypeByIdQueryError = ErrorResponse


export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦 햢햣혟햣햨혝혞 향햟 ID
 */

export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 뤯쫧쮏쒫혩혮 혰혜햫혞혩혢햦햧 혝햦 햢햣혟햣햨혝혞 향햟 쒫쥃썛햟햫햦햪 혰햢햣햫혝햦혟혰햨햟혝쮐쮏
 * @summary 뤯쫧쮏쒫쟴햦 혝햦 햢햣혟햣햨혝혞
 */
export const updateDefectType = (
    id: string,
    defectTypeDTO: DefectTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DefectTypeDTO>(
      {url: `/defect-types/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: defectTypeDTO
    },
      options);
    }
  


export const getUpdateDefectTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDefectType>>, TError,{id: string;data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateDefectType>>, TError,{id: string;data: DefectTypeDTO}, TContext> => {

const mutationKey = ['updateDefectType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDefectType>>, {id: string;data: DefectTypeDTO}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDefectType(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDefectTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateDefectType>>>
    export type UpdateDefectTypeMutationBody = DefectTypeDTO
    export type UpdateDefectTypeMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 혝햦 햢햣혟햣햨혝혞
 */
export const useUpdateDefectType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDefectType>>, TError,{id: string;data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDefectType>>,
        TError,
        {id: string;data: DefectTypeDTO},
        TContext
      > => {

      const mutationOptions = getUpdateDefectTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뉋쟳얧썛혪혮 혝햦 햢햣혟햣햨혝혞 향햟 쒫쥃썛햟햫햦햪 혰햢햣햫혝햦혟혰햨햟혝쮐쮏
 * @summary 뉋쟳얧썛햦혝햦 혝햦 햢햣혟햣햨혝혞
 */
export const deleteDefectType = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/defect-types/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteDefectTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDefectType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDefectType>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteDefectType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDefectType>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteDefectType(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDefectTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDefectType>>>
    
    export type DeleteDefectTypeMutationError = ErrorResponse

    /**
 * @summary 뉋쟳얧썛햦혝햦 혝햦 햢햣혟햣햨혝혞
 */
export const useDeleteDefectType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDefectType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDefectType>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteDefectTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 햢햟햫혰 햨햩혰혮햫혝햟 향햟 햧쮏 ID
 * @summary 뤰햦햪햟혝햦 햨햩혰혮햫혝햟 향햟 ID
 */
export const getClientById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/clients/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetClientByIdQueryKey = (id: string,) => {
    return [`/clients/${id}`] as const;
    }

    
export const getGetClientByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClientById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClientByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClientById>>> = ({ signal }) => getClientById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetClientByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClientById>>>
export type GetClientByIdInfiniteQueryError = ErrorResponse


export function useGetClientByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientById>>,
          TError,
          Awaited<ReturnType<typeof getClientById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientById>>,
          TError,
          Awaited<ReturnType<typeof getClientById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨햩혰혮햫혝햟 향햟 ID
 */

export function useGetClientByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetClientByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClientByIdQueryOptions = <TData = Awaited<ReturnType<typeof getClientById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClientByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClientById>>> = ({ signal }) => getClientById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetClientByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getClientById>>>
export type GetClientByIdQueryError = ErrorResponse


export function useGetClientById<TData = Awaited<ReturnType<typeof getClientById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientById>>,
          TError,
          Awaited<ReturnType<typeof getClientById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientById<TData = Awaited<ReturnType<typeof getClientById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientById>>,
          TError,
          Awaited<ReturnType<typeof getClientById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientById<TData = Awaited<ReturnType<typeof getClientById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨햩혰혮햫혝햟 향햟 ID
 */

export function useGetClientById<TData = Awaited<ReturnType<typeof getClientById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetClientByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 뤯쫧쮏쒫혩혮 햢햟햫혰 혰혜햫혞혩혢쮏 햨햩혰혮햫혝햟
 * @summary 뤯쫧쮏쒫쟴햦 햨햩혰혮햫혝햟
 */
export const updateClient = (
    id: string,
    updateClientRequest: UpdateClientRequest,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/clients/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateClientRequest
    },
      options);
    }
  


export const getUpdateClientMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClient>>, TError,{id: string;data: UpdateClientRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateClient>>, TError,{id: string;data: UpdateClientRequest}, TContext> => {

const mutationKey = ['updateClient'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateClient>>, {id: string;data: UpdateClientRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateClient(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateClientMutationResult = NonNullable<Awaited<ReturnType<typeof updateClient>>>
    export type UpdateClientMutationBody = UpdateClientRequest
    export type UpdateClientMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 햨햩혰혮햫혝햟
 */
export const useUpdateClient = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClient>>, TError,{id: string;data: UpdateClientRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateClient>>,
        TError,
        {id: string;data: UpdateClientRequest},
        TContext
      > => {

      const mutationOptions = getUpdateClientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뉋쟳얧썛혪혮 햨햩혰혮햫혝햟 향햟 햧쮏 ID
 * @summary 뉋쟳얧썛햦혝햦 햨햩혰혮햫혝햟
 */
export const deleteClient = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeleteClient204>(
      {url: `/clients/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteClientMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClient>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteClient>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteClient'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteClient>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteClient(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteClientMutationResult = NonNullable<Awaited<ReturnType<typeof deleteClient>>>
    
    export type DeleteClientMutationError = ErrorResponse

    /**
 * @summary 뉋쟳얧썛햦혝햦 햨햩혰혮햫혝햟
 */
export const useDeleteClient = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClient>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteClient>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteClientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혞햫햨혝 햦햧쮏쩀 향햟 쒫쥃썛햟햫햦햪 혰햢햣햫혝햦혟혰햨햟혝쮐쮏
 * @summary 뤰햦햪햟혝햦 혞햫햨혝 햦햧쮏쩀 향햟 ID
 */
export const getBranchLocationById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetBranchLocationByIdQueryKey = (id: string,) => {
    return [`/branch-locations/${id}`] as const;
    }

    
export const getGetBranchLocationByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchLocationByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranchLocationById>>> = ({ signal }) => getBranchLocationById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBranchLocationByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getBranchLocationById>>>
export type GetBranchLocationByIdInfiniteQueryError = ErrorResponse


export function useGetBranchLocationByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationById>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationById>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혞햫햨혝 햦햧쮏쩀 향햟 ID
 */

export function useGetBranchLocationByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBranchLocationByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBranchLocationByIdQueryOptions = <TData = Awaited<ReturnType<typeof getBranchLocationById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchLocationByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranchLocationById>>> = ({ signal }) => getBranchLocationById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBranchLocationByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBranchLocationById>>>
export type GetBranchLocationByIdQueryError = ErrorResponse


export function useGetBranchLocationById<TData = Awaited<ReturnType<typeof getBranchLocationById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationById>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationById<TData = Awaited<ReturnType<typeof getBranchLocationById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationById>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationById<TData = Awaited<ReturnType<typeof getBranchLocationById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혞햫햨혝 햦햧쮏쩀 향햟 ID
 */

export function useGetBranchLocationById<TData = Awaited<ReturnType<typeof getBranchLocationById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBranchLocationByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 뤯쫧쮏쒫혩혮 혰혜햫혞혩혢햦햧 혞햫햨혝 햦햧쮏쩀 향햟햪쮏쒫햣햫혧
 * @summary 뤯쫧쮏쒫쟴햦 혞햫햨혝 햦햧쮏쩀
 */
export const updateBranchLocation = (
    id: string,
    branchLocationUpdateRequest: BranchLocationUpdateRequest,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: branchLocationUpdateRequest
    },
      options);
    }
  


export const getUpdateBranchLocationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBranchLocation>>, TError,{id: string;data: BranchLocationUpdateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateBranchLocation>>, TError,{id: string;data: BranchLocationUpdateRequest}, TContext> => {

const mutationKey = ['updateBranchLocation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBranchLocation>>, {id: string;data: BranchLocationUpdateRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBranchLocation(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBranchLocationMutationResult = NonNullable<Awaited<ReturnType<typeof updateBranchLocation>>>
    export type UpdateBranchLocationMutationBody = BranchLocationUpdateRequest
    export type UpdateBranchLocationMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 혞햫햨혝 햦햧쮏쩀
 */
export const useUpdateBranchLocation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBranchLocation>>, TError,{id: string;data: BranchLocationUpdateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBranchLocation>>,
        TError,
        {id: string;data: BranchLocationUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateBranchLocationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뉋쟳얧썛혪혮 혞햫햨혝 햦햧쮏쩀 향햟햪쮏쒫햣햫혧
 * @summary 뉋쟳얧썛햦혝햦 혞햫햨혝 햦햧쮏쩀
 */
export const deleteBranchLocation = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeleteBranchLocation204>(
      {url: `/branch-locations/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteBranchLocationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBranchLocation>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBranchLocation>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteBranchLocation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBranchLocation>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteBranchLocation(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBranchLocationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBranchLocation>>>
    
    export type DeleteBranchLocationMutationError = ErrorResponse

    /**
 * @summary 뉋쟳얧썛햦혝햦 혞햫햨혝 햦햧쮏쩀
 */
export const useDeleteBranchLocation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBranchLocation>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBranchLocation>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteBranchLocationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 행햪혰햫혩혮 혜혝햟혝혞혜 햟햨혝햦쒫쫧쮐혝혰 혞햫햨혝혞 햦햧쮏쩀
 * @summary 행햪혰햫햦혝햦 혜혝햟혝혞혜 햟햨혝햦쒫쫧쮐혝혰
 */
export const setActiveStatus = (
    id: string,
    params: SetActiveStatusParams,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations/${id}/active`, method: 'PUT',
        params
    },
      options);
    }
  


export const getSetActiveStatusMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setActiveStatus>>, TError,{id: string;params: SetActiveStatusParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof setActiveStatus>>, TError,{id: string;params: SetActiveStatusParams}, TContext> => {

const mutationKey = ['setActiveStatus'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setActiveStatus>>, {id: string;params: SetActiveStatusParams}> = (props) => {
          const {id,params} = props ?? {};

          return  setActiveStatus(id,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetActiveStatusMutationResult = NonNullable<Awaited<ReturnType<typeof setActiveStatus>>>
    
    export type SetActiveStatusMutationError = ErrorResponse

    /**
 * @summary 행햪혰햫햦혝햦 혜혝햟혝혞혜 햟햨혝햦쒫쫧쮐혝혰
 */
export const useSetActiveStatus = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setActiveStatus>>, TError,{id: string;params: SetActiveStatusParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setActiveStatus>>,
        TError,
        {id: string;params: SetActiveStatusParams},
        TContext
      > => {

      const mutationOptions = getSetActiveStatusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋썛혰햢햟혡혰혪 햨쮏쫨혰햡혞햟혡혰혱 햨쒫쟴햟햫혡혰혱
 */
export const validateReceiptConfiguration = (
    receiptConfigurationDTO: ReceiptConfigurationDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidateReceiptConfiguration200>(
      {url: `/v1/order-wizard/stage4/validate/receipt-configuration`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: receiptConfigurationDTO, signal
    },
      options);
    }
  


export const getValidateReceiptConfigurationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateReceiptConfiguration>>, TError,{data: ReceiptConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof validateReceiptConfiguration>>, TError,{data: ReceiptConfigurationDTO}, TContext> => {

const mutationKey = ['validateReceiptConfiguration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateReceiptConfiguration>>, {data: ReceiptConfigurationDTO}> = (props) => {
          const {data} = props ?? {};

          return  validateReceiptConfiguration(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ValidateReceiptConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof validateReceiptConfiguration>>>
    export type ValidateReceiptConfigurationMutationBody = ReceiptConfigurationDTO
    export type ValidateReceiptConfigurationMutationError = ErrorResponse

    /**
 * @summary 뉋썛혰햢햟혡혰혪 햨쮏쫨혰햡혞햟혡혰혱 햨쒫쟴햟햫혡혰혱
 */
export const useValidateReceiptConfiguration = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateReceiptConfiguration>>, TError,{data: ReceiptConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof validateReceiptConfiguration>>,
        TError,
        {data: ReceiptConfigurationDTO},
        TContext
      > => {

      const mutationOptions = getValidateReceiptConfigurationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋썛혰햢햟혡혰혪 혰햢혝쒫왐햢햤햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const validateOrderConfirmation = (
    orderConfirmationDTO: OrderConfirmationDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidateOrderConfirmation200>(
      {url: `/v1/order-wizard/stage4/validate/order-confirmation`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderConfirmationDTO, signal
    },
      options);
    }
  


export const getValidateOrderConfirmationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateOrderConfirmation>>, TError,{data: OrderConfirmationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof validateOrderConfirmation>>, TError,{data: OrderConfirmationDTO}, TContext> => {

const mutationKey = ['validateOrderConfirmation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateOrderConfirmation>>, {data: OrderConfirmationDTO}> = (props) => {
          const {data} = props ?? {};

          return  validateOrderConfirmation(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ValidateOrderConfirmationMutationResult = NonNullable<Awaited<ReturnType<typeof validateOrderConfirmation>>>
    export type ValidateOrderConfirmationMutationBody = OrderConfirmationDTO
    export type ValidateOrderConfirmationMutationError = ErrorResponse

    /**
 * @summary 뉋썛혰햢햟혡혰혪 혰햢혝쒫왐햢햤햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const useValidateOrderConfirmation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateOrderConfirmation>>, TError,{data: OrderConfirmationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof validateOrderConfirmation>>,
        TError,
        {data: OrderConfirmationDTO},
        TContext
      > => {

      const mutationOptions = getValidateOrderConfirmationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋썛혰햢햟혡혰혪 향햟쒫왐혣햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const validateOrderCompletion = (
    orderCompletionDTO: OrderCompletionDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidateOrderCompletion200>(
      {url: `/v1/order-wizard/stage4/validate/order-completion`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderCompletionDTO, signal
    },
      options);
    }
  


export const getValidateOrderCompletionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateOrderCompletion>>, TError,{data: OrderCompletionDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof validateOrderCompletion>>, TError,{data: OrderCompletionDTO}, TContext> => {

const mutationKey = ['validateOrderCompletion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateOrderCompletion>>, {data: OrderCompletionDTO}> = (props) => {
          const {data} = props ?? {};

          return  validateOrderCompletion(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ValidateOrderCompletionMutationResult = NonNullable<Awaited<ReturnType<typeof validateOrderCompletion>>>
    export type ValidateOrderCompletionMutationBody = OrderCompletionDTO
    export type ValidateOrderCompletionMutationError = ErrorResponse

    /**
 * @summary 뉋썛혰햢햟혡혰혪 향햟쒫왐혣햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const useValidateOrderCompletion = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateOrderCompletion>>, TError,{data: OrderCompletionDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof validateOrderCompletion>>,
        TError,
        {data: OrderCompletionDTO},
        TContext
      > => {

      const mutationOptions = getValidateOrderCompletionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋썛혰햢햟혡혰혪 혩햦햢햦혢햫쮏 햦햧햫혪혝혝혪
 */
export const validateLegalAcceptance = (
    legalAcceptanceDTO: LegalAcceptanceDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidateLegalAcceptance200>(
      {url: `/v1/order-wizard/stage4/validate/legal-acceptance`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: legalAcceptanceDTO, signal
    },
      options);
    }
  


export const getValidateLegalAcceptanceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateLegalAcceptance>>, TError,{data: LegalAcceptanceDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof validateLegalAcceptance>>, TError,{data: LegalAcceptanceDTO}, TContext> => {

const mutationKey = ['validateLegalAcceptance'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateLegalAcceptance>>, {data: LegalAcceptanceDTO}> = (props) => {
          const {data} = props ?? {};

          return  validateLegalAcceptance(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ValidateLegalAcceptanceMutationResult = NonNullable<Awaited<ReturnType<typeof validateLegalAcceptance>>>
    export type ValidateLegalAcceptanceMutationBody = LegalAcceptanceDTO
    export type ValidateLegalAcceptanceMutationError = ErrorResponse

    /**
 * @summary 뉋썛혰햢햟혡혰혪 혩햦햢햦혢햫쮏 햦햧햫혪혝혝혪
 */
export const useValidateLegalAcceptance = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateLegalAcceptance>>, TError,{data: LegalAcceptanceDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof validateLegalAcceptance>>,
        TError,
        {data: LegalAcceptanceDTO},
        TContext
      > => {

      const mutationOptions = getValidateLegalAcceptanceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햠햣햣햤햣햫햫혪 혰햢햦혜혞 햨햩혰혮햫혝햟
 */
export const saveSignature = (
    customerSignatureRequest: CustomerSignatureRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SaveSignature200>(
      {url: `/v1/order-wizard/stage4/signature/save`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: customerSignatureRequest, signal
    },
      options);
    }
  


export const getSaveSignatureMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveSignature>>, TError,{data: CustomerSignatureRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof saveSignature>>, TError,{data: CustomerSignatureRequest}, TContext> => {

const mutationKey = ['saveSignature'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveSignature>>, {data: CustomerSignatureRequest}> = (props) => {
          const {data} = props ?? {};

          return  saveSignature(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SaveSignatureMutationResult = NonNullable<Awaited<ReturnType<typeof saveSignature>>>
    export type SaveSignatureMutationBody = CustomerSignatureRequest
    export type SaveSignatureMutationError = ErrorResponse

    /**
 * @summary 행햠햣햣햤햣햫햫혪 혰햢햦혜혞 햨햩혰혮햫혝햟
 */
export const useSaveSignature = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveSignature>>, TError,{data: CustomerSignatureRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof saveSignature>>,
        TError,
        {data: CustomerSignatureRequest},
        TContext
      > => {

      const mutationOptions = getSaveSignatureMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쫧쮏쒫햣햫햫혪 햨쮏쫨혰햡혞햟혡혰혱 햨쒫쟴햟햫혡혰혱
 */
export const updateReceiptConfiguration = (
    sessionId: string,
    receiptConfigurationDTO: ReceiptConfigurationDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<UpdateReceiptConfiguration200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/receipt-configuration`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: receiptConfigurationDTO, signal
    },
      options);
    }
  


export const getUpdateReceiptConfigurationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateReceiptConfiguration>>, TError,{sessionId: string;data: ReceiptConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateReceiptConfiguration>>, TError,{sessionId: string;data: ReceiptConfigurationDTO}, TContext> => {

const mutationKey = ['updateReceiptConfiguration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateReceiptConfiguration>>, {sessionId: string;data: ReceiptConfigurationDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateReceiptConfiguration(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateReceiptConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof updateReceiptConfiguration>>>
    export type UpdateReceiptConfigurationMutationBody = ReceiptConfigurationDTO
    export type UpdateReceiptConfigurationMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫햣햫햫혪 햨쮏쫨혰햡혞햟혡혰혱 햨쒫쟴햟햫혡혰혱
 */
export const useUpdateReceiptConfiguration = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateReceiptConfiguration>>, TError,{sessionId: string;data: ReceiptConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateReceiptConfiguration>>,
        TError,
        {sessionId: string;data: ReceiptConfigurationDTO},
        TContext
      > => {

      const mutationOptions = getUpdateReceiptConfigurationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쫧쮏쒫햣햫햫혪 혰햢혝쒫왐햢햤햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const updateOrderConfirmation = (
    sessionId: string,
    orderConfirmationDTO: OrderConfirmationDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<UpdateOrderConfirmation200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/order-confirmation`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderConfirmationDTO, signal
    },
      options);
    }
  


export const getUpdateOrderConfirmationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderConfirmation>>, TError,{sessionId: string;data: OrderConfirmationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateOrderConfirmation>>, TError,{sessionId: string;data: OrderConfirmationDTO}, TContext> => {

const mutationKey = ['updateOrderConfirmation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOrderConfirmation>>, {sessionId: string;data: OrderConfirmationDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateOrderConfirmation(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateOrderConfirmationMutationResult = NonNullable<Awaited<ReturnType<typeof updateOrderConfirmation>>>
    export type UpdateOrderConfirmationMutationBody = OrderConfirmationDTO
    export type UpdateOrderConfirmationMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫햣햫햫혪 혰햢혝쒫왐햢햤햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const useUpdateOrderConfirmation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderConfirmation>>, TError,{sessionId: string;data: OrderConfirmationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateOrderConfirmation>>,
        TError,
        {sessionId: string;data: OrderConfirmationDTO},
        TContext
      > => {

      const mutationOptions = getUpdateOrderConfirmationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쫧쮏쒫햣햫햫혪 향햟쒫왐혣햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const updateOrderCompletion1 = (
    sessionId: string,
    orderCompletionDTO: OrderCompletionDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<UpdateOrderCompletion1200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/order-completion`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderCompletionDTO, signal
    },
      options);
    }
  


export const getUpdateOrderCompletion1MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderCompletion1>>, TError,{sessionId: string;data: OrderCompletionDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateOrderCompletion1>>, TError,{sessionId: string;data: OrderCompletionDTO}, TContext> => {

const mutationKey = ['updateOrderCompletion1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOrderCompletion1>>, {sessionId: string;data: OrderCompletionDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateOrderCompletion1(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateOrderCompletion1MutationResult = NonNullable<Awaited<ReturnType<typeof updateOrderCompletion1>>>
    export type UpdateOrderCompletion1MutationBody = OrderCompletionDTO
    export type UpdateOrderCompletion1MutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫햣햫햫혪 향햟쒫왐혣햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const useUpdateOrderCompletion1 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderCompletion1>>, TError,{sessionId: string;data: OrderCompletionDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateOrderCompletion1>>,
        TError,
        {sessionId: string;data: OrderCompletionDTO},
        TContext
      > => {

      const mutationOptions = getUpdateOrderCompletion1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쫧쮏쒫햣햫햫혪 혩햦햢햦혢햫쮏 햦햧햫혪혝혝혪
 */
export const updateLegalAcceptance = (
    sessionId: string,
    legalAcceptanceDTO: LegalAcceptanceDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<UpdateLegalAcceptance200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/legal-acceptance`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: legalAcceptanceDTO, signal
    },
      options);
    }
  


export const getUpdateLegalAcceptanceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateLegalAcceptance>>, TError,{sessionId: string;data: LegalAcceptanceDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateLegalAcceptance>>, TError,{sessionId: string;data: LegalAcceptanceDTO}, TContext> => {

const mutationKey = ['updateLegalAcceptance'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateLegalAcceptance>>, {sessionId: string;data: LegalAcceptanceDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateLegalAcceptance(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateLegalAcceptanceMutationResult = NonNullable<Awaited<ReturnType<typeof updateLegalAcceptance>>>
    export type UpdateLegalAcceptanceMutationBody = LegalAcceptanceDTO
    export type UpdateLegalAcceptanceMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫햣햫햫혪 혩햦햢햦혢햫쮏 햦햧햫혪혝혝혪
 */
export const useUpdateLegalAcceptance = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateLegalAcceptance>>, TError,{sessionId: string;data: LegalAcceptanceDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateLegalAcceptance>>,
        TError,
        {sessionId: string;data: LegalAcceptanceDTO},
        TContext
      > => {

      const mutationOptions = getUpdateLegalAcceptanceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟햨햦혝혝혪 혜햣혜혰혱
 */
export const closeSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CloseSession200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/close`, method: 'POST', signal
    },
      options);
    }
  


export const getCloseSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof closeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof closeSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['closeSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof closeSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  closeSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CloseSessionMutationResult = NonNullable<Awaited<ReturnType<typeof closeSession>>>
    
    export type CloseSessionMutationError = ErrorResponse

    /**
 * @summary 행햟햨햦혝혝혪 혜햣혜혰혱
 */
export const useCloseSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof closeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof closeSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCloseSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햅햣햫햣햟혡혰혪 햨쒫쟴햟햫혡혰혱
 */
export const generateReceipt = (
    receiptGenerationRequest: ReceiptGenerationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GenerateReceipt200>(
      {url: `/v1/order-wizard/stage4/receipt/generate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: receiptGenerationRequest, signal
    },
      options);
    }
  


export const getGenerateReceiptMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof generateReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext> => {

const mutationKey = ['generateReceipt'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateReceipt>>, {data: ReceiptGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  generateReceipt(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof generateReceipt>>>
    export type GenerateReceiptMutationBody = ReceiptGenerationRequest
    export type GenerateReceiptMutationError = ErrorResponse

    /**
 * @summary 햅햣햫햣햟혡혰혪 햨쒫쟴햟햫혡혰혱
 */
export const useGenerateReceipt = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateReceipt>>,
        TError,
        {data: ReceiptGenerationRequest},
        TContext
      > => {

      const mutationOptions = getGenerateReceiptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햅햣햫햣햟혡혰혪 PDF 햨쒫쟴햟햫혡혰혱
 */
export const generatePdfReceipt = (
    receiptGenerationRequest: ReceiptGenerationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GeneratePdfReceipt200>(
      {url: `/v1/order-wizard/stage4/receipt/generate-pdf`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: receiptGenerationRequest, signal
    },
      options);
    }
  


export const getGeneratePdfReceiptMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePdfReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof generatePdfReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext> => {

const mutationKey = ['generatePdfReceipt'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generatePdfReceipt>>, {data: ReceiptGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  generatePdfReceipt(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GeneratePdfReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof generatePdfReceipt>>>
    export type GeneratePdfReceiptMutationBody = ReceiptGenerationRequest
    export type GeneratePdfReceiptMutationError = ErrorResponse

    /**
 * @summary 햅햣햫햣햟혡혰혪 PDF 햨쒫쟴햟햫혡혰혱
 */
export const useGeneratePdfReceipt = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePdfReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generatePdfReceipt>>,
        TError,
        {data: ReceiptGenerationRequest},
        TContext
      > => {

      const mutationOptions = getGeneratePdfReceiptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 핹햫혰혡혰햟햩혰향햟혡혰혪 Stage4 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */
export const initializeStage4 = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<InitializeStage4200>(
      {url: `/v1/order-wizard/stage4/initialize/${orderId}`, method: 'POST', signal
    },
      options);
    }
  


export const getInitializeStage4MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeStage4>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof initializeStage4>>, TError,{orderId: string}, TContext> => {

const mutationKey = ['initializeStage4'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeStage4>>, {orderId: string}> = (props) => {
          const {orderId} = props ?? {};

          return  initializeStage4(orderId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeStage4MutationResult = NonNullable<Awaited<ReturnType<typeof initializeStage4>>>
    
    export type InitializeStage4MutationError = ErrorResponse

    /**
 * @summary 핹햫혰혡혰햟햩혰향햟혡혰혪 Stage4 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */
export const useInitializeStage4 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeStage4>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initializeStage4>>,
        TError,
        {orderId: string},
        TContext
      > => {

      const mutationOptions = getInitializeStage4MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햓혰햫햟햩혰향햟혡혰혪 향햟햪쮏쒫햣햫햫혪
 */
export const finalizeOrder = (
    orderFinalizationRequest: OrderFinalizationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<FinalizeOrder200>(
      {url: `/v1/order-wizard/stage4/finalize`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderFinalizationRequest, signal
    },
      options);
    }
  


export const getFinalizeOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalizeOrder>>, TError,{data: OrderFinalizationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof finalizeOrder>>, TError,{data: OrderFinalizationRequest}, TContext> => {

const mutationKey = ['finalizeOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalizeOrder>>, {data: OrderFinalizationRequest}> = (props) => {
          const {data} = props ?? {};

          return  finalizeOrder(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalizeOrderMutationResult = NonNullable<Awaited<ReturnType<typeof finalizeOrder>>>
    export type FinalizeOrderMutationBody = OrderFinalizationRequest
    export type FinalizeOrderMutationError = ErrorResponse

    /**
 * @summary 햓혰햫햟햩혰향햟혡혰혪 향햟햪쮏쒫햣햫햫혪
 */
export const useFinalizeOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalizeOrder>>, TError,{data: OrderFinalizationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof finalizeOrder>>,
        TError,
        {data: OrderFinalizationRequest},
        TContext
      > => {

      const mutationOptions = getFinalizeOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒬 혜햣혜혰혩 Stage3
 */
export const createSession = (
    createSessionBody: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage3/sessions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSessionBody, signal
    },
      options);
    }
  


export const getCreateSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: string}, TContext> => {

const mutationKey = ['createSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSession>>, {data: string}> = (props) => {
          const {data} = props ?? {};

          return  createSession(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof createSession>>>
    export type CreateSessionMutationBody = string
    export type CreateSessionMutationError = ErrorResponse

    /**
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒬 혜햣혜혰혩 Stage3
 */
export const useCreateSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSession>>,
        TError,
        {data: string},
        TContext
      > => {

      const mutationOptions = getCreateSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 핹햫혰혡혰햟햩혰향혞쒫썜햦 Stage3 햢햩혪 혜햣혜혰혱
 */
export const initializeStage3 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/initialize`, method: 'POST', signal
    },
      options);
    }
  


export const getInitializeStage3MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeStage3>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof initializeStage3>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['initializeStage3'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeStage3>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  initializeStage3(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeStage3MutationResult = NonNullable<Awaited<ReturnType<typeof initializeStage3>>>
    
    export type InitializeStage3MutationError = ErrorResponse

    /**
 * @summary 핹햫혰혡혰햟햩혰향혞쒫썜햦 Stage3 햢햩혪 혜햣혜혰혱
 */
export const useInitializeStage3 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeStage3>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initializeStage3>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getInitializeStage3MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟햨햦혝햦 혜햣혜혰혩
 */
export const closeSession1 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/close`, method: 'POST', signal
    },
      options);
    }
  


export const getCloseSession1MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof closeSession1>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof closeSession1>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['closeSession1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof closeSession1>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  closeSession1(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CloseSession1MutationResult = NonNullable<Awaited<ReturnType<typeof closeSession1>>>
    
    export type CloseSession1MutationError = ErrorResponse

    /**
 * @summary 행햟햨햦혝햦 혜햣혜혰혩
 */
export const useCloseSession1 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof closeSession1>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof closeSession1>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCloseSession1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟혞혜햨햟혮 햫쮏쒫쟳 혰햢쒬뒗햟햢 햢쮏얧썛쒫썛쫧쫨 햣햢햪햣혝햟
 */
export const startNewItemWizard = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/wizard/new/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getStartNewItemWizardMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startNewItemWizard>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof startNewItemWizard>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['startNewItemWizard'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startNewItemWizard>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  startNewItemWizard(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartNewItemWizardMutationResult = NonNullable<Awaited<ReturnType<typeof startNewItemWizard>>>
    
    export type StartNewItemWizardMutationError = ErrorResponse

    /**
 * @summary 행햟혞혜햨햟혮 햫쮏쒫쟳 혰햢쒬뒗햟햢 햢쮏얧썛쒫썛쫧쫨 햣햢햪햣혝햟
 */
export const useStartNewItemWizard = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startNewItemWizard>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startNewItemWizard>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStartNewItemWizardMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟혞혜햨햟혮 혰햢쒬뒗햟햢 햣햢햟햡혞쒫썛쫧쫨 혰혜햫혞혩혢쮏 햣햢햪햣혝햟
 */
export const startEditItemWizard = (
    sessionId: string,
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/wizard/edit/${sessionId}/${itemId}`, method: 'POST', signal
    },
      options);
    }
  


export const getStartEditItemWizardMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startEditItemWizard>>, TError,{sessionId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof startEditItemWizard>>, TError,{sessionId: string;itemId: string}, TContext> => {

const mutationKey = ['startEditItemWizard'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startEditItemWizard>>, {sessionId: string;itemId: string}> = (props) => {
          const {sessionId,itemId} = props ?? {};

          return  startEditItemWizard(sessionId,itemId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartEditItemWizardMutationResult = NonNullable<Awaited<ReturnType<typeof startEditItemWizard>>>
    
    export type StartEditItemWizardMutationError = ErrorResponse

    /**
 * @summary 행햟혞혜햨햟혮 혰햢쒬뒗햟햢 햣햢햟햡혞쒫썛쫧쫨 혰혜햫혞혩혢쮏 햣햢햪햣혝햟
 */
export const useStartEditItemWizard = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startEditItemWizard>>, TError,{sessionId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startEditItemWizard>>,
        TError,
        {sessionId: string;itemId: string},
        TContext
      > => {

      const mutationOptions = getStartEditItemWizardMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟햨햦쒫썜 햟햨혝햦쒫쫧쟳 혰햢쒬뒗햟햢 햠햣향 향햠햣햣햤햣햫햫혪
 */
export const closeWizard = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/wizard/close/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getCloseWizardMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof closeWizard>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof closeWizard>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['closeWizard'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof closeWizard>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  closeWizard(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CloseWizardMutationResult = NonNullable<Awaited<ReturnType<typeof closeWizard>>>
    
    export type CloseWizardMutationError = ErrorResponse

    /**
 * @summary 행햟햨햦쒫썜 햟햨혝햦쒫쫧쟳 혰햢쒬뒗햟햢 햠햣향 향햠햣햣햤햣햫햫혪
 */
export const useCloseWizard = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof closeWizard>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof closeWizard>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCloseWizardMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐햦햫혠쮏쫨뒗혞혮 혜혝햟햫 햪햣햫햣햢햤햣햟
 */
export const synchronizeManager = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/synchronize/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSynchronizeManagerMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof synchronizeManager>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof synchronizeManager>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['synchronizeManager'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof synchronizeManager>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  synchronizeManager(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SynchronizeManagerMutationResult = NonNullable<Awaited<ReturnType<typeof synchronizeManager>>>
    
    export type SynchronizeManagerMutationError = ErrorResponse

    /**
 * @summary 햐햦햫혠쮏쫨뒗혞혮 혜혝햟햫 햪햣햫햣햢햤햣햟
 */
export const useSynchronizeManager = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof synchronizeManager>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof synchronizeManager>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSynchronizeManagerMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햆쮏얧썛쒫썛쫧쫨 혟쮐쮏햟혟혰혱
 */
export const addPhoto = (
    sessionId: string,
    addPhotoBody: AddPhotoBody,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}/photos`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addPhotoBody, signal
    },
      options);
    }
  


export const getAddPhotoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPhoto>>, TError,{sessionId: string;data: AddPhotoBody}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof addPhoto>>, TError,{sessionId: string;data: AddPhotoBody}, TContext> => {

const mutationKey = ['addPhoto'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPhoto>>, {sessionId: string;data: AddPhotoBody}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  addPhoto(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddPhotoMutationResult = NonNullable<Awaited<ReturnType<typeof addPhoto>>>
    export type AddPhotoMutationBody = AddPhotoBody
    export type AddPhotoMutationError = ErrorResponse

    /**
 * @summary 햆쮏얧썛쒫썛쫧쫨 혟쮐쮏햟혟혰혱
 */
export const useAddPhoto = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPhoto>>, TError,{sessionId: string;data: AddPhotoBody}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addPhoto>>,
        TError,
        {sessionId: string;data: AddPhotoBody},
        TContext
      > => {

      const mutationOptions = getAddPhotoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟쒫왐혣햣햫햫혪 혟쮐쮏얧쮏쥄햪햣햫혝햟혡혰혱
 */
export const completePhotoDocumentation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getCompletePhotoDocumentationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completePhotoDocumentation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof completePhotoDocumentation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['completePhotoDocumentation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completePhotoDocumentation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  completePhotoDocumentation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompletePhotoDocumentationMutationResult = NonNullable<Awaited<ReturnType<typeof completePhotoDocumentation>>>
    
    export type CompletePhotoDocumentationMutationError = ErrorResponse

    /**
 * @summary 행햟쒫왐혣햣햫햫혪 혟쮐쮏얧쮏쥄햪햣햫혝햟혡혰혱
 */
export const useCompletePhotoDocumentation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completePhotoDocumentation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completePhotoDocumentation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCompletePhotoDocumentationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 핹햫혰혡혰햟햩혰향햟혡혰혪 혰햢햣혝햟혞 5 - 햓쮐쮏얧쮏쥄햪햣햫혝햟혡혰혪
 */
export const initializeSubstep5 = (
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep5/initialize/${itemId}`, method: 'POST', signal
    },
      options);
    }
  


export const getInitializeSubstep5MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep5>>, TError,{itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep5>>, TError,{itemId: string}, TContext> => {

const mutationKey = ['initializeSubstep5'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeSubstep5>>, {itemId: string}> = (props) => {
          const {itemId} = props ?? {};

          return  initializeSubstep5(itemId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeSubstep5MutationResult = NonNullable<Awaited<ReturnType<typeof initializeSubstep5>>>
    
    export type InitializeSubstep5MutationError = ErrorResponse

    /**
 * @summary 핹햫혰혡혰햟햩혰향햟혡혰혪 혰햢햣혝햟혞 5 - 햓쮐쮏얧쮏쥄햪햣햫혝햟혡혰혪
 */
export const useInitializeSubstep5 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep5>>, TError,{itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initializeSubstep5>>,
        TError,
        {itemId: string},
        TContext
      > => {

      const mutationOptions = getInitializeSubstep5MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐햨햦햢햟햫햫혪 쮏햟혠혞햫햨혞
 */
export const resetCalculation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/reset/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getResetCalculationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof resetCalculation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['resetCalculation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetCalculation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  resetCalculation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetCalculationMutationResult = NonNullable<Awaited<ReturnType<typeof resetCalculation>>>
    
    export type ResetCalculationMutationError = ErrorResponse

    /**
 * @summary 햐햨햦햢햟햫햫혪 쮏햟혠혞햫햨혞
 */
export const useResetCalculation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetCalculation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getResetCalculationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햆쮏얧썛쒫썛쫧쫨 햪쮏얧쟴혰햨햟혝쮐햟 햢 쮏햟혠혞햫햨혞
 */
export const addModifier = (
    sessionId: string,
    addModifierRequest: AddModifierRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers/${sessionId}/add`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addModifierRequest, signal
    },
      options);
    }
  


export const getAddModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addModifier>>, TError,{sessionId: string;data: AddModifierRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof addModifier>>, TError,{sessionId: string;data: AddModifierRequest}, TContext> => {

const mutationKey = ['addModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addModifier>>, {sessionId: string;data: AddModifierRequest}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  addModifier(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddModifierMutationResult = NonNullable<Awaited<ReturnType<typeof addModifier>>>
    export type AddModifierMutationBody = AddModifierRequest
    export type AddModifierMutationError = ErrorResponse

    /**
 * @summary 햆쮏얧썛쒫썛쫧쫨 햪쮏얧쟴혰햨햟혝쮐햟 햢 쮏햟혠혞햫햨혞
 */
export const useAddModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addModifier>>, TError,{sessionId: string;data: AddModifierRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addModifier>>,
        TError,
        {sessionId: string;data: AddModifierRequest},
        TContext
      > => {

      const mutationOptions = getAddModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 핹햫혰혡혰햟햩혰향햟혡혰혪 혰햢햣혝햟혞 4
 */
export const initializeSubstep4 = (
    sessionId: string,
    initializeSubstepRequest: InitializeSubstepRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/initialize/${sessionId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: initializeSubstepRequest, signal
    },
      options);
    }
  


export const getInitializeSubstep4MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep4>>, TError,{sessionId: string;data: InitializeSubstepRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep4>>, TError,{sessionId: string;data: InitializeSubstepRequest}, TContext> => {

const mutationKey = ['initializeSubstep4'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeSubstep4>>, {sessionId: string;data: InitializeSubstepRequest}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  initializeSubstep4(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeSubstep4MutationResult = NonNullable<Awaited<ReturnType<typeof initializeSubstep4>>>
    export type InitializeSubstep4MutationBody = InitializeSubstepRequest
    export type InitializeSubstep4MutationError = ErrorResponse

    /**
 * @summary 핹햫혰혡혰햟햩혰향햟혡혰혪 혰햢햣혝햟혞 4
 */
export const useInitializeSubstep4 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep4>>, TError,{sessionId: string;data: InitializeSubstepRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initializeSubstep4>>,
        TError,
        {sessionId: string;data: InitializeSubstepRequest},
        TContext
      > => {

      const mutationOptions = getInitializeSubstep4MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 혰햢혝쒫왐햢햤햣햫햫혪 쮏햟혠혞햫햨혞 혝햟 향햟쒫왐혣햣햫햫혪 혰햢햣혝햟혞
 */
export const confirmCalculation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/confirm/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getConfirmCalculationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof confirmCalculation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['confirmCalculation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof confirmCalculation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  confirmCalculation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConfirmCalculationMutationResult = NonNullable<Awaited<ReturnType<typeof confirmCalculation>>>
    
    export type ConfirmCalculationMutationError = ErrorResponse

    /**
 * @summary 혰햢혝쒫왐햢햤햣햫햫혪 쮏햟혠혞햫햨혞 혝햟 향햟쒫왐혣햣햫햫혪 혰햢햣혝햟혞
 */
export const useConfirmCalculation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof confirmCalculation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getConfirmCalculationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 먫쮏햟혠혞햫쮏 혡혰햫햦
 */
export const calculatePrice = (
    priceDiscountDTO: PriceDiscountDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceCalculationResponseDTO>(
      {url: `/v1/order-wizard/stage2/substep4/calculate-price`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: priceDiscountDTO, signal
    },
      options);
    }
  


export const getCalculatePriceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculatePrice>>, TError,{data: PriceDiscountDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof calculatePrice>>, TError,{data: PriceDiscountDTO}, TContext> => {

const mutationKey = ['calculatePrice'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculatePrice>>, {data: PriceDiscountDTO}> = (props) => {
          const {data} = props ?? {};

          return  calculatePrice(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalculatePriceMutationResult = NonNullable<Awaited<ReturnType<typeof calculatePrice>>>
    export type CalculatePriceMutationBody = PriceDiscountDTO
    export type CalculatePriceMutationError = ErrorResponse

    /**
 * @summary 먫쮏햟혠혞햫쮏 혡혰햫햦
 */
export const useCalculatePrice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculatePrice>>, TError,{data: PriceDiscountDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof calculatePrice>>,
        TError,
        {data: PriceDiscountDTO},
        TContext
      > => {

      const mutationOptions = getCalculatePriceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 먫쮏햟혠혞햫쮏 혟혰햫햟햩혧햫쮐 혡혰햫햦 향 혞혜혰햪햟 햪쮏얧쟴혰햨햟혝쮐햟햪햦
 */
export const calculateFinalPrice = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/calculate-final-price/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getCalculateFinalPriceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateFinalPrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof calculateFinalPrice>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['calculateFinalPrice'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateFinalPrice>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  calculateFinalPrice(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalculateFinalPriceMutationResult = NonNullable<Awaited<ReturnType<typeof calculateFinalPrice>>>
    
    export type CalculateFinalPriceMutationError = ErrorResponse

    /**
 * @summary 먫쮏햟혠혞햫쮏 혟혰햫햟햩혧햫쮐 혡혰햫햦 향 혞혜혰햪햟 햪쮏얧쟴혰햨햟혝쮐햟햪햦
 */
export const useCalculateFinalPrice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateFinalPrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof calculateFinalPrice>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCalculateFinalPriceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 먫쮏햟혠혞햫쮏 햠햟향쮏쒫쮐 혡혰햫햦 햣햢햪햣혝햟
 */
export const calculateBasePrice = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/calculate-base-price/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getCalculateBasePriceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateBasePrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof calculateBasePrice>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['calculateBasePrice'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateBasePrice>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  calculateBasePrice(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalculateBasePriceMutationResult = NonNullable<Awaited<ReturnType<typeof calculateBasePrice>>>
    
    export type CalculateBasePriceMutationError = ErrorResponse

    /**
 * @summary 먫쮏햟혠혞햫쮏 햠햟향쮏쒫쮐 혡혰햫햦 햣햢햪햣혝햟
 */
export const useCalculateBasePrice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateBasePrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof calculateBasePrice>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCalculateBasePriceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쐄쮏쐃쥃 쒫쟳쐃쮐혞 햩혪햪
 */
export const processStainSelection = (
    sessionId: string,
    params?: ProcessStainSelectionParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/stains/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getProcessStainSelectionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processStainSelection>>, TError,{sessionId: string;params?: ProcessStainSelectionParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof processStainSelection>>, TError,{sessionId: string;params?: ProcessStainSelectionParams}, TContext> => {

const mutationKey = ['processStainSelection'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processStainSelection>>, {sessionId: string;params?: ProcessStainSelectionParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  processStainSelection(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessStainSelectionMutationResult = NonNullable<Awaited<ReturnType<typeof processStainSelection>>>
    
    export type ProcessStainSelectionMutationError = ErrorResponse

    /**
 * @summary 뤯쐄쮏쐃쥃 쒫쟳쐃쮐혞 햩혪햪
 */
export const useProcessStainSelection = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processStainSelection>>, TError,{sessionId: string;params?: ProcessStainSelectionParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof processStainSelection>>,
        TError,
        {sessionId: string;params?: ProcessStainSelectionParams},
        TContext
      > => {

      const mutationOptions = getProcessStainSelectionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쐄쮏쐃쥃 햢쮏얧썛쒫썛쫧쫨 햦햪혰혝쮏  햢햣혟햣햨혝햦
 */
export const processDefectNotes = (
    sessionId: string,
    params?: ProcessDefectNotesParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/notes/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getProcessDefectNotesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processDefectNotes>>, TError,{sessionId: string;params?: ProcessDefectNotesParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof processDefectNotes>>, TError,{sessionId: string;params?: ProcessDefectNotesParams}, TContext> => {

const mutationKey = ['processDefectNotes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processDefectNotes>>, {sessionId: string;params?: ProcessDefectNotesParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  processDefectNotes(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessDefectNotesMutationResult = NonNullable<Awaited<ReturnType<typeof processDefectNotes>>>
    
    export type ProcessDefectNotesMutationError = ErrorResponse

    /**
 * @summary 뤯쐄쮏쐃쥃 햢쮏얧썛쒫썛쫧쫨 햦햪혰혝쮏  햢햣혟햣햨혝햦
 */
export const useProcessDefectNotes = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processDefectNotes>>, TError,{sessionId: string;params?: ProcessDefectNotesParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof processDefectNotes>>,
        TError,
        {sessionId: string;params?: ProcessDefectNotesParams},
        TContext
      > => {

      const mutationOptions = getProcessDefectNotesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 핹햫혰혡혰햟햩혰향햟혡혰혪 혰햢햣혝햟혞 3
 */
export const initializeSubstep3 = (
    sessionId: string,
    orderItemAddRequest: OrderItemAddRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/initialize/${sessionId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderItemAddRequest, signal
    },
      options);
    }
  


export const getInitializeSubstep3MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep3>>, TError,{sessionId: string;data: OrderItemAddRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep3>>, TError,{sessionId: string;data: OrderItemAddRequest}, TContext> => {

const mutationKey = ['initializeSubstep3'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeSubstep3>>, {sessionId: string;data: OrderItemAddRequest}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  initializeSubstep3(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeSubstep3MutationResult = NonNullable<Awaited<ReturnType<typeof initializeSubstep3>>>
    export type InitializeSubstep3MutationBody = OrderItemAddRequest
    export type InitializeSubstep3MutationError = ErrorResponse

    /**
 * @summary 핹햫혰혡혰햟햩혰향햟혡혰혪 혰햢햣혝햟혞 3
 */
export const useInitializeSubstep3 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep3>>, TError,{sessionId: string;data: OrderItemAddRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initializeSubstep3>>,
        TError,
        {sessionId: string;data: OrderItemAddRequest},
        TContext
      > => {

      const mutationOptions = getInitializeSubstep3MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 쮏쒫왐햫햣햫햫혪 햢 쮏햣햣햢햫혧쮏 혜혝햟햫혞
 */
export const goBack = (
    sessionId: string,
    params: GoBackParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/go-back/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getGoBackMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof goBack>>, TError,{sessionId: string;params: GoBackParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof goBack>>, TError,{sessionId: string;params: GoBackParams}, TContext> => {

const mutationKey = ['goBack'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof goBack>>, {sessionId: string;params: GoBackParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  goBack(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GoBackMutationResult = NonNullable<Awaited<ReturnType<typeof goBack>>>
    
    export type GoBackMutationError = ErrorResponse

    /**
 * @summary 쮏쒫왐햫햣햫햫혪 햢 쮏햣햣햢햫혧쮏 혜혝햟햫혞
 */
export const useGoBack = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof goBack>>, TError,{sessionId: string;params: GoBackParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof goBack>>,
        TError,
        {sessionId: string;params: GoBackParams},
        TContext
      > => {

      const mutationOptions = getGoBackMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤯쐄쮏쐃쥃 쒫쟳쐃쮐혞 햢햣혟햣햨혝혰 혝햟 햦향햦햨혰
 */
export const processDefectSelection = (
    sessionId: string,
    params?: ProcessDefectSelectionParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/defects/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getProcessDefectSelectionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processDefectSelection>>, TError,{sessionId: string;params?: ProcessDefectSelectionParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof processDefectSelection>>, TError,{sessionId: string;params?: ProcessDefectSelectionParams}, TContext> => {

const mutationKey = ['processDefectSelection'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processDefectSelection>>, {sessionId: string;params?: ProcessDefectSelectionParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  processDefectSelection(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessDefectSelectionMutationResult = NonNullable<Awaited<ReturnType<typeof processDefectSelection>>>
    
    export type ProcessDefectSelectionMutationError = ErrorResponse

    /**
 * @summary 뤯쐄쮏쐃쥃 쒫쟳쐃쮐혞 햢햣혟햣햨혝혰 혝햟 햦향햦햨혰
 */
export const useProcessDefectSelection = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processDefectSelection>>, TError,{sessionId: string;params?: ProcessDefectSelectionParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof processDefectSelection>>,
        TError,
        {sessionId: string;params?: ProcessDefectSelectionParams},
        TContext
      > => {

      const mutationOptions = getProcessDefectSelectionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟쒫왐혣햣햫햫혪 혰햢햣혝햟혞 3
 */
export const completeSubstep3 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/complete/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getCompleteSubstep3MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeSubstep3>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof completeSubstep3>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['completeSubstep3'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeSubstep3>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  completeSubstep3(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteSubstep3MutationResult = NonNullable<Awaited<ReturnType<typeof completeSubstep3>>>
    
    export type CompleteSubstep3MutationError = ErrorResponse

    /**
 * @summary 행햟쒫왐혣햣햫햫혪 혰햢햣혝햟혞 3
 */
export const useCompleteSubstep3 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeSubstep3>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeSubstep3>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCompleteSubstep3MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋썛혰햢혞혮 쒬혰 쒫쟳쐄햟햫혰 혠햟햟햨혝햣햦혜혝햦햨햦
 */
export const validateCharacteristics = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/substep2/validate/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getValidateCharacteristicsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateCharacteristics>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof validateCharacteristics>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['validateCharacteristics'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateCharacteristics>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  validateCharacteristics(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ValidateCharacteristicsMutationResult = NonNullable<Awaited<ReturnType<typeof validateCharacteristics>>>
    
    export type ValidateCharacteristicsMutationError = ErrorResponse

    /**
 * @summary 뉋썛혰햢혞혮 쒬혰 쒫쟳쐄햟햫혰 혠햟햟햨혝햣햦혜혝햦햨햦
 */
export const useValidateCharacteristics = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateCharacteristics>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof validateCharacteristics>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getValidateCharacteristicsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳쐃쟴햟혮 혜혝혞혰햫혧 향햫쮐혞
 */
export const selectWearLevel = (
    sessionId: string,
    params: SelectWearLevelParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/substep2/select-wear-level/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSelectWearLevelMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectWearLevel>>, TError,{sessionId: string;params: SelectWearLevelParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof selectWearLevel>>, TError,{sessionId: string;params: SelectWearLevelParams}, TContext> => {

const mutationKey = ['selectWearLevel'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof selectWearLevel>>, {sessionId: string;params: SelectWearLevelParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  selectWearLevel(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SelectWearLevelMutationResult = NonNullable<Awaited<ReturnType<typeof selectWearLevel>>>
    
    export type SelectWearLevelMutationError = ErrorResponse

    /**
 * @summary 뉋쟳쐃쟴햟혮 혜혝혞혰햫혧 향햫쮐혞
 */
export const useSelectWearLevel = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectWearLevel>>, TError,{sessionId: string;params: SelectWearLevelParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof selectWearLevel>>,
        TError,
        {sessionId: string;params: SelectWearLevelParams},
        TContext
      > => {

      const mutationOptions = getSelectWearLevelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳쐃쟴햟혮 햪햟혝햣혰햟햩 햣햢햪햣혝햟
 */
export const selectMaterial = (
    sessionId: string,
    params: SelectMaterialParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/substep2/select-material/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSelectMaterialMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectMaterial>>, TError,{sessionId: string;params: SelectMaterialParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof selectMaterial>>, TError,{sessionId: string;params: SelectMaterialParams}, TContext> => {

const mutationKey = ['selectMaterial'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof selectMaterial>>, {sessionId: string;params: SelectMaterialParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  selectMaterial(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SelectMaterialMutationResult = NonNullable<Awaited<ReturnType<typeof selectMaterial>>>
    
    export type SelectMaterialMutationError = ErrorResponse

    /**
 * @summary 뉋쟳쐃쟴햟혮 햪햟혝햣혰햟햩 햣햢햪햣혝햟
 */
export const useSelectMaterial = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectMaterial>>, TError,{sessionId: string;params: SelectMaterialParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof selectMaterial>>,
        TError,
        {sessionId: string;params: SelectMaterialParams},
        TContext
      > => {

      const mutationOptions = getSelectMaterialMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳쐃쟴햟혮 햫햟쮏쒫쫨꿿쒫썜
 */
export const selectFiller = (
    sessionId: string,
    params?: SelectFillerParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/substep2/select-filler/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSelectFillerMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectFiller>>, TError,{sessionId: string;params?: SelectFillerParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof selectFiller>>, TError,{sessionId: string;params?: SelectFillerParams}, TContext> => {

const mutationKey = ['selectFiller'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof selectFiller>>, {sessionId: string;params?: SelectFillerParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  selectFiller(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SelectFillerMutationResult = NonNullable<Awaited<ReturnType<typeof selectFiller>>>
    
    export type SelectFillerMutationError = ErrorResponse

    /**
 * @summary 뉋쟳쐃쟴햟혮 햫햟쮏쒫쫨꿿쒫썜
 */
export const useSelectFiller = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectFiller>>, TError,{sessionId: string;params?: SelectFillerParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof selectFiller>>,
        TError,
        {sessionId: string;params?: SelectFillerParams},
        TContext
      > => {

      const mutationOptions = getSelectFillerMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳쐃쟴햟혮 햨쮏혰 햣햢햪햣혝햟
 */
export const selectColor = (
    sessionId: string,
    params: SelectColorParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/substep2/select-color/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSelectColorMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectColor>>, TError,{sessionId: string;params: SelectColorParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof selectColor>>, TError,{sessionId: string;params: SelectColorParams}, TContext> => {

const mutationKey = ['selectColor'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof selectColor>>, {sessionId: string;params: SelectColorParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  selectColor(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SelectColorMutationResult = NonNullable<Awaited<ReturnType<typeof selectColor>>>
    
    export type SelectColorMutationError = ErrorResponse

    /**
 * @summary 뉋쟳쐃쟴햟혮 햨쮏혰 햣햢햪햣혝햟
 */
export const useSelectColor = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectColor>>, TError,{sessionId: string;params: SelectColorParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof selectColor>>,
        TError,
        {sessionId: string;params: SelectColorParams},
        TContext
      > => {

      const mutationOptions = getSelectColorMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 핹햫혰혡혰햟햩혰향혞혮 혰햢햣혝햟 2 - 햔햟햟햨혝햣햦혜혝햦햨햦
 */
export const initializeSubstep2 = (
    sessionId: string,
    params: InitializeSubstep2Params,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemCharacteristicsDTO>(
      {url: `/v1/order-wizard/stage2/substep2/initialize/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getInitializeSubstep2MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep2>>, TError,{sessionId: string;params: InitializeSubstep2Params}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep2>>, TError,{sessionId: string;params: InitializeSubstep2Params}, TContext> => {

const mutationKey = ['initializeSubstep2'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeSubstep2>>, {sessionId: string;params: InitializeSubstep2Params}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  initializeSubstep2(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeSubstep2MutationResult = NonNullable<Awaited<ReturnType<typeof initializeSubstep2>>>
    
    export type InitializeSubstep2MutationError = ErrorResponse

    /**
 * @summary 핹햫혰혡혰햟햩혰향혞혮 혰햢햣혝햟 2 - 햔햟햟햨혝햣햦혜혝햦햨햦
 */
export const useInitializeSubstep2 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSubstep2>>, TError,{sessionId: string;params: InitializeSubstep2Params}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initializeSubstep2>>,
        TError,
        {sessionId: string;params: InitializeSubstep2Params},
        TContext
      > => {

      const mutationOptions = getInitializeSubstep2MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟쒫왐혣혞혮 혰햢햣혝햟 2
 */
export const completeSubstep2 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CompleteSubstep2200>(
      {url: `/v1/order-wizard/stage2/substep2/complete/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getCompleteSubstep2MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeSubstep2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof completeSubstep2>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['completeSubstep2'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeSubstep2>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  completeSubstep2(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteSubstep2MutationResult = NonNullable<Awaited<ReturnType<typeof completeSubstep2>>>
    
    export type CompleteSubstep2MutationError = ErrorResponse

    /**
 * @summary 행햟쒫왐혣혞혮 혰햢햣혝햟 2
 */
export const useCompleteSubstep2 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeSubstep2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeSubstep2>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCompleteSubstep2MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐햨햟혜쮏쒬혮 혰햢햣혝햟 2
 */
export const cancelSubstep2 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/substep2/cancel/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getCancelSubstep2MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelSubstep2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelSubstep2>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['cancelSubstep2'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelSubstep2>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  cancelSubstep2(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelSubstep2MutationResult = NonNullable<Awaited<ReturnType<typeof cancelSubstep2>>>
    
    export type CancelSubstep2MutationError = ErrorResponse

    /**
 * @summary 햐햨햟혜쮏쒬혮 혰햢햣혝햟 2
 */
export const useCancelSubstep2 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelSubstep2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelSubstep2>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCancelSubstep2MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋썛혰햢혞혮 혝햟 향햟쒫왐혣혞혮 혰햢햣혝햟 1
 */
export const validateAndCompleteSubstep1 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/validate-and-complete`, method: 'POST', signal
    },
      options);
    }
  


export const getValidateAndCompleteSubstep1MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateAndCompleteSubstep1>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof validateAndCompleteSubstep1>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['validateAndCompleteSubstep1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateAndCompleteSubstep1>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  validateAndCompleteSubstep1(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ValidateAndCompleteSubstep1MutationResult = NonNullable<Awaited<ReturnType<typeof validateAndCompleteSubstep1>>>
    
    export type ValidateAndCompleteSubstep1MutationError = ErrorResponse

    /**
 * @summary 뉋썛혰햢혞혮 혝햟 향햟쒫왐혣혞혮 혰햢햣혝햟 1
 */
export const useValidateAndCompleteSubstep1 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateAndCompleteSubstep1>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof validateAndCompleteSubstep1>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getValidateAndCompleteSubstep1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳쐃쟴햟혮 햣햢햪햣혝 향 햟햧혜-햩햦혜혝햟
 */
export const selectPriceListItem = (
    sessionId: string,
    params: SelectPriceListItemParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/select-item`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSelectPriceListItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectPriceListItem>>, TError,{sessionId: string;params: SelectPriceListItemParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof selectPriceListItem>>, TError,{sessionId: string;params: SelectPriceListItemParams}, TContext> => {

const mutationKey = ['selectPriceListItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof selectPriceListItem>>, {sessionId: string;params: SelectPriceListItemParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  selectPriceListItem(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SelectPriceListItemMutationResult = NonNullable<Awaited<ReturnType<typeof selectPriceListItem>>>
    
    export type SelectPriceListItemMutationError = ErrorResponse

    /**
 * @summary 뉋쟳쐃쟴햟혮 햣햢햪햣혝 향 햟햧혜-햩햦혜혝햟
 */
export const useSelectPriceListItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectPriceListItem>>, TError,{sessionId: string;params: SelectPriceListItemParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof selectPriceListItem>>,
        TError,
        {sessionId: string;params: SelectPriceListItemParams},
        TContext
      > => {

      const mutationOptions = getSelectPriceListItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳쐃쟴햟혮 햨햟혝햣햡쮐혰혩 쮐햩혞햡햦
 */
export const selectServiceCategory = (
    sessionId: string,
    params: SelectServiceCategoryParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/select-category`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSelectServiceCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectServiceCategory>>, TError,{sessionId: string;params: SelectServiceCategoryParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof selectServiceCategory>>, TError,{sessionId: string;params: SelectServiceCategoryParams}, TContext> => {

const mutationKey = ['selectServiceCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof selectServiceCategory>>, {sessionId: string;params: SelectServiceCategoryParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  selectServiceCategory(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SelectServiceCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof selectServiceCategory>>>
    
    export type SelectServiceCategoryMutationError = ErrorResponse

    /**
 * @summary 뉋쟳쐃쟴햟혮 햨햟혝햣햡쮐혰혩 쮐햩혞햡햦
 */
export const useSelectServiceCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectServiceCategory>>, TError,{sessionId: string;params: SelectServiceCategoryParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof selectServiceCategory>>,
        TError,
        {sessionId: string;params: SelectServiceCategoryParams},
        TContext
      > => {

      const mutationOptions = getSelectServiceCategoryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐햨햦햢햟혮 혰햢햣혝햟 1 햢 쮐햟혝햨쮏쒫쮏 혜혝햟햫혞
 */
export const resetSubstep1 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/reset`, method: 'POST', signal
    },
      options);
    }
  


export const getResetSubstep1MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetSubstep1>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof resetSubstep1>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['resetSubstep1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetSubstep1>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  resetSubstep1(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetSubstep1MutationResult = NonNullable<Awaited<ReturnType<typeof resetSubstep1>>>
    
    export type ResetSubstep1MutationError = ErrorResponse

    /**
 * @summary 햐햨햦햢햟혮 혰햢햣혝햟 1 햢 쮐햟혝햨쮏쒫쮏 혜혝햟햫혞
 */
export const useResetSubstep1 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetSubstep1>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetSubstep1>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getResetSubstep1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쒫쮏얧쟴혧 햨혰햩혧햨혰혜혝혧
 */
export const enterQuantity = (
    sessionId: string,
    params: EnterQuantityParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/enter-quantity`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getEnterQuantityMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enterQuantity>>, TError,{sessionId: string;params: EnterQuantityParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof enterQuantity>>, TError,{sessionId: string;params: EnterQuantityParams}, TContext> => {

const mutationKey = ['enterQuantity'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof enterQuantity>>, {sessionId: string;params: EnterQuantityParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  enterQuantity(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EnterQuantityMutationResult = NonNullable<Awaited<ReturnType<typeof enterQuantity>>>
    
    export type EnterQuantityMutationError = ErrorResponse

    /**
 * @summary 뉋쒫쮏얧쟴혧 햨혰햩혧햨혰혜혝혧
 */
export const useEnterQuantity = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enterQuantity>>, TError,{sessionId: string;params: EnterQuantityParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof enterQuantity>>,
        TError,
        {sessionId: string;params: EnterQuantityParams},
        TContext
      > => {

      const mutationOptions = getEnterQuantityMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 쮐햦햫햟혮 햫쮏쒫쟳 혰햢햣혝햟 1 - 뤰햫쮏쒫쫧 혰햫혟쮐햪햟혡혰혪
 */
export const startSubstep1 = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/start`, method: 'POST', signal
    },
      options);
    }
  


export const getStartSubstep1MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startSubstep1>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof startSubstep1>>, TError,void, TContext> => {

const mutationKey = ['startSubstep1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startSubstep1>>, void> = () => {
          

          return  startSubstep1(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartSubstep1MutationResult = NonNullable<Awaited<ReturnType<typeof startSubstep1>>>
    
    export type StartSubstep1MutationError = ErrorResponse

    /**
 * @summary 쮐햦햫햟혮 햫쮏쒫쟳 혰햢햣혝햟 1 - 뤰햫쮏쒫쫧 혰햫혟쮐햪햟혡혰혪
 */
export const useStartSubstep1 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startSubstep1>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startSubstep1>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getStartSubstep1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐햨햦햢햟혮 혜햣혜혰혩 햢 쮐햟혝햨쮏쒫쮏 혜혝햟햫혞
 */
export const resetSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/reset/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getResetSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof resetSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['resetSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  resetSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetSessionMutationResult = NonNullable<Awaited<ReturnType<typeof resetSession>>>
    
    export type ResetSessionMutationError = ErrorResponse

    /**
 * @summary 햐햨햦햢햟혮 혜햣혜혰혩 햢 쮐햟혝햨쮏쒫쮏 혜혝햟햫혞
 */
export const useResetSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getResetSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햆쮏얧썜 햫쮏쒫쟳 햣햢햪햣혝 햢 향햟햪쮏쒫햣햫햫혪 (향 혰햢쒬뒗햟햢햟)
 */
export const addItemToOrder = (
    sessionId: string,
    orderItemDTO: OrderItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/items/${sessionId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderItemDTO, signal
    },
      options);
    }
  


export const getAddItemToOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addItemToOrder>>, TError,{sessionId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof addItemToOrder>>, TError,{sessionId: string;data: OrderItemDTO}, TContext> => {

const mutationKey = ['addItemToOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addItemToOrder>>, {sessionId: string;data: OrderItemDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  addItemToOrder(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddItemToOrderMutationResult = NonNullable<Awaited<ReturnType<typeof addItemToOrder>>>
    export type AddItemToOrderMutationBody = OrderItemDTO
    export type AddItemToOrderMutationError = ErrorResponse

    /**
 * @summary 햆쮏얧썜 햫쮏쒫쟳 햣햢햪햣혝 햢 향햟햪쮏쒫햣햫햫혪 (향 혰햢쒬뒗햟햢햟)
 */
export const useAddItemToOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addItemToOrder>>, TError,{sessionId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addItemToOrder>>,
        TError,
        {sessionId: string;data: OrderItemDTO},
        TContext
      > => {

      const mutationOptions = getAddItemToOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 핹햫혰혡혰햟햩혰향혞혮 햫쮏쒫쟳 혜햣햟햫혜 햪햣햫햣햢햤햣햟 햣햢햪햣혝혰 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */
export const initializeItemManager = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/initialize/${orderId}`, method: 'POST', signal
    },
      options);
    }
  


export const getInitializeItemManagerMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeItemManager>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof initializeItemManager>>, TError,{orderId: string}, TContext> => {

const mutationKey = ['initializeItemManager'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeItemManager>>, {orderId: string}> = (props) => {
          const {orderId} = props ?? {};

          return  initializeItemManager(orderId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeItemManagerMutationResult = NonNullable<Awaited<ReturnType<typeof initializeItemManager>>>
    
    export type InitializeItemManagerMutationError = ErrorResponse

    /**
 * @summary 핹햫혰혡혰햟햩혰향혞혮 햫쮏쒫쟳 혜햣햟햫혜 햪햣햫햣햢햤햣햟 햣햢햪햣혝혰 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */
export const useInitializeItemManager = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeItemManager>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initializeItemManager>>,
        TError,
        {orderId: string},
        TContext
      > => {

      const mutationOptions = getInitializeItemManagerMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟쒫왐혣혞혮 햣혝햟 2 혝햟 햣햣혠쮏얧쟴혧 햢 햫햟혜혝혞햫쮏 햣혝햟혞
 */
export const completeStage2 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/complete/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getCompleteStage2MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeStage2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof completeStage2>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['completeStage2'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeStage2>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  completeStage2(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteStage2MutationResult = NonNullable<Awaited<ReturnType<typeof completeStage2>>>
    
    export type CompleteStage2MutationError = ErrorResponse

    /**
 * @summary 행햟쒫왐혣혞혮 햣혝햟 2 혝햟 햣햣혠쮏얧쟴혧 햢 햫햟혜혝혞햫쮏 햣혝햟혞
 */
export const useCompleteStage2 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeStage2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeStage2>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCompleteStage2MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋썛혰햢혞혮 혟쮐햪혞 햨햩혰혮햫혝햟
 */
export const validateNewClientForm = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidateNewClientForm200>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/validate`, method: 'POST', signal
    },
      options);
    }
  


export const getValidateNewClientFormMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateNewClientForm>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof validateNewClientForm>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['validateNewClientForm'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateNewClientForm>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  validateNewClientForm(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ValidateNewClientFormMutationResult = NonNullable<Awaited<ReturnType<typeof validateNewClientForm>>>
    
    export type ValidateNewClientFormMutationError = ErrorResponse

    /**
 * @summary 뉋썛혰햢혞혮 혟쮐햪혞 햨햩혰혮햫혝햟
 */
export const useValidateNewClientForm = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateNewClientForm>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof validateNewClientForm>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getValidateNewClientFormMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐혝쒫쮐혩혮 햫쮏쒫쮏 햨햩혰혮햫혝햟
 */
export const createNewClient = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/create`, method: 'POST', signal
    },
      options);
    }
  


export const getCreateNewClientMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNewClient>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createNewClient>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['createNewClient'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNewClient>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  createNewClient(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNewClientMutationResult = NonNullable<Awaited<ReturnType<typeof createNewClient>>>
    
    export type CreateNewClientMutationError = ErrorResponse

    /**
 * @summary 햐혝쒫쮐혩혮 햫쮏쒫쮏 햨햩혰혮햫혝햟
 */
export const useCreateNewClient = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNewClient>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createNewClient>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCreateNewClientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟쒫왐혣혞혮 혜혝쒫쮐햣햫햫혪 햨햩혰혮햫혝햟
 */
export const completeNewClientCreation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getCompleteNewClientCreationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeNewClientCreation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof completeNewClientCreation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['completeNewClientCreation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeNewClientCreation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  completeNewClientCreation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteNewClientCreationMutationResult = NonNullable<Awaited<ReturnType<typeof completeNewClientCreation>>>
    
    export type CompleteNewClientCreationMutationError = ErrorResponse

    /**
 * @summary 행햟쒫왐혣혞혮 혜혝쒫쮐햣햫햫혪 햨햩혰혮햫혝햟
 */
export const useCompleteNewClientCreation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeNewClientCreation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeNewClientCreation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCompleteNewClientCreationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 핹햫혰혡혰햟햩혰향혞혮 혟쮐햪혞 혜혝쒫쮐햣햫햫혪 햫쮏쒫쮏 햨햩혰혮햫혝햟
 */
export const initializeNewClientForm = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage1/new-client/initialize`, method: 'POST', signal
    },
      options);
    }
  


export const getInitializeNewClientFormMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeNewClientForm>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof initializeNewClientForm>>, TError,void, TContext> => {

const mutationKey = ['initializeNewClientForm'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeNewClientForm>>, void> = () => {
          

          return  initializeNewClientForm(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeNewClientFormMutationResult = NonNullable<Awaited<ReturnType<typeof initializeNewClientForm>>>
    
    export type InitializeNewClientFormMutationError = ErrorResponse

    /**
 * @summary 핹햫혰혡혰햟햩혰향혞혮 혟쮐햪혞 혜혝쒫쮐햣햫햫혪 햫쮏쒫쮏 햨햩혰혮햫혝햟
 */
export const useInitializeNewClientForm = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeNewClientForm>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initializeNewClientForm>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getInitializeNewClientFormMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳쐃쟴햟혮 햨햩혰혮햫혝햟 향혰 혜햦혜햨혞 햣향혞햩혧혝햟혝혰
 */
export const selectClient = (
    sessionId: string,
    params: SelectClientParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/select-client`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSelectClientMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectClient>>, TError,{sessionId: string;params: SelectClientParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof selectClient>>, TError,{sessionId: string;params: SelectClientParams}, TContext> => {

const mutationKey = ['selectClient'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof selectClient>>, {sessionId: string;params: SelectClientParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  selectClient(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SelectClientMutationResult = NonNullable<Awaited<ReturnType<typeof selectClient>>>
    
    export type SelectClientMutationError = ErrorResponse

    /**
 * @summary 뉋쟳쐃쟴햟혮 햨햩혰혮햫혝햟 향혰 혜햦혜햨혞 햣향혞햩혧혝햟혝혰
 */
export const useSelectClient = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectClient>>, TError,{sessionId: string;params: SelectClientParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof selectClient>>,
        TError,
        {sessionId: string;params: SelectClientParams},
        TContext
      > => {

      const mutationOptions = getSelectClientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳쥃쮏쫨혮 쮐걤햨 햨햩혰혮햫혝혰 향 햨햦혝햣혰혪햪햦
 */
export const searchClients = (
    sessionId: string,
    clientSearchCriteriaDTO: ClientSearchCriteriaDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientSearchResultDTO>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: clientSearchCriteriaDTO, signal
    },
      options);
    }
  


export const getSearchClientsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchClients>>, TError,{sessionId: string;data: ClientSearchCriteriaDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof searchClients>>, TError,{sessionId: string;data: ClientSearchCriteriaDTO}, TContext> => {

const mutationKey = ['searchClients'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchClients>>, {sessionId: string;data: ClientSearchCriteriaDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  searchClients(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchClientsMutationResult = NonNullable<Awaited<ReturnType<typeof searchClients>>>
    export type SearchClientsMutationBody = ClientSearchCriteriaDTO
    export type SearchClientsMutationError = ErrorResponse

    /**
 * @summary 뉋쟳쥃쮏쫨혮 쮐걤햨 햨햩혰혮햫혝혰 향 햨햦혝햣혰혪햪햦
 */
export const useSearchClients = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchClients>>, TError,{sessionId: string;data: ClientSearchCriteriaDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchClients>>,
        TError,
        {sessionId: string;data: ClientSearchCriteriaDTO},
        TContext
      > => {

      const mutationOptions = getSearchClientsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 쮐걤햨 햨햩혰혮햫혝혰 향햟 혝햣햩햣혟쮏쫧쮏
 */
export const searchClientsByPhone = (
    sessionId: string,
    params: SearchClientsByPhoneParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientSearchResultDTO>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/search-by-phone`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSearchClientsByPhoneMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchClientsByPhone>>, TError,{sessionId: string;params: SearchClientsByPhoneParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof searchClientsByPhone>>, TError,{sessionId: string;params: SearchClientsByPhoneParams}, TContext> => {

const mutationKey = ['searchClientsByPhone'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchClientsByPhone>>, {sessionId: string;params: SearchClientsByPhoneParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  searchClientsByPhone(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchClientsByPhoneMutationResult = NonNullable<Awaited<ReturnType<typeof searchClientsByPhone>>>
    
    export type SearchClientsByPhoneMutationError = ErrorResponse

    /**
 * @summary 쮐걤햨 햨햩혰혮햫혝혰 향햟 혝햣햩햣혟쮏쫧쮏
 */
export const useSearchClientsByPhone = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchClientsByPhone>>, TError,{sessionId: string;params: SearchClientsByPhoneParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchClientsByPhone>>,
        TError,
        {sessionId: string;params: SearchClientsByPhoneParams},
        TContext
      > => {

      const mutationOptions = getSearchClientsByPhoneMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟쒫왐혣혞혮 쮐걤햨 햨햩혰혮햫혝햟
 */
export const completeClientSearch = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getCompleteClientSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof completeClientSearch>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['completeClientSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeClientSearch>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  completeClientSearch(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteClientSearchMutationResult = NonNullable<Awaited<ReturnType<typeof completeClientSearch>>>
    
    export type CompleteClientSearchMutationError = ErrorResponse

    /**
 * @summary 행햟쒫왐혣혞혮 쮐걤햨 햨햩혰혮햫혝햟
 */
export const useCompleteClientSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeClientSearch>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCompleteClientSearchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤰햦혤혞혮 햣향혞햩혧혝햟혝햦 쮐걤햨혞
 */
export const clearClientSearch = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/clear`, method: 'POST', signal
    },
      options);
    }
  


export const getClearClientSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof clearClientSearch>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['clearClientSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof clearClientSearch>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  clearClientSearch(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ClearClientSearchMutationResult = NonNullable<Awaited<ReturnType<typeof clearClientSearch>>>
    
    export type ClearClientSearchMutationError = ErrorResponse

    /**
 * @summary 뤰햦혤혞혮 햣향혞햩혧혝햟혝햦 쮐걤햨혞
 */
export const useClearClientSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof clearClientSearch>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getClearClientSearchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 핹햫혰혡혰햟햩혰향혞혮 햫쮏쒫쟳 햨쮏쫨햣햨혜혝 쮐걤햨혞 햨햩혰혮햫혝혰
 */
export const initializeClientSearch = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage1/client-search/initialize`, method: 'POST', signal
    },
      options);
    }
  


export const getInitializeClientSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeClientSearch>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof initializeClientSearch>>, TError,void, TContext> => {

const mutationKey = ['initializeClientSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeClientSearch>>, void> = () => {
          

          return  initializeClientSearch(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeClientSearchMutationResult = NonNullable<Awaited<ReturnType<typeof initializeClientSearch>>>
    
    export type InitializeClientSearchMutationError = ErrorResponse

    /**
 * @summary 핹햫혰혡혰햟햩혰향혞혮 햫쮏쒫쟳 햨쮏쫨햣햨혜혝 쮐걤햨혞 햨햩혰혮햫혝혰
 */
export const useInitializeClientSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeClientSearch>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initializeClientSearch>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getInitializeClientSearchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 쮐햦햫햟혮 workflow 햠햟향쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */
export const startBasicOrderWorkflow = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage1/basic-order/workflow/start`, method: 'POST', signal
    },
      options);
    }
  


export const getStartBasicOrderWorkflowMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startBasicOrderWorkflow>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof startBasicOrderWorkflow>>, TError,void, TContext> => {

const mutationKey = ['startBasicOrderWorkflow'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startBasicOrderWorkflow>>, void> = () => {
          

          return  startBasicOrderWorkflow(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartBasicOrderWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof startBasicOrderWorkflow>>>
    
    export type StartBasicOrderWorkflowMutationError = ErrorResponse

    /**
 * @summary 쮐햦햫햟혮 workflow 햠햟향쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */
export const useStartBasicOrderWorkflow = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startBasicOrderWorkflow>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startBasicOrderWorkflow>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getStartBasicOrderWorkflowMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋썛혰햢혞혮 햠햟향쮏쒬 혰햫혟쮐햪햟혡혰혩
 */
export const validateBasicOrderInfo = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidateBasicOrderInfo200>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/validate`, method: 'POST', signal
    },
      options);
    }
  


export const getValidateBasicOrderInfoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateBasicOrderInfo>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof validateBasicOrderInfo>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['validateBasicOrderInfo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateBasicOrderInfo>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  validateBasicOrderInfo(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ValidateBasicOrderInfoMutationResult = NonNullable<Awaited<ReturnType<typeof validateBasicOrderInfo>>>
    
    export type ValidateBasicOrderInfoMutationError = ErrorResponse

    /**
 * @summary 뉋썛혰햢혞혮 햠햟향쮏쒬 혰햫혟쮐햪햟혡혰혩
 */
export const useValidateBasicOrderInfo = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateBasicOrderInfo>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof validateBasicOrderInfo>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getValidateBasicOrderInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉌혝햟햫쮏쒫혩혮 혞햫혰햨햟햩혧햫혞 햪혰혝햨혞
 */
export const setUniqueTag = (
    sessionId: string,
    params: SetUniqueTagParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/set-unique-tag`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSetUniqueTagMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setUniqueTag>>, TError,{sessionId: string;params: SetUniqueTagParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof setUniqueTag>>, TError,{sessionId: string;params: SetUniqueTagParams}, TContext> => {

const mutationKey = ['setUniqueTag'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setUniqueTag>>, {sessionId: string;params: SetUniqueTagParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  setUniqueTag(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetUniqueTagMutationResult = NonNullable<Awaited<ReturnType<typeof setUniqueTag>>>
    
    export type SetUniqueTagMutationError = ErrorResponse

    /**
 * @summary 뉌혝햟햫쮏쒫혩혮 혞햫혰햨햟햩혧햫혞 햪혰혝햨혞
 */
export const useSetUniqueTag = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setUniqueTag>>, TError,{sessionId: string;params: SetUniqueTagParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setUniqueTag>>,
        TError,
        {sessionId: string;params: SetUniqueTagParams},
        TContext
      > => {

      const mutationOptions = getSetUniqueTagMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳쐃쟴햟혮 혟혰햩혰혩 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */
export const selectBranch = (
    sessionId: string,
    params: SelectBranchParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/select-branch`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSelectBranchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectBranch>>, TError,{sessionId: string;params: SelectBranchParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof selectBranch>>, TError,{sessionId: string;params: SelectBranchParams}, TContext> => {

const mutationKey = ['selectBranch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof selectBranch>>, {sessionId: string;params: SelectBranchParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  selectBranch(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SelectBranchMutationResult = NonNullable<Awaited<ReturnType<typeof selectBranch>>>
    
    export type SelectBranchMutationError = ErrorResponse

    /**
 * @summary 뉋쟳쐃쟴햟혮 혟혰햩혰혩 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */
export const useSelectBranch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selectBranch>>, TError,{sessionId: string;params: SelectBranchParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof selectBranch>>,
        TError,
        {sessionId: string;params: SelectBranchParams},
        TContext
      > => {

      const mutationOptions = getSelectBranchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐햨햦햢햟혮 햠햟향쮏쒬 혰햫혟쮐햪햟혡혰혩 햢 쮐햟혝햨쮏쒫쮏 혜혝햟햫혞
 */
export const resetBasicOrderInfo = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/reset`, method: 'POST', signal
    },
      options);
    }
  


export const getResetBasicOrderInfoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetBasicOrderInfo>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof resetBasicOrderInfo>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['resetBasicOrderInfo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetBasicOrderInfo>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  resetBasicOrderInfo(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetBasicOrderInfoMutationResult = NonNullable<Awaited<ReturnType<typeof resetBasicOrderInfo>>>
    
    export type ResetBasicOrderInfoMutationError = ErrorResponse

    /**
 * @summary 햐햨햦햢햟혮 햠햟향쮏쒬 혰햫혟쮐햪햟혡혰혩 햢 쮐햟혝햨쮏쒫쮏 혜혝햟햫혞
 */
export const useResetBasicOrderInfo = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetBasicOrderInfo>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetBasicOrderInfo>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getResetBasicOrderInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햅햣햫햣혞혮 햫쮏쨿왐 햨쒫쟴햟햫혡혰혱
 */
export const generateReceiptNumber = (
    sessionId: string,
    params: GenerateReceiptNumberParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/generate-receipt-number`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getGenerateReceiptNumberMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateReceiptNumber>>, TError,{sessionId: string;params: GenerateReceiptNumberParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof generateReceiptNumber>>, TError,{sessionId: string;params: GenerateReceiptNumberParams}, TContext> => {

const mutationKey = ['generateReceiptNumber'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateReceiptNumber>>, {sessionId: string;params: GenerateReceiptNumberParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  generateReceiptNumber(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateReceiptNumberMutationResult = NonNullable<Awaited<ReturnType<typeof generateReceiptNumber>>>
    
    export type GenerateReceiptNumberMutationError = ErrorResponse

    /**
 * @summary 햅햣햫햣혞혮 햫쮏쨿왐 햨쒫쟴햟햫혡혰혱
 */
export const useGenerateReceiptNumber = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateReceiptNumber>>, TError,{sessionId: string;params: GenerateReceiptNumberParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateReceiptNumber>>,
        TError,
        {sessionId: string;params: GenerateReceiptNumberParams},
        TContext
      > => {

      const mutationOptions = getGenerateReceiptNumberMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟쒫왐혣혞혮 향햠혰 햠햟향쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */
export const completeBasicOrderInfo = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getCompleteBasicOrderInfoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeBasicOrderInfo>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof completeBasicOrderInfo>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['completeBasicOrderInfo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeBasicOrderInfo>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  completeBasicOrderInfo(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteBasicOrderInfoMutationResult = NonNullable<Awaited<ReturnType<typeof completeBasicOrderInfo>>>
    
    export type CompleteBasicOrderInfoMutationError = ErrorResponse

    /**
 * @summary 행햟쒫왐혣혞혮 향햠혰 햠햟향쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */
export const useCompleteBasicOrderInfo = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeBasicOrderInfo>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeBasicOrderInfo>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCompleteBasicOrderInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 핹햫혰혡혰햟햩혰향혞혮 향햠혰 햠햟향쮏쒫쮐 혰햫혟쮐햪햟혡혰혱 향햟햪쮏쒫햣햫햫혪
 */
export const initializeBasicOrderInfo = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage1/basic-order/initialize`, method: 'POST', signal
    },
      options);
    }
  


export const getInitializeBasicOrderInfoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeBasicOrderInfo>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof initializeBasicOrderInfo>>, TError,void, TContext> => {

const mutationKey = ['initializeBasicOrderInfo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeBasicOrderInfo>>, void> = () => {
          

          return  initializeBasicOrderInfo(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeBasicOrderInfoMutationResult = NonNullable<Awaited<ReturnType<typeof initializeBasicOrderInfo>>>
    
    export type InitializeBasicOrderInfoMutationError = ErrorResponse

    /**
 * @summary 핹햫혰혡혰햟햩혰향혞혮 향햠혰 햠햟향쮏쒫쮐 혰햫혟쮐햪햟혡혰혱 향햟햪쮏쒫햣햫햫혪
 */
export const useInitializeBasicOrderInfo = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeBasicOrderInfo>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initializeBasicOrderInfo>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getInitializeBasicOrderInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 쒬혰혠 햟햠 혝혰햩혧햨햦 햟햨혝햦쒫쫧쟴 혝햦혰 햩혪햪 향 햪쮏웷햦쒬뒘혝혩 혟혰햩혧혝햟혡혰혱 향햟 혰쒫쫧왏 햦향햦햨혞
 * @summary 뤰햦햪햟혝햦 혝햦햦 햩혪햪
 */
export const getStainTypes = (
    params?: GetStainTypesParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainTypeDTO[]>(
      {url: `/stain-types`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetStainTypesQueryKey = (params?: GetStainTypesParams,) => {
    return [`/stain-types`, ...(params ? [params]: [])] as const;
    }

    
export const getGetStainTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes>>> = ({ signal }) => getStainTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes>>>
export type GetStainTypesInfiniteQueryError = ErrorResponse


export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params: undefined |  GetStainTypesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦햦 햩혪햪
 */

export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypesInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypesQueryOptions = <TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes>>> = ({ signal }) => getStainTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes>>>
export type GetStainTypesQueryError = ErrorResponse


export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params: undefined |  GetStainTypesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦햦 햩혪햪
 */

export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 햐혝쒫쮐혩혮 햫쮏쒫쟳 혝햦 햩혪햪햦 향 쒫쥃썛햟햫햦햪햦 햢햟햫햦햪햦
 * @summary 햐혝쒫쮐햦혝햦 혝햦 햩혪햪햦
 */
export const createStainType = (
    stainTypeDTO: StainTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreateStainType200>(
      {url: `/stain-types`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: stainTypeDTO, signal
    },
      options);
    }
  


export const getCreateStainTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStainType>>, TError,{data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createStainType>>, TError,{data: StainTypeDTO}, TContext> => {

const mutationKey = ['createStainType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStainType>>, {data: StainTypeDTO}> = (props) => {
          const {data} = props ?? {};

          return  createStainType(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateStainTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createStainType>>>
    export type CreateStainTypeMutationBody = StainTypeDTO
    export type CreateStainTypeMutationError = ErrorResponse

    /**
 * @summary 햐혝쒫쮐햦혝햦 혝햦 햩혪햪햦
 */
export const useCreateStainType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStainType>>, TError,{data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createStainType>>,
        TError,
        {data: StainTypeDTO},
        TContext
      > => {

      const mutationOptions = getCreateStainTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 행햠햣혰햡햟혮 햫쮏쒫쟳 햟햠 쮏쫧쮏쒫혩혮 혰혜햫혞혩혢햦햧 혰햢햦혜 햨햩혰혮햫혝햟
 * @summary 행햠햣햣햡혝햦 혰햢햦혜 햨햩혰혮햫혝햟
 */
export const saveSignature1 = (
    customerSignatureRequest: CustomerSignatureRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CustomerSignatureResponse>(
      {url: `/signatures`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: customerSignatureRequest, signal
    },
      options);
    }
  


export const getSaveSignature1MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveSignature1>>, TError,{data: CustomerSignatureRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof saveSignature1>>, TError,{data: CustomerSignatureRequest}, TContext> => {

const mutationKey = ['saveSignature1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveSignature1>>, {data: CustomerSignatureRequest}> = (props) => {
          const {data} = props ?? {};

          return  saveSignature1(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SaveSignature1MutationResult = NonNullable<Awaited<ReturnType<typeof saveSignature1>>>
    export type SaveSignature1MutationBody = CustomerSignatureRequest
    export type SaveSignature1MutationError = ErrorResponse

    /**
 * @summary 행햠햣햣햡혝햦 혰햢햦혜 햨햩혰혮햫혝햟
 */
export const useSaveSignature1 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveSignature1>>, TError,{data: CustomerSignatureRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof saveSignature1>>,
        TError,
        {data: CustomerSignatureRequest},
        TContext
      > => {

      const mutationOptions = getSaveSignature1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 햅햣햫햣혞혮 PDF-햨쒫쟴햟햫혡혰혩 햢햩혪 향햟햪쮏쒫햣햫햫혪 향 쒫쥃썛햟햫햦햪햦 햟햟햪햣혝햟햪햦
 * @summary 행햡햣햫햣혞쒫썜햦 PDF-햨쒫쟴햟햫혡혰혩
 */
export const generatePdfReceipt1 = (
    receiptGenerationRequest: ReceiptGenerationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PdfReceiptResponse>(
      {url: `/receipts/pdf`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: receiptGenerationRequest, signal
    },
      options);
    }
  


export const getGeneratePdfReceipt1MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePdfReceipt1>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof generatePdfReceipt1>>, TError,{data: ReceiptGenerationRequest}, TContext> => {

const mutationKey = ['generatePdfReceipt1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generatePdfReceipt1>>, {data: ReceiptGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  generatePdfReceipt1(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GeneratePdfReceipt1MutationResult = NonNullable<Awaited<ReturnType<typeof generatePdfReceipt1>>>
    export type GeneratePdfReceipt1MutationBody = ReceiptGenerationRequest
    export type GeneratePdfReceipt1MutationError = ErrorResponse

    /**
 * @summary 행햡햣햫햣혞쒫썜햦 PDF-햨쒫쟴햟햫혡혰혩
 */
export const useGeneratePdfReceipt1 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePdfReceipt1>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generatePdfReceipt1>>,
        TError,
        {data: ReceiptGenerationRequest},
        TContext
      > => {

      const mutationOptions = getGeneratePdfReceipt1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뉌뒗얧햟쒫혪혮 PDF-햨쒫쟴햟햫혡혰혩 햫햟 쒫쥃썛햟햫햦햧 email
 * @summary 뉌뒗얧햟쒫쟴햦 햨쒫쟴햟햫혡혰혩 햫햟 email
 */
export const sendReceiptByEmail = (
    emailReceiptRequest: EmailReceiptRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<EmailReceiptResponse>(
      {url: `/receipts/email`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: emailReceiptRequest, signal
    },
      options);
    }
  


export const getSendReceiptByEmailMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendReceiptByEmail>>, TError,{data: EmailReceiptRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof sendReceiptByEmail>>, TError,{data: EmailReceiptRequest}, TContext> => {

const mutationKey = ['sendReceiptByEmail'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendReceiptByEmail>>, {data: EmailReceiptRequest}> = (props) => {
          const {data} = props ?? {};

          return  sendReceiptByEmail(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendReceiptByEmailMutationResult = NonNullable<Awaited<ReturnType<typeof sendReceiptByEmail>>>
    export type SendReceiptByEmailMutationBody = EmailReceiptRequest
    export type SendReceiptByEmailMutationError = ErrorResponse

    /**
 * @summary 뉌뒗얧햟쒫쟴햦 햨쒫쟴햟햫혡혰혩 햫햟 email
 */
export const useSendReceiptByEmail = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendReceiptByEmail>>, TError,{data: EmailReceiptRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendReceiptByEmail>>,
        TError,
        {data: EmailReceiptRequest},
        TContext
      > => {

      const mutationOptions = getSendReceiptByEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햟햨혝햦쒫쫨 햪쮏얧쟴혰햨햟혝쮐햦
 */
export const getAllModifiers = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAllModifiers200>(
      {url: `/price-modifiers`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllModifiersQueryKey = () => {
    return [`/price-modifiers`] as const;
    }

    
export const getGetAllModifiersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllModifiersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllModifiers>>> = ({ signal }) => getAllModifiers(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllModifiersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllModifiers>>>
export type GetAllModifiersInfiniteQueryError = ErrorResponse


export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햟햨혝햦쒫쫨 햪쮏얧쟴혰햨햟혝쮐햦
 */

export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllModifiersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllModifiersQueryOptions = <TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllModifiersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllModifiers>>> = ({ signal }) => getAllModifiers(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllModifiers>>>
export type GetAllModifiersQueryError = ErrorResponse


export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햟햨혝햦쒫쫨 햪쮏얧쟴혰햨햟혝쮐햦
 */

export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllModifiersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒫쟳 햪쮏얧쟴혰햨햟혝쮐 혡혰햫햦
 */
export const createModifier = (
    priceModifierDTO: PriceModifierDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreateModifier200>(
      {url: `/price-modifiers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: priceModifierDTO, signal
    },
      options);
    }
  


export const getCreateModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModifier>>, TError,{data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createModifier>>, TError,{data: PriceModifierDTO}, TContext> => {

const mutationKey = ['createModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createModifier>>, {data: PriceModifierDTO}> = (props) => {
          const {data} = props ?? {};

          return  createModifier(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateModifierMutationResult = NonNullable<Awaited<ReturnType<typeof createModifier>>>
    export type CreateModifierMutationBody = PriceModifierDTO
    export type CreateModifierMutationError = ErrorResponse

    /**
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒫쟳 햪쮏얧쟴혰햨햟혝쮐 혡혰햫햦
 */
export const useCreateModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModifier>>, TError,{data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createModifier>>,
        TError,
        {data: PriceModifierDTO},
        TContext
      > => {

      const mutationOptions = getCreateModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒫쟳 햣햩햣햪햣햫혝 햟햧혜-햩햦혜혝햟  햨햟혝햣햡쮐혰혱
 */
export const createPriceListItem = (
    categoryId: string,
    priceListItemDTO: PriceListItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreatePriceListItem200>(
      {url: `/price-list/${categoryId}/item`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: priceListItemDTO, signal
    },
      options);
    }
  


export const getCreatePriceListItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPriceListItem>>, TError,{categoryId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createPriceListItem>>, TError,{categoryId: string;data: PriceListItemDTO}, TContext> => {

const mutationKey = ['createPriceListItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPriceListItem>>, {categoryId: string;data: PriceListItemDTO}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  createPriceListItem(categoryId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePriceListItemMutationResult = NonNullable<Awaited<ReturnType<typeof createPriceListItem>>>
    export type CreatePriceListItemMutationBody = PriceListItemDTO
    export type CreatePriceListItemMutationError = ErrorResponse

    /**
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒫쟳 햣햩햣햪햣햫혝 햟햧혜-햩햦혜혝햟  햨햟혝햣햡쮐혰혱
 */
export const useCreatePriceListItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPriceListItem>>, TError,{categoryId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPriceListItem>>,
        TError,
        {categoryId: string;data: PriceListItemDTO},
        TContext
      > => {

      const mutationOptions = getCreatePriceListItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒬 햨햟혝햣햡쮐혰혩 쮐햩혞햡
 */
export const createCategory = (
    serviceCategoryDTO: ServiceCategoryDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreateCategory200>(
      {url: `/price-list/category`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: serviceCategoryDTO, signal
    },
      options);
    }
  


export const getCreateCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: ServiceCategoryDTO}, TContext> => {

const mutationKey = ['createCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCategory>>, {data: ServiceCategoryDTO}> = (props) => {
          const {data} = props ?? {};

          return  createCategory(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof createCategory>>>
    export type CreateCategoryMutationBody = ServiceCategoryDTO
    export type CreateCategoryMutationError = ErrorResponse

    /**
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒬 햨햟혝햣햡쮐혰혩 쮐햩혞햡
 */
export const useCreateCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCategory>>,
        TError,
        {data: ServiceCategoryDTO},
        TContext
      > => {

      const mutationOptions = getCreateCategoryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혰햫혟쮐햪햟혡혰혩  햪쮏얧쟴혰햨햟혝쮐햦 향햟 혜햦혜햨쮏 혱혠 햨쮏얨뒗
 * @summary 뤰햦햪햟혝햦 혰햫혟쮐햪햟혡혰혩  햨혰햩혧햨햟 햪쮏얧쟴혰햨햟혝쮐혰
 */
export const getModifiersByCodes = (
    getModifiersByCodesBody: string[],
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersByCodes200>(
      {url: `/price-calculation/modifiers/batch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: getModifiersByCodesBody, signal
    },
      options);
    }
  


export const getGetModifiersByCodesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getModifiersByCodes>>, TError,{data: string[]}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof getModifiersByCodes>>, TError,{data: string[]}, TContext> => {

const mutationKey = ['getModifiersByCodes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getModifiersByCodes>>, {data: string[]}> = (props) => {
          const {data} = props ?? {};

          return  getModifiersByCodes(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetModifiersByCodesMutationResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCodes>>>
    export type GetModifiersByCodesMutationBody = string[]
    export type GetModifiersByCodesMutationError = ErrorResponse

    /**
 * @summary 뤰햦햪햟혝햦 혰햫혟쮐햪햟혡혰혩  햨혰햩혧햨햟 햪쮏얧쟴혰햨햟혝쮐혰
 */
export const useGetModifiersByCodes = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getModifiersByCodes>>, TError,{data: string[]}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getModifiersByCodes>>,
        TError,
        {data: string[]},
        TContext
      > => {

      const mutationOptions = getGetModifiersByCodesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 햆햣혝햟햩혧햫햦햧 쮏햟혠혞햫쮏 혡혰햫햦 향 혞햟혠혞쒫썛쫧쫨햪 햠햟향쮏쒫쮐 혡혰햫햦, 햪쮏얧쟴혰햨햟혝쮐혰, 향햫햦햤쮏 혝햟 혝햣햪혰햫쮏쒫쮐혝혰
 * @summary 먫쮏햟혠혞쒫썜햦 혡혰햫혞 향 혞햟혠혞쒫썛쫧쫨햪 쒫쟳쐄햟햫햦혠 햪쮏얧쟴혰햨햟혝쮐혰
 */
export const calculatePrice1 = (
    priceCalculationRequestDTO: PriceCalculationRequestDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceCalculationResponseDTO>(
      {url: `/price-calculation/calculate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: priceCalculationRequestDTO, signal
    },
      options);
    }
  


export const getCalculatePrice1MutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculatePrice1>>, TError,{data: PriceCalculationRequestDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof calculatePrice1>>, TError,{data: PriceCalculationRequestDTO}, TContext> => {

const mutationKey = ['calculatePrice1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculatePrice1>>, {data: PriceCalculationRequestDTO}> = (props) => {
          const {data} = props ?? {};

          return  calculatePrice1(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalculatePrice1MutationResult = NonNullable<Awaited<ReturnType<typeof calculatePrice1>>>
    export type CalculatePrice1MutationBody = PriceCalculationRequestDTO
    export type CalculatePrice1MutationError = void | ErrorResponse

    /**
 * @summary 먫쮏햟혠혞쒫썜햦 혡혰햫혞 향 혞햟혠혞쒫썛쫧쫨햪 쒫쟳쐄햟햫햦혠 햪쮏얧쟴혰햨햟혝쮐혰
 */
export const useCalculatePrice1 = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculatePrice1>>, TError,{data: PriceCalculationRequestDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof calculatePrice1>>,
        TError,
        {data: PriceCalculationRequestDTO},
        TContext
      > => {

      const mutationOptions = getCalculatePrice1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 쒬혰혠 향햟햪쮏쒫햣햫혧
 * @summary 뤰햦햪햟혝햦 쒬혰 향햟햪쮏쒫햣햫햫혪
 */
export const getAllOrders = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO[]>(
      {url: `/orders`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllOrdersQueryKey = () => {
    return [`/orders`] as const;
    }

    
export const getGetAllOrdersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllOrders>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllOrders>>> = ({ signal }) => getAllOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllOrders>>>
export type GetAllOrdersInfiniteQueryError = ErrorResponse


export function useGetAllOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllOrders>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllOrders>>,
          TError,
          Awaited<ReturnType<typeof getAllOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllOrders>>,
          TError,
          Awaited<ReturnType<typeof getAllOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 향햟햪쮏쒫햣햫햫혪
 */

export function useGetAllOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllOrdersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getAllOrders>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllOrders>>> = ({ signal }) => getAllOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllOrders>>>
export type GetAllOrdersQueryError = ErrorResponse


export function useGetAllOrders<TData = Awaited<ReturnType<typeof getAllOrders>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllOrders>>,
          TError,
          Awaited<ReturnType<typeof getAllOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllOrders<TData = Awaited<ReturnType<typeof getAllOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllOrders>>,
          TError,
          Awaited<ReturnType<typeof getAllOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllOrders<TData = Awaited<ReturnType<typeof getAllOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 향햟햪쮏쒫햣햫햫혪
 */

export function useGetAllOrders<TData = Awaited<ReturnType<typeof getAllOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllOrdersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 햐혝쒫쮐혩혮 햫쮏쒫 향햟햪쮏쒫햣햫햫혪
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒫 향햟햪쮏쒫햣햫햫혪
 */
export const createOrder = (
    createOrderRequest: CreateOrderRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createOrderRequest, signal
    },
      options);
    }
  


export const getCreateOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: CreateOrderRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: CreateOrderRequest}, TContext> => {

const mutationKey = ['createOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOrder>>, {data: CreateOrderRequest}> = (props) => {
          const {data} = props ?? {};

          return  createOrder(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOrderMutationResult = NonNullable<Awaited<ReturnType<typeof createOrder>>>
    export type CreateOrderMutationBody = CreateOrderRequest
    export type CreateOrderMutationError = ErrorResponse

    /**
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒫 향햟햪쮏쒫햣햫햫혪
 */
export const useCreateOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: CreateOrderRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOrder>>,
        TError,
        {data: CreateOrderRequest},
        TContext
      > => {

      const mutationOptions = getCreateOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 쮐쮐햫혰 햢쮏얧썜햨쮏쒬 쒫쟳쨿쮏햦 혝햟 햦햪혰혝햨햦 햨햩혰혮햫혝햟 햢 향햟햪쮏쒫햣햫햫혪
 * @summary 뤰햦햪햟혝햦 햢쮏얧썜햨쮏쒬 쒫쟳쨿쮏햦 혝햟 햦햪혰혝햨햦 햢 향햟햪쮏쒫햣햫햫혪
 */
export const getRequirements = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetRequirements200>(
      {url: `/orders/${orderId}/requirements`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRequirementsQueryKey = (orderId: string,) => {
    return [`/orders/${orderId}/requirements`] as const;
    }

    
export const getGetRequirementsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRequirements>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRequirementsQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRequirements>>> = ({ signal }) => getRequirements(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRequirementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRequirements>>>
export type GetRequirementsInfiniteQueryError = ErrorResponse


export function useGetRequirementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRequirements>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirements>>,
          TError,
          Awaited<ReturnType<typeof getRequirements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRequirements>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirements>>,
          TError,
          Awaited<ReturnType<typeof getRequirements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRequirements>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢쮏얧썜햨쮏쒬 쒫쟳쨿쮏햦 혝햟 햦햪혰혝햨햦 햢 향햟햪쮏쒫햣햫햫혪
 */

export function useGetRequirementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRequirements>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRequirementsInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRequirementsQueryOptions = <TData = Awaited<ReturnType<typeof getRequirements>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRequirementsQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRequirements>>> = ({ signal }) => getRequirements(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRequirementsQueryResult = NonNullable<Awaited<ReturnType<typeof getRequirements>>>
export type GetRequirementsQueryError = ErrorResponse


export function useGetRequirements<TData = Awaited<ReturnType<typeof getRequirements>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirements>>,
          TError,
          Awaited<ReturnType<typeof getRequirements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirements<TData = Awaited<ReturnType<typeof getRequirements>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirements>>,
          TError,
          Awaited<ReturnType<typeof getRequirements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirements<TData = Awaited<ReturnType<typeof getRequirements>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢쮏얧썜햨쮏쒬 쒫쟳쨿쮏햦 혝햟 햦햪혰혝햨햦 햢 향햟햪쮏쒫햣햫햫혪
 */

export function useGetRequirements<TData = Awaited<ReturnType<typeof getRequirements>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRequirementsQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 행햠햣혰햡햟혮 햢쮏얧썜햨쮏쒬 쒫쟳쨿쮏햦 혝햟 햦햪혰혝햨햦 햨햩혰혮햫혝햟 햢 향햟햪쮏쒫햣햫햫혪
 * @summary 뤯쫧쮏쒫쟴햦 햢쮏얧썜햨쮏쒬 쒫쟳쨿쮏햦 혝햟 햦햪혰혝햨햦 햢 향햟햪쮏쒫햣햫햫혪
 */
export const updateRequirements = (
    orderId: string,
    additionalRequirementsRequest: AdditionalRequirementsRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<UpdateRequirements200>(
      {url: `/orders/${orderId}/requirements`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: additionalRequirementsRequest, signal
    },
      options);
    }
  


export const getUpdateRequirementsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRequirements>>, TError,{orderId: string;data: AdditionalRequirementsRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateRequirements>>, TError,{orderId: string;data: AdditionalRequirementsRequest}, TContext> => {

const mutationKey = ['updateRequirements'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRequirements>>, {orderId: string;data: AdditionalRequirementsRequest}> = (props) => {
          const {orderId,data} = props ?? {};

          return  updateRequirements(orderId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRequirementsMutationResult = NonNullable<Awaited<ReturnType<typeof updateRequirements>>>
    export type UpdateRequirementsMutationBody = AdditionalRequirementsRequest
    export type UpdateRequirementsMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫쟴햦 햢쮏얧썜햨쮏쒬 쒫쟳쨿쮏햦 혝햟 햦햪혰혝햨햦 햢 향햟햪쮏쒫햣햫햫혪
 */
export const useUpdateRequirements = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRequirements>>, TError,{orderId: string;data: AdditionalRequirementsRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRequirements>>,
        TError,
        {orderId: string;data: AdditionalRequirementsRequest},
        TContext
      > => {

      const mutationOptions = getUpdateRequirementsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 쮐쮐햫혰 햢햟햫혰  쮏햩햟혝혞 향햟햪쮏쒫햣햫햫혪
 * @summary 뤰햦햪햟혝햦 혰햫혟쮐햪햟혡혰혩  쮏햩햟혝혞 향햟햪쮏쒫햣햫햫혪
 */
export const getOrderPayment = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetOrderPayment200>(
      {url: `/orders/${orderId}/payment`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderPaymentQueryKey = (orderId: string,) => {
    return [`/orders/${orderId}/payment`] as const;
    }

    
export const getGetOrderPaymentInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderPayment>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderPaymentQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderPayment>>> = ({ signal }) => getOrderPayment(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderPaymentInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderPayment>>>
export type GetOrderPaymentInfiniteQueryError = ErrorResponse


export function useGetOrderPaymentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderPayment>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderPayment>>,
          TError,
          Awaited<ReturnType<typeof getOrderPayment>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderPaymentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderPayment>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderPayment>>,
          TError,
          Awaited<ReturnType<typeof getOrderPayment>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderPaymentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderPayment>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혰햫혟쮐햪햟혡혰혩  쮏햩햟혝혞 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderPaymentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderPayment>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderPaymentInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderPaymentQueryOptions = <TData = Awaited<ReturnType<typeof getOrderPayment>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderPaymentQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderPayment>>> = ({ signal }) => getOrderPayment(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderPaymentQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderPayment>>>
export type GetOrderPaymentQueryError = ErrorResponse


export function useGetOrderPayment<TData = Awaited<ReturnType<typeof getOrderPayment>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderPayment>>,
          TError,
          Awaited<ReturnType<typeof getOrderPayment>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderPayment<TData = Awaited<ReturnType<typeof getOrderPayment>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderPayment>>,
          TError,
          Awaited<ReturnType<typeof getOrderPayment>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderPayment<TData = Awaited<ReturnType<typeof getOrderPayment>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혰햫혟쮐햪햟혡혰혩  쮏햩햟혝혞 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderPayment<TData = Awaited<ReturnType<typeof getOrderPayment>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderPaymentQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 행햠햣혰햡햟혮 혰햫혟쮐햪햟혡혰혩  쮏햩햟혝혞 혝햟 쮏햟혠쮏쒬혮 혟혰햫햟햩혧햫혰 혜혞햪햦
 * @summary 행햟혜혝쮐혞쒫썜햦 혰햫혟쮐햪햟혡혰혩  쮏햩햟혝혞 햢 향햟햪쮏쒫햣햫햫혪
 */
export const applyPayment = (
    orderId: string,
    paymentCalculationRequest: PaymentCalculationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ApplyPayment200>(
      {url: `/orders/${orderId}/payment`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: paymentCalculationRequest, signal
    },
      options);
    }
  


export const getApplyPaymentMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyPayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof applyPayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext> => {

const mutationKey = ['applyPayment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof applyPayment>>, {orderId: string;data: PaymentCalculationRequest}> = (props) => {
          const {orderId,data} = props ?? {};

          return  applyPayment(orderId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApplyPaymentMutationResult = NonNullable<Awaited<ReturnType<typeof applyPayment>>>
    export type ApplyPaymentMutationBody = PaymentCalculationRequest
    export type ApplyPaymentMutationError = ErrorResponse

    /**
 * @summary 행햟혜혝쮐혞쒫썜햦 혰햫혟쮐햪햟혡혰혩  쮏햩햟혝혞 햢 향햟햪쮏쒫햣햫햫혪
 */
export const useApplyPayment = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyPayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof applyPayment>>,
        TError,
        {orderId: string;data: PaymentCalculationRequest},
        TContext
      > => {

      const mutationOptions = getApplyPaymentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 먫쮏햟혠쮏쒬혮 혜혞햪햦 쮏햩햟혝햦 햫햟 쮐햫쮏쒬 쒫쥃썛햟햫햦혠 햟햟햪햣혝혰 햠햣향 향햠햣햣햤햣햫햫혪 혞 햠햟향혰 햢햟햫햦혠
 * @summary 먫쮏햟혠혞쒫썜햦 햢햣혝햟햩혰 쮏햩햟혝햦 향햟햪쮏쒫햣햫햫혪
 */
export const calculatePayment = (
    orderId: string,
    paymentCalculationRequest: PaymentCalculationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CalculatePayment200>(
      {url: `/orders/${orderId}/payment/calculate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: paymentCalculationRequest, signal
    },
      options);
    }
  


export const getCalculatePaymentMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculatePayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof calculatePayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext> => {

const mutationKey = ['calculatePayment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculatePayment>>, {orderId: string;data: PaymentCalculationRequest}> = (props) => {
          const {orderId,data} = props ?? {};

          return  calculatePayment(orderId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalculatePaymentMutationResult = NonNullable<Awaited<ReturnType<typeof calculatePayment>>>
    export type CalculatePaymentMutationBody = PaymentCalculationRequest
    export type CalculatePaymentMutationError = ErrorResponse

    /**
 * @summary 먫쮏햟혠혞쒫썜햦 햢햣혝햟햩혰 쮏햩햟혝햦 향햟햪쮏쒫햣햫햫혪
 */
export const useCalculatePayment = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculatePayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof calculatePayment>>,
        TError,
        {orderId: string;data: PaymentCalculationRequest},
        TContext
      > => {

      const mutationOptions = getCalculatePaymentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 쒬혰혠 햣햢햪햣혝혰 햢햩혪 햨쮏쫧쥄햣혝햫쮏 향햟햪쮏쒫햣햫햫혪
 * @summary 뤰햦햪햟혝햦 쒬혰 햣햢햪햣혝햦 향햟햪쮏쒫햣햫햫혪
 */
export const getOrderItems = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderItemDTO[]>(
      {url: `/orders/${orderId}/items`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderItemsQueryKey = (orderId: string,) => {
    return [`/orders/${orderId}/items`] as const;
    }

    
export const getGetOrderItemsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderItems>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderItemsQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderItems>>> = ({ signal }) => getOrderItems(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderItemsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderItems>>>
export type GetOrderItemsInfiniteQueryError = ErrorResponse


export function useGetOrderItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItems>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItems>>,
          TError,
          Awaited<ReturnType<typeof getOrderItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItems>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItems>>,
          TError,
          Awaited<ReturnType<typeof getOrderItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItems>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햣햢햪햣혝햦 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItems>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderItemsInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderItemsQueryOptions = <TData = Awaited<ReturnType<typeof getOrderItems>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderItemsQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderItems>>> = ({ signal }) => getOrderItems(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderItems>>>
export type GetOrderItemsQueryError = ErrorResponse


export function useGetOrderItems<TData = Awaited<ReturnType<typeof getOrderItems>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItems>>,
          TError,
          Awaited<ReturnType<typeof getOrderItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItems<TData = Awaited<ReturnType<typeof getOrderItems>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItems>>,
          TError,
          Awaited<ReturnType<typeof getOrderItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItems<TData = Awaited<ReturnType<typeof getOrderItems>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햣햢햪햣혝햦 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderItems<TData = Awaited<ReturnType<typeof getOrderItems>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderItemsQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 햆쮏얧썜 햫쮏쒫쟳 햣햢햪햣혝 햢 햨쮏쫧쥄햣혝햫쮏 향햟햪쮏쒫햣햫햫혪
 * @summary 햆쮏얧썜햦 햫쮏쒫쟳 햣햢햪햣혝 햢 향햟햪쮏쒫햣햫햫혪
 */
export const addOrderItem = (
    orderId: string,
    orderItemDTO: OrderItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderItemDTO>(
      {url: `/orders/${orderId}/items`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderItemDTO, signal
    },
      options);
    }
  


export const getAddOrderItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addOrderItem>>, TError,{orderId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof addOrderItem>>, TError,{orderId: string;data: OrderItemDTO}, TContext> => {

const mutationKey = ['addOrderItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addOrderItem>>, {orderId: string;data: OrderItemDTO}> = (props) => {
          const {orderId,data} = props ?? {};

          return  addOrderItem(orderId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddOrderItemMutationResult = NonNullable<Awaited<ReturnType<typeof addOrderItem>>>
    export type AddOrderItemMutationBody = OrderItemDTO
    export type AddOrderItemMutationError = ErrorResponse

    /**
 * @summary 햆쮏얧썜햦 햫쮏쒫쟳 햣햢햪햣혝 햢 향햟햪쮏쒫햣햫햫혪
 */
export const useAddOrderItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addOrderItem>>, TError,{orderId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addOrderItem>>,
        TError,
        {orderId: string;data: OrderItemDTO},
        TContext
      > => {

      const mutationOptions = getAddOrderItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뉌뒗얧햟쒫혪혮 PDF-혢햣햨 향햟햪쮏쒫햣햫햫혪 햫햟 email 햨햩혰혮햫혝햟
 * @summary 뉌뒗얧햟쒫쟴햦 혢햣햨 햫햟 email
 */
export const emailReceipt = (
    orderId: string,
    emailReceiptRequest: EmailReceiptRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<EmailReceipt200>(
      {url: `/orders/finalization/${orderId}/email-receipt`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: emailReceiptRequest, signal
    },
      options);
    }
  


export const getEmailReceiptMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof emailReceipt>>, TError,{orderId: string;data: EmailReceiptRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof emailReceipt>>, TError,{orderId: string;data: EmailReceiptRequest}, TContext> => {

const mutationKey = ['emailReceipt'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof emailReceipt>>, {orderId: string;data: EmailReceiptRequest}> = (props) => {
          const {orderId,data} = props ?? {};

          return  emailReceipt(orderId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EmailReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof emailReceipt>>>
    export type EmailReceiptMutationBody = EmailReceiptRequest
    export type EmailReceiptMutationError = ErrorResponse

    /**
 * @summary 뉌뒗얧햟쒫쟴햦 혢햣햨 햫햟 email
 */
export const useEmailReceipt = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof emailReceipt>>, TError,{orderId: string;data: EmailReceiptRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof emailReceipt>>,
        TError,
        {orderId: string;data: EmailReceiptRequest},
        TContext
      > => {

      const mutationOptions = getEmailReceiptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 햓혰햫햟햩혰향혞혮 향햟햪쮏쒫햣햫햫혪, 향햠햣혰햡햟혮 혰햢햦혜 햨햩혰혮햫혝햟 혝햟 향햪혰햫혩혮 혜혝햟혝혞혜 향햟햪쮏쒫햣햫햫혪
 * @summary 행햟쒫왐혣햦혝햦 쮐쮐햪햩햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const finalizeOrder1 = (
    orderFinalizationRequest: OrderFinalizationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/finalization/complete`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderFinalizationRequest, signal
    },
      options);
    }
  


export const getFinalizeOrder1MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalizeOrder1>>, TError,{data: OrderFinalizationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof finalizeOrder1>>, TError,{data: OrderFinalizationRequest}, TContext> => {

const mutationKey = ['finalizeOrder1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalizeOrder1>>, {data: OrderFinalizationRequest}> = (props) => {
          const {data} = props ?? {};

          return  finalizeOrder1(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalizeOrder1MutationResult = NonNullable<Awaited<ReturnType<typeof finalizeOrder1>>>
    export type FinalizeOrder1MutationBody = OrderFinalizationRequest
    export type FinalizeOrder1MutationError = ErrorResponse

    /**
 * @summary 행햟쒫왐혣햦혝햦 쮐쮐햪햩햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const useFinalizeOrder1 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalizeOrder1>>, TError,{data: OrderFinalizationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof finalizeOrder1>>,
        TError,
        {data: OrderFinalizationRequest},
        TContext
      > => {

      const mutationOptions = getFinalizeOrder1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 행햠햣혰햡햟혮 향햟햪쮏쒫햣햫햫혪 혪햨 혢햣햫햣혝햨혞
 * @summary 행햠햣햣햡혝햦 혢햣햫햣혝햨혞 향햟햪쮏쒫햣햫햫혪
 */
export const saveOrderDraft = (
    createOrderRequest: CreateOrderRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/draft`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createOrderRequest, signal
    },
      options);
    }
  


export const getSaveOrderDraftMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveOrderDraft>>, TError,{data: CreateOrderRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof saveOrderDraft>>, TError,{data: CreateOrderRequest}, TContext> => {

const mutationKey = ['saveOrderDraft'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveOrderDraft>>, {data: CreateOrderRequest}> = (props) => {
          const {data} = props ?? {};

          return  saveOrderDraft(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SaveOrderDraftMutationResult = NonNullable<Awaited<ReturnType<typeof saveOrderDraft>>>
    export type SaveOrderDraftMutationBody = CreateOrderRequest
    export type SaveOrderDraftMutationError = ErrorResponse

    /**
 * @summary 행햠햣햣햡혝햦 혢햣햫햣혝햨혞 향햟햪쮏쒫햣햫햫혪
 */
export const useSaveOrderDraft = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveOrderDraft>>, TError,{data: CreateOrderRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof saveOrderDraft>>,
        TError,
        {data: CreateOrderRequest},
        TContext
      > => {

      const mutationOptions = getSaveOrderDraftMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 행햟혜혝쮐쮏쒬혮 향햫햦햤햨혞 햢 향햟햪쮏쒫햣햫햫혪 향 혞햟혠혞쒫썛쫧쫨햪 쮏쐃쨿왏웷왏쫨 햫햟 햨햟혝햣햡쮐혰혱
 * @summary 행햟혜혝쮐혞쒫썜햦 향햫햦햤햨혞 햢 향햟햪쮏쒫햣햫햫혪
 */
export const applyDiscount1 = (
    orderDiscountRequest: OrderDiscountRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ApplyDiscount1200>(
      {url: `/orders/discounts/apply`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderDiscountRequest, signal
    },
      options);
    }
  


export const getApplyDiscount1MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyDiscount1>>, TError,{data: OrderDiscountRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof applyDiscount1>>, TError,{data: OrderDiscountRequest}, TContext> => {

const mutationKey = ['applyDiscount1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof applyDiscount1>>, {data: OrderDiscountRequest}> = (props) => {
          const {data} = props ?? {};

          return  applyDiscount1(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApplyDiscount1MutationResult = NonNullable<Awaited<ReturnType<typeof applyDiscount1>>>
    export type ApplyDiscount1MutationBody = OrderDiscountRequest
    export type ApplyDiscount1MutationError = ErrorResponse

    /**
 * @summary 행햟혜혝쮐혞쒫썜햦 향햫햦햤햨혞 햢 향햟햪쮏쒫햣햫햫혪
 */
export const useApplyDiscount1 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyDiscount1>>, TError,{data: OrderDiscountRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof applyDiscount1>>,
        TError,
        {data: OrderDiscountRequest},
        TContext
      > => {

      const mutationOptions = getApplyDiscount1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 먫쮏햟혠쮏쒬혮 햢햟혝혞 향햟쒫왐혣햣햫햫혪 햫햟 쮐햫쮏쒬 햨햟혝햣햡쮐혰햧 쮐햩혞햡 혝햟 혝햦혞 혝햣햪혰햫쮏쒫쮐혝혰
 * @summary 먫쮏햟혠혞쒫썜햦 쮐혰햨혞쒫썛쫨 햢햟혝혞 향햟쒫왐혣햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const calculateCompletionDate = (
    completionDateCalculationRequest: CompletionDateCalculationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CalculateCompletionDate200>(
      {url: `/orders/completion/calculate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: completionDateCalculationRequest, signal
    },
      options);
    }
  


export const getCalculateCompletionDateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateCompletionDate>>, TError,{data: CompletionDateCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof calculateCompletionDate>>, TError,{data: CompletionDateCalculationRequest}, TContext> => {

const mutationKey = ['calculateCompletionDate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateCompletionDate>>, {data: CompletionDateCalculationRequest}> = (props) => {
          const {data} = props ?? {};

          return  calculateCompletionDate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalculateCompletionDateMutationResult = NonNullable<Awaited<ReturnType<typeof calculateCompletionDate>>>
    export type CalculateCompletionDateMutationBody = CompletionDateCalculationRequest
    export type CalculateCompletionDateMutationError = ErrorResponse

    /**
 * @summary 먫쮏햟혠혞쒫썜햦 쮐혰햨혞쒫썛쫨 햢햟혝혞 향햟쒫왐혣햣햫햫혪 향햟햪쮏쒫햣햫햫혪
 */
export const useCalculateCompletionDate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateCompletionDate>>, TError,{data: CompletionDateCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof calculateCompletionDate>>,
        TError,
        {data: CompletionDateCalculationRequest},
        TContext
      > => {

      const mutationOptions = getCalculateCompletionDateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 쒬혰혠 혟쮐쮏햟혟혰햧 햢햩혪 쒫쥃썛햟햫쮏 햣햢햪햣혝햟 향햟햪쮏쒫햣햫햫혪
 * @summary 뤰햦햪햟혝햦 쒬혰 혟쮐쮏햟혟혰혱 햣햢햪햣혝햟 향햟햪쮏쒫햣햫햫혪
 */
export const getPhotosByItemId = (
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderItemPhotoDTO[]>(
      {url: `/order-items/${itemId}/photos`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPhotosByItemIdQueryKey = (itemId: string,) => {
    return [`/order-items/${itemId}/photos`] as const;
    }

    
export const getGetPhotosByItemIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPhotosByItemId>>>, TError = ErrorResponse>(itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhotosByItemIdQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotosByItemId>>> = ({ signal }) => getPhotosByItemId(itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPhotosByItemIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotosByItemId>>>
export type GetPhotosByItemIdInfiniteQueryError = ErrorResponse


export function useGetPhotosByItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotosByItemId>>>, TError = ErrorResponse>(
 itemId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotosByItemId>>,
          TError,
          Awaited<ReturnType<typeof getPhotosByItemId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotosByItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotosByItemId>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotosByItemId>>,
          TError,
          Awaited<ReturnType<typeof getPhotosByItemId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotosByItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotosByItemId>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 혟쮐쮏햟혟혰혱 햣햢햪햣혝햟 향햟햪쮏쒫햣햫햫혪
 */

export function useGetPhotosByItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotosByItemId>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPhotosByItemIdInfiniteQueryOptions(itemId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPhotosByItemIdQueryOptions = <TData = Awaited<ReturnType<typeof getPhotosByItemId>>, TError = ErrorResponse>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhotosByItemIdQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotosByItemId>>> = ({ signal }) => getPhotosByItemId(itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPhotosByItemIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotosByItemId>>>
export type GetPhotosByItemIdQueryError = ErrorResponse


export function useGetPhotosByItemId<TData = Awaited<ReturnType<typeof getPhotosByItemId>>, TError = ErrorResponse>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotosByItemId>>,
          TError,
          Awaited<ReturnType<typeof getPhotosByItemId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotosByItemId<TData = Awaited<ReturnType<typeof getPhotosByItemId>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotosByItemId>>,
          TError,
          Awaited<ReturnType<typeof getPhotosByItemId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotosByItemId<TData = Awaited<ReturnType<typeof getPhotosByItemId>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 혟쮐쮏햟혟혰혱 햣햢햪햣혝햟 향햟햪쮏쒫햣햫햫혪
 */

export function useGetPhotosByItemId<TData = Awaited<ReturnType<typeof getPhotosByItemId>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPhotosByItemIdQueryOptions(itemId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 행햟쒫썛쫨햟햤혞혮 햫쮏쒬 혟쮐쮏햟혟혰혩 햢햩혪 쒫쥃썛햟햫쮏 햣햢햪햣혝햟 향햟햪쮏쒫햣햫햫혪
 * @summary 행햟쒫썛쫨햟햤햦혝햦 혟쮐쮏햟혟혰혩 햣햢햪햣혝햟 향햟햪쮏쒫햣햫햫혪
 */
export const uploadPhoto = (
    itemId: string,
    uploadPhotoBody: UploadPhotoBody,
    params?: UploadPhotoParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, uploadPhotoBody.file)

      return orvalFetcher<OrderItemPhotoDTO>(
      {url: `/order-items/${itemId}/photos`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData,
        params, signal
    },
      options);
    }
  


export const getUploadPhotoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadPhoto>>, TError,{itemId: string;data: UploadPhotoBody;params?: UploadPhotoParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof uploadPhoto>>, TError,{itemId: string;data: UploadPhotoBody;params?: UploadPhotoParams}, TContext> => {

const mutationKey = ['uploadPhoto'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadPhoto>>, {itemId: string;data: UploadPhotoBody;params?: UploadPhotoParams}> = (props) => {
          const {itemId,data,params} = props ?? {};

          return  uploadPhoto(itemId,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadPhotoMutationResult = NonNullable<Awaited<ReturnType<typeof uploadPhoto>>>
    export type UploadPhotoMutationBody = UploadPhotoBody
    export type UploadPhotoMutationError = ErrorResponse

    /**
 * @summary 행햟쒫썛쫨햟햤햦혝햦 혟쮐쮏햟혟혰혩 햣햢햪햣혝햟 향햟햪쮏쒫햣햫햫혪
 */
export const useUploadPhoto = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadPhoto>>, TError,{itemId: string;data: UploadPhotoBody;params?: UploadPhotoParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadPhoto>>,
        TError,
        {itemId: string;data: UploadPhotoBody;params?: UploadPhotoParams},
        TContext
      > => {

      const mutationOptions = getUploadPhotoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 쒬혰혠 햟햠 혝혰햩혧햨햦 햟햨혝햦쒫쫧쟴 혝햦혰 햢햣혟햣햨혝혰 향 햪쮏웷햦쒬뒘혝혩 혟혰햩혧혝햟혡혰혱 향햟 혰쒫쫧왏 햦향햦햨혞
 * @summary 뤰햦햪햟혝햦 혝햦햦 햢햣혟햣햨혝혰
 */
export const getDefectTypes = (
    params?: GetDefectTypesParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<DefectTypeDTO[]>(
      {url: `/defect-types`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetDefectTypesQueryKey = (params?: GetDefectTypesParams,) => {
    return [`/defect-types`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDefectTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypes>>> = ({ signal }) => getDefectTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypes>>>
export type GetDefectTypesInfiniteQueryError = ErrorResponse


export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params: undefined |  GetDefectTypesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦햦 햢햣혟햣햨혝혰
 */

export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypesInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectTypesQueryOptions = <TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypes>>> = ({ signal }) => getDefectTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypes>>>
export type GetDefectTypesQueryError = ErrorResponse


export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params: undefined |  GetDefectTypesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦햦 햢햣혟햣햨혝혰
 */

export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 햐혝쒫쮐혩혮 햫쮏쒫쟳 혝햦 햢햣혟햣햨혝혞 향 쒫쥃썛햟햫햦햪햦 햢햟햫햦햪햦
 * @summary 햐혝쒫쮐햦혝햦 혝햦 햢햣혟햣햨혝혞
 */
export const createDefectType = (
    defectTypeDTO: DefectTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<DefectTypeDTO>(
      {url: `/defect-types`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: defectTypeDTO, signal
    },
      options);
    }
  


export const getCreateDefectTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDefectType>>, TError,{data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createDefectType>>, TError,{data: DefectTypeDTO}, TContext> => {

const mutationKey = ['createDefectType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDefectType>>, {data: DefectTypeDTO}> = (props) => {
          const {data} = props ?? {};

          return  createDefectType(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDefectTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createDefectType>>>
    export type CreateDefectTypeMutationBody = DefectTypeDTO
    export type CreateDefectTypeMutationError = ErrorResponse

    /**
 * @summary 햐혝쒫쮐햦혝햦 혝햦 햢햣혟햣햨혝혞
 */
export const useCreateDefectType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDefectType>>, TError,{data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDefectType>>,
        TError,
        {data: DefectTypeDTO},
        TContext
      > => {

      const mutationOptions = getCreateDefectTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 쒬혰혠 햨햩혰혮햫혝혰
 * @summary 뤰햦햪햟혝햦 쒬혰혠 햨햩혰혮햫혝혰
 */
export const getAllClients = (
    params?: GetAllClientsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/clients`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAllClientsQueryKey = (params?: GetAllClientsParams,) => {
    return [`/clients`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllClientsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllClients>>>, TError = ErrorResponse>(params?: GetAllClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllClientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllClients>>> = ({ signal }) => getAllClients(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllClientsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllClients>>>
export type GetAllClientsInfiniteQueryError = ErrorResponse


export function useGetAllClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllClients>>>, TError = ErrorResponse>(
 params: undefined |  GetAllClientsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllClients>>,
          TError,
          Awaited<ReturnType<typeof getAllClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllClients>>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllClients>>,
          TError,
          Awaited<ReturnType<typeof getAllClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllClients>>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰혠 햨햩혰혮햫혝혰
 */

export function useGetAllClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllClients>>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllClientsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllClientsQueryOptions = <TData = Awaited<ReturnType<typeof getAllClients>>, TError = ErrorResponse>(params?: GetAllClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllClientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllClients>>> = ({ signal }) => getAllClients(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllClientsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllClients>>>
export type GetAllClientsQueryError = ErrorResponse


export function useGetAllClients<TData = Awaited<ReturnType<typeof getAllClients>>, TError = ErrorResponse>(
 params: undefined |  GetAllClientsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllClients>>,
          TError,
          Awaited<ReturnType<typeof getAllClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllClients<TData = Awaited<ReturnType<typeof getAllClients>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllClients>>,
          TError,
          Awaited<ReturnType<typeof getAllClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllClients<TData = Awaited<ReturnType<typeof getAllClients>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰혠 햨햩혰혮햫혝혰
 */

export function useGetAllClients<TData = Awaited<ReturnType<typeof getAllClients>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllClientsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 햐혝쒫쮐혩혮 햫쮏쒫쮏 햨햩혰혮햫혝햟 향 햫햟햢햟햫햦햪햦 햢햟햫햦햪햦
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒫쮏 햨햩혰혮햫혝햟
 */
export const createClient = (
    createClientRequest: CreateClientRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/clients`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createClientRequest, signal
    },
      options);
    }
  


export const getCreateClientMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClient>>, TError,{data: CreateClientRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createClient>>, TError,{data: CreateClientRequest}, TContext> => {

const mutationKey = ['createClient'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createClient>>, {data: CreateClientRequest}> = (props) => {
          const {data} = props ?? {};

          return  createClient(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateClientMutationResult = NonNullable<Awaited<ReturnType<typeof createClient>>>
    export type CreateClientMutationBody = CreateClientRequest
    export type CreateClientMutationError = ErrorResponse

    /**
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒫쮏 햨햩혰혮햫혝햟
 */
export const useCreateClient = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClient>>, TError,{data: CreateClientRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createClient>>,
        TError,
        {data: CreateClientRequest},
        TContext
      > => {

      const mutationOptions = getCreateClientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮐걤햨 햨햩혰혮햫혝혰 향햟 향햟햦혝쮏 향 혰햢혝햦햪햨쮐 햟햡혰햫햟혡혰혱
 * @summary 쮐걤햨 햨햩혰혮햫혝혰 향 햟햡혰햫햟혡혰혮혩
 */
export const searchClientsWithPagination = (
    clientSearchRequest: ClientSearchRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientPageResponse>(
      {url: `/clients/search/pagination`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: clientSearchRequest, signal
    },
      options);
    }
  


export const getSearchClientsWithPaginationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchClientsWithPagination>>, TError,{data: ClientSearchRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof searchClientsWithPagination>>, TError,{data: ClientSearchRequest}, TContext> => {

const mutationKey = ['searchClientsWithPagination'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchClientsWithPagination>>, {data: ClientSearchRequest}> = (props) => {
          const {data} = props ?? {};

          return  searchClientsWithPagination(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchClientsWithPaginationMutationResult = NonNullable<Awaited<ReturnType<typeof searchClientsWithPagination>>>
    export type SearchClientsWithPaginationMutationBody = ClientSearchRequest
    export type SearchClientsWithPaginationMutationError = ErrorResponse

    /**
 * @summary 쮐걤햨 햨햩혰혮햫혝혰 향 햟햡혰햫햟혡혰혮혩
 */
export const useSearchClientsWithPagination = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchClientsWithPagination>>, TError,{data: ClientSearchRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchClientsWithPagination>>,
        TError,
        {data: ClientSearchRequest},
        TContext
      > => {

      const mutationOptions = getSearchClientsWithPaginationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 쒬혰혠 혞햫햨혝혰 햦햧쮏쩀, 혪햨혤 active=true - 혝혰햩혧햨햦 햟햨혝햦쒫쫨
 * @summary 뤰햦햪햟혝햦 쒬혰 혞햫햨혝햦 햦햧쮏쩀 향햟햪쮏쒫햣햫혧
 */
export const getAllBranchLocations = (
    params?: GetAllBranchLocationsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAllBranchLocationsQueryKey = (params?: GetAllBranchLocationsParams,) => {
    return [`/branch-locations`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllBranchLocationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllBranchLocations>>>, TError = ErrorResponse>(params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllBranchLocationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllBranchLocations>>> = ({ signal }) => getAllBranchLocations(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllBranchLocationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllBranchLocations>>>
export type GetAllBranchLocationsInfiniteQueryError = ErrorResponse


export function useGetAllBranchLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllBranchLocations>>>, TError = ErrorResponse>(
 params: undefined |  GetAllBranchLocationsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBranchLocations>>,
          TError,
          Awaited<ReturnType<typeof getAllBranchLocations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBranchLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllBranchLocations>>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBranchLocations>>,
          TError,
          Awaited<ReturnType<typeof getAllBranchLocations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBranchLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllBranchLocations>>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 혞햫햨혝햦 햦햧쮏쩀 향햟햪쮏쒫햣햫혧
 */

export function useGetAllBranchLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllBranchLocations>>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllBranchLocationsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllBranchLocationsQueryOptions = <TData = Awaited<ReturnType<typeof getAllBranchLocations>>, TError = ErrorResponse>(params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllBranchLocationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllBranchLocations>>> = ({ signal }) => getAllBranchLocations(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllBranchLocationsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllBranchLocations>>>
export type GetAllBranchLocationsQueryError = ErrorResponse


export function useGetAllBranchLocations<TData = Awaited<ReturnType<typeof getAllBranchLocations>>, TError = ErrorResponse>(
 params: undefined |  GetAllBranchLocationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBranchLocations>>,
          TError,
          Awaited<ReturnType<typeof getAllBranchLocations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBranchLocations<TData = Awaited<ReturnType<typeof getAllBranchLocations>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBranchLocations>>,
          TError,
          Awaited<ReturnType<typeof getAllBranchLocations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBranchLocations<TData = Awaited<ReturnType<typeof getAllBranchLocations>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 혞햫햨혝햦 햦햧쮏쩀 향햟햪쮏쒫햣햫혧
 */

export function useGetAllBranchLocations<TData = Awaited<ReturnType<typeof getAllBranchLocations>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllBranchLocationsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 햐혝쒫쮐혩혮 햫쮏쒫쟳 혞햫햨혝 햦햧쮏쩀 향햟햪쮏쒫햣햫혧
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒫쟳 혞햫햨혝 햦햧쮏쩀
 */
export const createBranchLocation = (
    branchLocationCreateRequest: BranchLocationCreateRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: branchLocationCreateRequest, signal
    },
      options);
    }
  


export const getCreateBranchLocationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBranchLocation>>, TError,{data: BranchLocationCreateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createBranchLocation>>, TError,{data: BranchLocationCreateRequest}, TContext> => {

const mutationKey = ['createBranchLocation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBranchLocation>>, {data: BranchLocationCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createBranchLocation(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBranchLocationMutationResult = NonNullable<Awaited<ReturnType<typeof createBranchLocation>>>
    export type CreateBranchLocationMutationBody = BranchLocationCreateRequest
    export type CreateBranchLocationMutationError = ErrorResponse

    /**
 * @summary 햐혝쒫쮐햦혝햦 햫쮏쒫쟳 혞햫햨혝 햦햧쮏쩀
 */
export const useCreateBranchLocation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBranchLocation>>, TError,{data: BranchLocationCreateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBranchLocation>>,
        TError,
        {data: BranchLocationCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateBranchLocationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 햐혝쒫쮐혩혮 햫쮏쒫쮏 햨쮐햦혜혝혞쒫썜햟 혰 쮏쒫왐혝햟혮 JWT 혝쮏쥃왏
 * @summary 먫왐덈혝햟혡혰혪 햫쮏쒫쮏 햨쮐햦혜혝혞쒫썜햟
 */
export const register = (
    registerRequest: RegisterRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Register200>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerRequest, signal
    },
      options);
    }
  


export const getRegisterMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext> => {

const mutationKey = ['register'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  register(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
    export type RegisterMutationBody = RegisterRequest
    export type RegisterMutationError = ErrorResponse

    /**
 * @summary 먫왐덈혝햟혡혰혪 햫쮏쒫쮏 햨쮐햦혜혝혞쒫썜햟
 */
export const useRegister = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof register>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {

      const mutationOptions = getRegisterMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 뤯쫧쮏쒫혩혮 JWT 혝쮏쥃왏 향햟 햢쮏쮏쨿쮏쮐 refresh 혝쮏쥃왏쫧
 * @summary 뤯쫧쮏쒫햣햫햫혪 혝쮏쥃왏쫧
 */
export const refreshToken = (
    refreshTokenBody: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<RefreshToken200>(
      {url: `/auth/refresh-token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshTokenBody, signal
    },
      options);
    }
  


export const getRefreshTokenMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: string}, TContext> => {

const mutationKey = ['refreshToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshToken>>, {data: string}> = (props) => {
          const {data} = props ?? {};

          return  refreshToken(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshToken>>>
    export type RefreshTokenMutationBody = string
    export type RefreshTokenMutationError = ErrorResponse

    /**
 * @summary 뤯쫧쮏쒫햣햫햫혪 혝쮏쥃왏쫧
 */
export const useRefreshToken = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshToken>>,
        TError,
        {data: string},
        TContext
      > => {

      const mutationOptions = getRefreshTokenMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 햃쒬햣햫혝햦혟혰햨혞혮 햨쮐햦혜혝혞쒫썜햟 혰 쮏쒫왐혝햟혮 JWT 혝쮏쥃왏
 * @summary 뉌혰햢 햨쮐햦혜혝혞쒫썜햟
 */
export const login = (
    loginRequest: LoginRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Login200>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      options);
    }
  


export const getLoginMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = ErrorResponse

    /**
 * @summary 뉌혰햢 햨쮐햦혜혝혞쒫썜햟
 */
export const useLogin = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 쮏쒫쫧 쒫썛혰햢햟혡혰혪 Stage4
 */
export const validateComplete = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidateComplete200>(
      {url: `/v1/order-wizard/stage4/validate/complete/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getValidateCompleteQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage4/validate/complete/${sessionId}`] as const;
    }

    
export const getValidateCompleteInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof validateComplete>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateCompleteQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateComplete>>> = ({ signal }) => validateComplete(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidateCompleteInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof validateComplete>>>
export type ValidateCompleteInfiniteQueryError = ErrorResponse


export function useValidateCompleteInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateComplete>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateComplete>>,
          TError,
          Awaited<ReturnType<typeof validateComplete>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateCompleteInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateComplete>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateComplete>>,
          TError,
          Awaited<ReturnType<typeof validateComplete>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateCompleteInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateComplete>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 쮏쒫쫧 쒫썛혰햢햟혡혰혪 Stage4
 */

export function useValidateCompleteInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateComplete>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidateCompleteInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getValidateCompleteQueryOptions = <TData = Awaited<ReturnType<typeof validateComplete>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateCompleteQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateComplete>>> = ({ signal }) => validateComplete(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidateCompleteQueryResult = NonNullable<Awaited<ReturnType<typeof validateComplete>>>
export type ValidateCompleteQueryError = ErrorResponse


export function useValidateComplete<TData = Awaited<ReturnType<typeof validateComplete>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateComplete>>,
          TError,
          Awaited<ReturnType<typeof validateComplete>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateComplete<TData = Awaited<ReturnType<typeof validateComplete>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateComplete>>,
          TError,
          Awaited<ReturnType<typeof validateComplete>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateComplete<TData = Awaited<ReturnType<typeof validateComplete>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 쮏쒫쫧 쒫썛혰햢햟혡혰혪 Stage4
 */

export function useValidateComplete<TData = Awaited<ReturnType<typeof validateComplete>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidateCompleteQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 햨쮏쫨햣햨혜혝혞 혜햣혜혰혱
 */
export const getSessionContext = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetSessionContext200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSessionContextQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage4/session/${sessionId}`] as const;
    }

    
export const getGetSessionContextInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSessionContext>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionContextQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionContext>>> = ({ signal }) => getSessionContext(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionContextInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionContext>>>
export type GetSessionContextInfiniteQueryError = ErrorResponse


export function useGetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionContext>>,
          TError,
          Awaited<ReturnType<typeof getSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionContext>>,
          TError,
          Awaited<ReturnType<typeof getSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 햨쮏쫨햣햨혜혝혞 혜햣혜혰혱
 */

export function useGetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionContextInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionContextQueryOptions = <TData = Awaited<ReturnType<typeof getSessionContext>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionContextQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionContext>>> = ({ signal }) => getSessionContext(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionContextQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionContext>>>
export type GetSessionContextQueryError = ErrorResponse


export function useGetSessionContext<TData = Awaited<ReturnType<typeof getSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionContext>>,
          TError,
          Awaited<ReturnType<typeof getSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionContext<TData = Awaited<ReturnType<typeof getSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionContext>>,
          TError,
          Awaited<ReturnType<typeof getSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionContext<TData = Awaited<ReturnType<typeof getSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 햨쮏쫨햣햨혜혝혞 혜햣혜혰혱
 */

export function useGetSessionContext<TData = Awaited<ReturnType<typeof getSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionContextQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 혜혝햟햫혞 Stage4
 */
export const getCurrentState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCurrentState200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCurrentStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage4/session/${sessionId}/state`] as const;
    }

    
export const getGetCurrentStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentState>>> = ({ signal }) => getCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentState>>>
export type GetCurrentStateInfiniteQueryError = ErrorResponse


export function useGetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 혜혝햟햫혞 Stage4
 */

export function useGetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentStateQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentState>>> = ({ signal }) => getCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentStateQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentState>>>
export type GetCurrentStateQueryError = ErrorResponse


export function useGetCurrentState<TData = Awaited<ReturnType<typeof getCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentState<TData = Awaited<ReturnType<typeof getCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentState<TData = Awaited<ReturnType<typeof getCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 혜혝햟햫혞 Stage4
 */

export function useGetCurrentState<TData = Awaited<ReturnType<typeof getCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 햢햣혝햟햩혧햫쮏 혰햢혜혞햪햨혞 향햟햪쮏쒫햣햫햫혪
 */
export const getOrderSummary = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetOrderSummary200>(
      {url: `/v1/order-wizard/stage4/order/${orderId}/summary`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderSummaryQueryKey = (orderId: string,) => {
    return [`/v1/order-wizard/stage4/order/${orderId}/summary`] as const;
    }

    
export const getGetOrderSummaryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderSummary>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderSummaryQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderSummary>>> = ({ signal }) => getOrderSummary(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderSummaryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderSummary>>>
export type GetOrderSummaryInfiniteQueryError = ErrorResponse


export function useGetOrderSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderSummary>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderSummary>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderSummary>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢햣혝햟햩혧햫쮏 혰햢혜혞햪햨혞 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderSummary>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderSummaryInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderSummaryQueryOptions = <TData = Awaited<ReturnType<typeof getOrderSummary>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderSummaryQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderSummary>>> = ({ signal }) => getOrderSummary(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderSummary>>>
export type GetOrderSummaryQueryError = ErrorResponse


export function useGetOrderSummary<TData = Awaited<ReturnType<typeof getOrderSummary>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderSummary<TData = Awaited<ReturnType<typeof getOrderSummary>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderSummary<TData = Awaited<ReturnType<typeof getOrderSummary>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢햣혝햟햩혧햫쮏 혰햢혜혞햪햨혞 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderSummary<TData = Awaited<ReturnType<typeof getOrderSummary>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderSummaryQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뉋썛혰햢혞쒫썜햦 쒬혰 혰햢햣혝햟햦
 */
export const validateAllSubsteps = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/validate-all`, method: 'GET', signal
    },
      options);
    }
  

export const getValidateAllSubstepsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/validate-all`] as const;
    }

    
export const getValidateAllSubstepsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof validateAllSubsteps>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateAllSubstepsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateAllSubsteps>>> = ({ signal }) => validateAllSubsteps(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidateAllSubstepsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof validateAllSubsteps>>>
export type ValidateAllSubstepsInfiniteQueryError = ErrorResponse


export function useValidateAllSubstepsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateAllSubsteps>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateAllSubsteps>>,
          TError,
          Awaited<ReturnType<typeof validateAllSubsteps>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateAllSubstepsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateAllSubsteps>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateAllSubsteps>>,
          TError,
          Awaited<ReturnType<typeof validateAllSubsteps>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateAllSubstepsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateAllSubsteps>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뉋썛혰햢혞쒫썜햦 쒬혰 혰햢햣혝햟햦
 */

export function useValidateAllSubstepsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateAllSubsteps>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidateAllSubstepsInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getValidateAllSubstepsQueryOptions = <TData = Awaited<ReturnType<typeof validateAllSubsteps>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateAllSubstepsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateAllSubsteps>>> = ({ signal }) => validateAllSubsteps(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidateAllSubstepsQueryResult = NonNullable<Awaited<ReturnType<typeof validateAllSubsteps>>>
export type ValidateAllSubstepsQueryError = ErrorResponse


export function useValidateAllSubsteps<TData = Awaited<ReturnType<typeof validateAllSubsteps>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateAllSubsteps>>,
          TError,
          Awaited<ReturnType<typeof validateAllSubsteps>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateAllSubsteps<TData = Awaited<ReturnType<typeof validateAllSubsteps>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateAllSubsteps>>,
          TError,
          Awaited<ReturnType<typeof validateAllSubsteps>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateAllSubsteps<TData = Awaited<ReturnType<typeof validateAllSubsteps>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뉋썛혰햢혞쒫썜햦 쒬혰 혰햢햣혝햟햦
 */

export function useValidateAllSubsteps<TData = Awaited<ReturnType<typeof validateAllSubsteps>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidateAllSubstepsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 혜혝햟햫 혜햣혜혰혱
 */
export const getSessionState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetSessionState200>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSessionStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/state`] as const;
    }

    
export const getGetSessionStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSessionState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionState>>> = ({ signal }) => getSessionState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionState>>>
export type GetSessionStateInfiniteQueryError = ErrorResponse


export function useGetSessionStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionState>>,
          TError,
          Awaited<ReturnType<typeof getSessionState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionState>>,
          TError,
          Awaited<ReturnType<typeof getSessionState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혜혝햟햫 혜햣혜혰혱
 */

export function useGetSessionStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionStateQueryOptions = <TData = Awaited<ReturnType<typeof getSessionState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionState>>> = ({ signal }) => getSessionState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionStateQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionState>>>
export type GetSessionStateQueryError = ErrorResponse


export function useGetSessionState<TData = Awaited<ReturnType<typeof getSessionState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionState>>,
          TError,
          Awaited<ReturnType<typeof getSessionState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionState<TData = Awaited<ReturnType<typeof getSessionState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionState>>,
          TError,
          Awaited<ReturnType<typeof getSessionState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionState<TData = Awaited<ReturnType<typeof getSessionState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혜혝햟햫 혜햣혜혰혱
 */

export function useGetSessionState<TData = Awaited<ReturnType<typeof getSessionState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 Stage3
 */
export const isStage3Ready = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/ready`, method: 'GET', signal
    },
      options);
    }
  

export const getIsStage3ReadyQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/ready`] as const;
    }

    
export const getIsStage3ReadyInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof isStage3Ready>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsStage3ReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isStage3Ready>>> = ({ signal }) => isStage3Ready(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsStage3ReadyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof isStage3Ready>>>
export type IsStage3ReadyInfiniteQueryError = ErrorResponse


export function useIsStage3ReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isStage3Ready>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isStage3Ready>>,
          TError,
          Awaited<ReturnType<typeof isStage3Ready>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsStage3ReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isStage3Ready>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isStage3Ready>>,
          TError,
          Awaited<ReturnType<typeof isStage3Ready>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsStage3ReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isStage3Ready>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 Stage3
 */

export function useIsStage3ReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isStage3Ready>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsStage3ReadyInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getIsStage3ReadyQueryOptions = <TData = Awaited<ReturnType<typeof isStage3Ready>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsStage3ReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isStage3Ready>>> = ({ signal }) => isStage3Ready(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsStage3ReadyQueryResult = NonNullable<Awaited<ReturnType<typeof isStage3Ready>>>
export type IsStage3ReadyQueryError = ErrorResponse


export function useIsStage3Ready<TData = Awaited<ReturnType<typeof isStage3Ready>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isStage3Ready>>,
          TError,
          Awaited<ReturnType<typeof isStage3Ready>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsStage3Ready<TData = Awaited<ReturnType<typeof isStage3Ready>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isStage3Ready>>,
          TError,
          Awaited<ReturnType<typeof isStage3Ready>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsStage3Ready<TData = Awaited<ReturnType<typeof isStage3Ready>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 Stage3
 */

export function useIsStage3Ready<TData = Awaited<ReturnType<typeof isStage3Ready>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isStage3Ready>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsStage3ReadyQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 쮏햣혜 혜햣혜혰혱
 */
export const getSessionProgress = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<number>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/progress`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSessionProgressQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/progress`] as const;
    }

    
export const getGetSessionProgressInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSessionProgress>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionProgressQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionProgress>>> = ({ signal }) => getSessionProgress(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionProgressInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionProgress>>>
export type GetSessionProgressInfiniteQueryError = ErrorResponse


export function useGetSessionProgressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionProgress>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionProgress>>,
          TError,
          Awaited<ReturnType<typeof getSessionProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionProgressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionProgress>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionProgress>>,
          TError,
          Awaited<ReturnType<typeof getSessionProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionProgressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionProgress>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쮏햣혜 혜햣혜혰혱
 */

export function useGetSessionProgressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionProgress>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionProgressInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionProgressQueryOptions = <TData = Awaited<ReturnType<typeof getSessionProgress>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionProgressQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionProgress>>> = ({ signal }) => getSessionProgress(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionProgressQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionProgress>>>
export type GetSessionProgressQueryError = ErrorResponse


export function useGetSessionProgress<TData = Awaited<ReturnType<typeof getSessionProgress>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionProgress>>,
          TError,
          Awaited<ReturnType<typeof getSessionProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionProgress<TData = Awaited<ReturnType<typeof getSessionProgress>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionProgress>>,
          TError,
          Awaited<ReturnType<typeof getSessionProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionProgress<TData = Awaited<ReturnType<typeof getSessionProgress>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쮏햣혜 혜햣혜혰혱
 */

export function useGetSessionProgress<TData = Awaited<ReturnType<typeof getSessionProgress>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionProgressQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햨쮏쫨혰햡혞햟혡혰혱 쮏햩햟혝햦
 */
export const isPaymentConfigReady = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/payment-config/ready`, method: 'GET', signal
    },
      options);
    }
  

export const getIsPaymentConfigReadyQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/payment-config/ready`] as const;
    }

    
export const getIsPaymentConfigReadyInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof isPaymentConfigReady>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsPaymentConfigReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isPaymentConfigReady>>> = ({ signal }) => isPaymentConfigReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsPaymentConfigReadyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof isPaymentConfigReady>>>
export type IsPaymentConfigReadyInfiniteQueryError = ErrorResponse


export function useIsPaymentConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isPaymentConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isPaymentConfigReady>>,
          TError,
          Awaited<ReturnType<typeof isPaymentConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsPaymentConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isPaymentConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isPaymentConfigReady>>,
          TError,
          Awaited<ReturnType<typeof isPaymentConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsPaymentConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isPaymentConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햨쮏쫨혰햡혞햟혡혰혱 쮏햩햟혝햦
 */

export function useIsPaymentConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isPaymentConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsPaymentConfigReadyInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getIsPaymentConfigReadyQueryOptions = <TData = Awaited<ReturnType<typeof isPaymentConfigReady>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsPaymentConfigReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isPaymentConfigReady>>> = ({ signal }) => isPaymentConfigReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsPaymentConfigReadyQueryResult = NonNullable<Awaited<ReturnType<typeof isPaymentConfigReady>>>
export type IsPaymentConfigReadyQueryError = ErrorResponse


export function useIsPaymentConfigReady<TData = Awaited<ReturnType<typeof isPaymentConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isPaymentConfigReady>>,
          TError,
          Awaited<ReturnType<typeof isPaymentConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsPaymentConfigReady<TData = Awaited<ReturnType<typeof isPaymentConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isPaymentConfigReady>>,
          TError,
          Awaited<ReturnType<typeof isPaymentConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsPaymentConfigReady<TData = Awaited<ReturnType<typeof isPaymentConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햨쮏쫨혰햡혞햟혡혰혱 쮏햩햟혝햦
 */

export function useIsPaymentConfigReady<TData = Awaited<ReturnType<typeof isPaymentConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsPaymentConfigReadyQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햫햟혜혝혞햫햦햧 혰햢햣혝햟
 */
export const getNextSubstep = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetNextSubstep200>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/next-substep`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNextSubstepQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/next-substep`] as const;
    }

    
export const getGetNextSubstepInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getNextSubstep>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNextSubstepQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNextSubstep>>> = ({ signal }) => getNextSubstep(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNextSubstepInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNextSubstep>>>
export type GetNextSubstepInfiniteQueryError = ErrorResponse


export function useGetNextSubstepInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNextSubstep>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNextSubstep>>,
          TError,
          Awaited<ReturnType<typeof getNextSubstep>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNextSubstepInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNextSubstep>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNextSubstep>>,
          TError,
          Awaited<ReturnType<typeof getNextSubstep>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNextSubstepInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNextSubstep>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햫햟혜혝혞햫햦햧 혰햢햣혝햟
 */

export function useGetNextSubstepInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNextSubstep>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNextSubstepInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetNextSubstepQueryOptions = <TData = Awaited<ReturnType<typeof getNextSubstep>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNextSubstepQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNextSubstep>>> = ({ signal }) => getNextSubstep(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNextSubstepQueryResult = NonNullable<Awaited<ReturnType<typeof getNextSubstep>>>
export type GetNextSubstepQueryError = ErrorResponse


export function useGetNextSubstep<TData = Awaited<ReturnType<typeof getNextSubstep>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNextSubstep>>,
          TError,
          Awaited<ReturnType<typeof getNextSubstep>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNextSubstep<TData = Awaited<ReturnType<typeof getNextSubstep>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNextSubstep>>,
          TError,
          Awaited<ReturnType<typeof getNextSubstep>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNextSubstep<TData = Awaited<ReturnType<typeof getNextSubstep>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햫햟혜혝혞햫햦햧 혰햢햣혝햟
 */

export function useGetNextSubstep<TData = Awaited<ReturnType<typeof getNextSubstep>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNextSubstepQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햟햟햪햣혝혰 쒫쟳쥃쮏쫧썛쫧쫨
 */
export const isExecutionParamsReady = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/execution-params/ready`, method: 'GET', signal
    },
      options);
    }
  

export const getIsExecutionParamsReadyQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/execution-params/ready`] as const;
    }

    
export const getIsExecutionParamsReadyInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof isExecutionParamsReady>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsExecutionParamsReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isExecutionParamsReady>>> = ({ signal }) => isExecutionParamsReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsExecutionParamsReadyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof isExecutionParamsReady>>>
export type IsExecutionParamsReadyInfiniteQueryError = ErrorResponse


export function useIsExecutionParamsReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isExecutionParamsReady>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isExecutionParamsReady>>,
          TError,
          Awaited<ReturnType<typeof isExecutionParamsReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsExecutionParamsReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isExecutionParamsReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isExecutionParamsReady>>,
          TError,
          Awaited<ReturnType<typeof isExecutionParamsReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsExecutionParamsReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isExecutionParamsReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햟햟햪햣혝혰 쒫쟳쥃쮏쫧썛쫧쫨
 */

export function useIsExecutionParamsReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isExecutionParamsReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsExecutionParamsReadyInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getIsExecutionParamsReadyQueryOptions = <TData = Awaited<ReturnType<typeof isExecutionParamsReady>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsExecutionParamsReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isExecutionParamsReady>>> = ({ signal }) => isExecutionParamsReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsExecutionParamsReadyQueryResult = NonNullable<Awaited<ReturnType<typeof isExecutionParamsReady>>>
export type IsExecutionParamsReadyQueryError = ErrorResponse


export function useIsExecutionParamsReady<TData = Awaited<ReturnType<typeof isExecutionParamsReady>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isExecutionParamsReady>>,
          TError,
          Awaited<ReturnType<typeof isExecutionParamsReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsExecutionParamsReady<TData = Awaited<ReturnType<typeof isExecutionParamsReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isExecutionParamsReady>>,
          TError,
          Awaited<ReturnType<typeof isExecutionParamsReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsExecutionParamsReady<TData = Awaited<ReturnType<typeof isExecutionParamsReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햟햟햪햣혝혰 쒫쟳쥃쮏쫧썛쫧쫨
 */

export function useIsExecutionParamsReady<TData = Awaited<ReturnType<typeof isExecutionParamsReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsExecutionParamsReadyQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햨쮏쫨혰햡혞햟혡혰혱 향햫햦햤쮏
 */
export const isDiscountConfigReady = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/discount-config/ready`, method: 'GET', signal
    },
      options);
    }
  

export const getIsDiscountConfigReadyQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/discount-config/ready`] as const;
    }

    
export const getIsDiscountConfigReadyInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof isDiscountConfigReady>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsDiscountConfigReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isDiscountConfigReady>>> = ({ signal }) => isDiscountConfigReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsDiscountConfigReadyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof isDiscountConfigReady>>>
export type IsDiscountConfigReadyInfiniteQueryError = ErrorResponse


export function useIsDiscountConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isDiscountConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isDiscountConfigReady>>,
          TError,
          Awaited<ReturnType<typeof isDiscountConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsDiscountConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isDiscountConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isDiscountConfigReady>>,
          TError,
          Awaited<ReturnType<typeof isDiscountConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsDiscountConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isDiscountConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햨쮏쫨혰햡혞햟혡혰혱 향햫햦햤쮏
 */

export function useIsDiscountConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isDiscountConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsDiscountConfigReadyInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getIsDiscountConfigReadyQueryOptions = <TData = Awaited<ReturnType<typeof isDiscountConfigReady>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsDiscountConfigReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isDiscountConfigReady>>> = ({ signal }) => isDiscountConfigReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsDiscountConfigReadyQueryResult = NonNullable<Awaited<ReturnType<typeof isDiscountConfigReady>>>
export type IsDiscountConfigReadyQueryError = ErrorResponse


export function useIsDiscountConfigReady<TData = Awaited<ReturnType<typeof isDiscountConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isDiscountConfigReady>>,
          TError,
          Awaited<ReturnType<typeof isDiscountConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsDiscountConfigReady<TData = Awaited<ReturnType<typeof isDiscountConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isDiscountConfigReady>>,
          TError,
          Awaited<ReturnType<typeof isDiscountConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsDiscountConfigReady<TData = Awaited<ReturnType<typeof isDiscountConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햨쮏쫨혰햡혞햟혡혰혱 향햫햦햤쮏
 */

export function useIsDiscountConfigReady<TData = Awaited<ReturnType<typeof isDiscountConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsDiscountConfigReadyQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햨쮏쫨햣햨혜혝 혜햣혜혰혱
 */
export const getSessionContext1 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage3Context>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/context`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSessionContext1QueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/context`] as const;
    }

    
export const getGetSessionContext1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSessionContext1>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionContext1QueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionContext1>>> = ({ signal }) => getSessionContext1(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionContext1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionContext1>>>
export type GetSessionContext1InfiniteQueryError = ErrorResponse


export function useGetSessionContext1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionContext1>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionContext1>>,
          TError,
          Awaited<ReturnType<typeof getSessionContext1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionContext1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionContext1>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionContext1>>,
          TError,
          Awaited<ReturnType<typeof getSessionContext1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionContext1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionContext1>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨쮏쫨햣햨혜혝 혜햣혜혰혱
 */

export function useGetSessionContext1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionContext1>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionContext1InfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionContext1QueryOptions = <TData = Awaited<ReturnType<typeof getSessionContext1>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionContext1QueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionContext1>>> = ({ signal }) => getSessionContext1(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionContext1QueryResult = NonNullable<Awaited<ReturnType<typeof getSessionContext1>>>
export type GetSessionContext1QueryError = ErrorResponse


export function useGetSessionContext1<TData = Awaited<ReturnType<typeof getSessionContext1>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionContext1>>,
          TError,
          Awaited<ReturnType<typeof getSessionContext1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionContext1<TData = Awaited<ReturnType<typeof getSessionContext1>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionContext1>>,
          TError,
          Awaited<ReturnType<typeof getSessionContext1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionContext1<TData = Awaited<ReturnType<typeof getSessionContext1>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨쮏쫨햣햨혜혝 혜햣혜혰혱
 */

export function useGetSessionContext1<TData = Awaited<ReturnType<typeof getSessionContext1>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionContext1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionContext1QueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햢쮏얧썜햨쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */
export const isAdditionalInfoReady = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/additional-info/ready`, method: 'GET', signal
    },
      options);
    }
  

export const getIsAdditionalInfoReadyQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/additional-info/ready`] as const;
    }

    
export const getIsAdditionalInfoReadyInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof isAdditionalInfoReady>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsAdditionalInfoReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isAdditionalInfoReady>>> = ({ signal }) => isAdditionalInfoReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsAdditionalInfoReadyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof isAdditionalInfoReady>>>
export type IsAdditionalInfoReadyInfiniteQueryError = ErrorResponse


export function useIsAdditionalInfoReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isAdditionalInfoReady>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isAdditionalInfoReady>>,
          TError,
          Awaited<ReturnType<typeof isAdditionalInfoReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsAdditionalInfoReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isAdditionalInfoReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isAdditionalInfoReady>>,
          TError,
          Awaited<ReturnType<typeof isAdditionalInfoReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsAdditionalInfoReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isAdditionalInfoReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햢쮏얧썜햨쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */

export function useIsAdditionalInfoReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isAdditionalInfoReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsAdditionalInfoReadyInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getIsAdditionalInfoReadyQueryOptions = <TData = Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsAdditionalInfoReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isAdditionalInfoReady>>> = ({ signal }) => isAdditionalInfoReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsAdditionalInfoReadyQueryResult = NonNullable<Awaited<ReturnType<typeof isAdditionalInfoReady>>>
export type IsAdditionalInfoReadyQueryError = ErrorResponse


export function useIsAdditionalInfoReady<TData = Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isAdditionalInfoReady>>,
          TError,
          Awaited<ReturnType<typeof isAdditionalInfoReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsAdditionalInfoReady<TData = Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isAdditionalInfoReady>>,
          TError,
          Awaited<ReturnType<typeof isAdditionalInfoReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsAdditionalInfoReady<TData = Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 햡쮐쮏쒫쫨뒘혝혧 햢쮏얧썜햨쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */

export function useIsAdditionalInfoReady<TData = Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsAdditionalInfoReadyQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뉋썛혰햢혞혮 쮐쮐햫햦햧 혜혝햟햫 햪햣햫햣햢햤햣햟
 */
export const validateCurrentState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/validate/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getValidateCurrentStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/validate/${sessionId}`] as const;
    }

    
export const getValidateCurrentStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof validateCurrentState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateCurrentState>>> = ({ signal }) => validateCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidateCurrentStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof validateCurrentState>>>
export type ValidateCurrentStateInfiniteQueryError = ErrorResponse


export function useValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof validateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof validateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뉋썛혰햢혞혮 쮐쮐햫햦햧 혜혝햟햫 햪햣햫햣햢햤햣햟
 */

export function useValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidateCurrentStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getValidateCurrentStateQueryOptions = <TData = Awaited<ReturnType<typeof validateCurrentState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateCurrentState>>> = ({ signal }) => validateCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidateCurrentStateQueryResult = NonNullable<Awaited<ReturnType<typeof validateCurrentState>>>
export type ValidateCurrentStateQueryError = ErrorResponse


export function useValidateCurrentState<TData = Awaited<ReturnType<typeof validateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof validateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateCurrentState<TData = Awaited<ReturnType<typeof validateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof validateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateCurrentState<TData = Awaited<ReturnType<typeof validateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뉋썛혰햢혞혮 쮐쮐햫햦햧 혜혝햟햫 햪햣햫햣햢햤햣햟
 */

export function useValidateCurrentState<TData = Awaited<ReturnType<typeof validateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidateCurrentStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 혜혝햟혝혞혜혞 혟쮐쮏얧쮏쥄햪햣햫혝햟혡혰혱
 */
export const getDocumentationStatus = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}/status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDocumentationStatusQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep5/${sessionId}/status`] as const;
    }

    
export const getGetDocumentationStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDocumentationStatus>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentationStatusQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentationStatus>>> = ({ signal }) => getDocumentationStatus(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentationStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentationStatus>>>
export type GetDocumentationStatusInfiniteQueryError = ErrorResponse


export function useGetDocumentationStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDocumentationStatus>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentationStatus>>,
          TError,
          Awaited<ReturnType<typeof getDocumentationStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentationStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDocumentationStatus>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentationStatus>>,
          TError,
          Awaited<ReturnType<typeof getDocumentationStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentationStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDocumentationStatus>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 혜혝햟혝혞혜혞 혟쮐쮏얧쮏쥄햪햣햫혝햟혡혰혱
 */

export function useGetDocumentationStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDocumentationStatus>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentationStatusInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDocumentationStatusQueryOptions = <TData = Awaited<ReturnType<typeof getDocumentationStatus>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentationStatusQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentationStatus>>> = ({ signal }) => getDocumentationStatus(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentationStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentationStatus>>>
export type GetDocumentationStatusQueryError = ErrorResponse


export function useGetDocumentationStatus<TData = Awaited<ReturnType<typeof getDocumentationStatus>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentationStatus>>,
          TError,
          Awaited<ReturnType<typeof getDocumentationStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentationStatus<TData = Awaited<ReturnType<typeof getDocumentationStatus>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentationStatus>>,
          TError,
          Awaited<ReturnType<typeof getDocumentationStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentationStatus<TData = Awaited<ReturnType<typeof getDocumentationStatus>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 혜혝햟혝혞혜혞 혟쮐쮏얧쮏쥄햪햣햫혝햟혡혰혱
 */

export function useGetDocumentationStatus<TData = Awaited<ReturnType<typeof getDocumentationStatus>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentationStatusQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 햢햟햫햦혠 혟쮐쮏얧쮏쥄햪햣햫혝햟혡혰혱
 */
export const getDocumentationData = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PhotoDocumentationDTO>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}/data`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDocumentationDataQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep5/${sessionId}/data`] as const;
    }

    
export const getGetDocumentationDataInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDocumentationData>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentationDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentationData>>> = ({ signal }) => getDocumentationData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentationDataInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentationData>>>
export type GetDocumentationDataInfiniteQueryError = ErrorResponse


export function useGetDocumentationDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDocumentationData>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentationData>>,
          TError,
          Awaited<ReturnType<typeof getDocumentationData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentationDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDocumentationData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentationData>>,
          TError,
          Awaited<ReturnType<typeof getDocumentationData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentationDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDocumentationData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢햟햫햦혠 혟쮐쮏얧쮏쥄햪햣햫혝햟혡혰혱
 */

export function useGetDocumentationDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDocumentationData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentationDataInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDocumentationDataQueryOptions = <TData = Awaited<ReturnType<typeof getDocumentationData>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentationDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentationData>>> = ({ signal }) => getDocumentationData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentationDataQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentationData>>>
export type GetDocumentationDataQueryError = ErrorResponse


export function useGetDocumentationData<TData = Awaited<ReturnType<typeof getDocumentationData>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentationData>>,
          TError,
          Awaited<ReturnType<typeof getDocumentationData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentationData<TData = Awaited<ReturnType<typeof getDocumentationData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentationData>>,
          TError,
          Awaited<ReturnType<typeof getDocumentationData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentationData<TData = Awaited<ReturnType<typeof getDocumentationData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢햟햫햦혠 혟쮐쮏얧쮏쥄햪햣햫혝햟혡혰혱
 */

export function useGetDocumentationData<TData = Awaited<ReturnType<typeof getDocumentationData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentationDataQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뉋썛혰햢햟혡혰혪 쮐쮐햫쮏 혜혝햟햫혞
 */
export const validateCurrentState1 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage2/substep4/validate/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getValidateCurrentState1QueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/validate/${sessionId}`] as const;
    }

    
export const getValidateCurrentState1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof validateCurrentState1>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateCurrentState1QueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateCurrentState1>>> = ({ signal }) => validateCurrentState1(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidateCurrentState1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof validateCurrentState1>>>
export type ValidateCurrentState1InfiniteQueryError = ErrorResponse


export function useValidateCurrentState1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof validateCurrentState1>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateCurrentState1>>,
          TError,
          Awaited<ReturnType<typeof validateCurrentState1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateCurrentState1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof validateCurrentState1>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateCurrentState1>>,
          TError,
          Awaited<ReturnType<typeof validateCurrentState1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateCurrentState1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof validateCurrentState1>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뉋썛혰햢햟혡혰혪 쮐쮐햫쮏 혜혝햟햫혞
 */

export function useValidateCurrentState1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof validateCurrentState1>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidateCurrentState1InfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getValidateCurrentState1QueryOptions = <TData = Awaited<ReturnType<typeof validateCurrentState1>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateCurrentState1QueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateCurrentState1>>> = ({ signal }) => validateCurrentState1(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidateCurrentState1QueryResult = NonNullable<Awaited<ReturnType<typeof validateCurrentState1>>>
export type ValidateCurrentState1QueryError = ErrorResponse


export function useValidateCurrentState1<TData = Awaited<ReturnType<typeof validateCurrentState1>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateCurrentState1>>,
          TError,
          Awaited<ReturnType<typeof validateCurrentState1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateCurrentState1<TData = Awaited<ReturnType<typeof validateCurrentState1>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateCurrentState1>>,
          TError,
          Awaited<ReturnType<typeof validateCurrentState1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateCurrentState1<TData = Awaited<ReturnType<typeof validateCurrentState1>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뉋썛혰햢햟혡혰혪 쮐쮐햫쮏 혜혝햟햫혞
 */

export function useValidateCurrentState1<TData = Awaited<ReturnType<typeof validateCurrentState1>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidateCurrentState1QueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햆햣혝햟햩혧햫햟 쒫썛혰햢햟혡혰혪 향 햣향혞햩혧혝햟혝쮏
 */
export const validateDetailed = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/validate-detailed/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getValidateDetailedQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/validate-detailed/${sessionId}`] as const;
    }

    
export const getValidateDetailedInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof validateDetailed>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateDetailedQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateDetailed>>> = ({ signal }) => validateDetailed(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidateDetailedInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof validateDetailed>>>
export type ValidateDetailedInfiniteQueryError = ErrorResponse


export function useValidateDetailedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateDetailed>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateDetailed>>,
          TError,
          Awaited<ReturnType<typeof validateDetailed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateDetailedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateDetailed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateDetailed>>,
          TError,
          Awaited<ReturnType<typeof validateDetailed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateDetailedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateDetailed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햆햣혝햟햩혧햫햟 쒫썛혰햢햟혡혰혪 향 햣향혞햩혧혝햟혝쮏
 */

export function useValidateDetailedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof validateDetailed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidateDetailedInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getValidateDetailedQueryOptions = <TData = Awaited<ReturnType<typeof validateDetailed>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateDetailedQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateDetailed>>> = ({ signal }) => validateDetailed(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidateDetailedQueryResult = NonNullable<Awaited<ReturnType<typeof validateDetailed>>>
export type ValidateDetailedQueryError = ErrorResponse


export function useValidateDetailed<TData = Awaited<ReturnType<typeof validateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateDetailed>>,
          TError,
          Awaited<ReturnType<typeof validateDetailed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateDetailed<TData = Awaited<ReturnType<typeof validateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateDetailed>>,
          TError,
          Awaited<ReturnType<typeof validateDetailed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateDetailed<TData = Awaited<ReturnType<typeof validateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햆햣혝햟햩혧햫햟 쒫썛혰햢햟혡혰혪 향 햣향혞햩혧혝햟혝쮏
 */

export function useValidateDetailed<TData = Awaited<ReturnType<typeof validateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidateDetailedQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 혜혝햟햫혞 혰햢햣혝햟혞
 */
export const getCurrentState1 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/state/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCurrentState1QueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/state/${sessionId}`] as const;
    }

    
export const getGetCurrentState1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState1>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentState1QueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentState1>>> = ({ signal }) => getCurrentState1(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentState1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentState1>>>
export type GetCurrentState1InfiniteQueryError = ErrorResponse


export function useGetCurrentState1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState1>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState1>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentState1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState1>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState1>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentState1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState1>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 혜혝햟햫혞 혰햢햣혝햟혞
 */

export function useGetCurrentState1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState1>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentState1InfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentState1QueryOptions = <TData = Awaited<ReturnType<typeof getCurrentState1>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentState1QueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentState1>>> = ({ signal }) => getCurrentState1(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentState1QueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentState1>>>
export type GetCurrentState1QueryError = ErrorResponse


export function useGetCurrentState1<TData = Awaited<ReturnType<typeof getCurrentState1>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState1>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentState1<TData = Awaited<ReturnType<typeof getCurrentState1>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState1>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentState1<TData = Awaited<ReturnType<typeof getCurrentState1>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 혜혝햟햫혞 혰햢햣혝햟혞
 */

export function useGetCurrentState1<TData = Awaited<ReturnType<typeof getCurrentState1>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentState1QueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햣햣쒬뒘햨햟 혰혜햫혞쒫썛쫧쫨 혜햣혜혰혱
 */
export const sessionExists = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage2/substep4/session/${sessionId}/exists`, method: 'GET', signal
    },
      options);
    }
  

export const getSessionExistsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/session/${sessionId}/exists`] as const;
    }

    
export const getSessionExistsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof sessionExists>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSessionExistsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionExists>>> = ({ signal }) => sessionExists(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SessionExistsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof sessionExists>>>
export type SessionExistsInfiniteQueryError = ErrorResponse


export function useSessionExistsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof sessionExists>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionExists>>,
          TError,
          Awaited<ReturnType<typeof sessionExists>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSessionExistsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof sessionExists>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionExists>>,
          TError,
          Awaited<ReturnType<typeof sessionExists>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSessionExistsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof sessionExists>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햨햟 혰혜햫혞쒫썛쫧쫨 혜햣혜혰혱
 */

export function useSessionExistsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof sessionExists>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSessionExistsInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSessionExistsQueryOptions = <TData = Awaited<ReturnType<typeof sessionExists>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSessionExistsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionExists>>> = ({ signal }) => sessionExists(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SessionExistsQueryResult = NonNullable<Awaited<ReturnType<typeof sessionExists>>>
export type SessionExistsQueryError = ErrorResponse


export function useSessionExists<TData = Awaited<ReturnType<typeof sessionExists>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionExists>>,
          TError,
          Awaited<ReturnType<typeof sessionExists>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSessionExists<TData = Awaited<ReturnType<typeof sessionExists>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionExists>>,
          TError,
          Awaited<ReturnType<typeof sessionExists>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSessionExists<TData = Awaited<ReturnType<typeof sessionExists>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햨햟 혰혜햫혞쒫썛쫧쫨 혜햣혜혰혱
 */

export function useSessionExists<TData = Awaited<ReturnType<typeof sessionExists>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSessionExistsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 햪쮏얧쟴혰햨햟혝쮐혰 햢햩혪 햨햟혝햣햡쮐혰혱
 */
export const getAvailableModifiers = (
    params: GetAvailableModifiersParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceModifierDTO[]>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAvailableModifiersQueryKey = (params: GetAvailableModifiersParams,) => {
    return [`/v1/order-wizard/stage2/substep4/modifiers`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAvailableModifiersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiers>>>, TError = ErrorResponse>(params: GetAvailableModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableModifiers>>> = ({ signal }) => getAvailableModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableModifiersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableModifiers>>>
export type GetAvailableModifiersInfiniteQueryError = ErrorResponse


export function useGetAvailableModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiers>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiers>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiers>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 햪쮏얧쟴혰햨햟혝쮐혰 햢햩혪 햨햟혝햣햡쮐혰혱
 */

export function useGetAvailableModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiers>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableModifiersInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableModifiersQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableModifiers>>, TError = ErrorResponse>(params: GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableModifiers>>> = ({ signal }) => getAvailableModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableModifiers>>>
export type GetAvailableModifiersQueryError = ErrorResponse


export function useGetAvailableModifiers<TData = Awaited<ReturnType<typeof getAvailableModifiers>>, TError = ErrorResponse>(
 params: GetAvailableModifiersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiers<TData = Awaited<ReturnType<typeof getAvailableModifiers>>, TError = ErrorResponse>(
 params: GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiers<TData = Awaited<ReturnType<typeof getAvailableModifiers>>, TError = ErrorResponse>(
 params: GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 햪쮏얧쟴혰햨햟혝쮐혰 햢햩혪 햨햟혝햣햡쮐혰혱
 */

export function useGetAvailableModifiers<TData = Awaited<ReturnType<typeof getAvailableModifiers>>, TError = ErrorResponse>(
 params: GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableModifiersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 햣햨쮏쨿왏쫧얧쮏쒫썛쫧쟴 햪쮏얧쟴혰햨햟혝쮐혰
 */
export const getRecommendedModifiers = (
    params: GetRecommendedModifiersParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceModifierDTO[]>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers/recommended`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedModifiersQueryKey = (params: GetRecommendedModifiersParams,) => {
    return [`/v1/order-wizard/stage2/substep4/modifiers/recommended`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedModifiersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers>>>, TError = ErrorResponse>(params: GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiers>>> = ({ signal }) => getRecommendedModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiers>>>
export type GetRecommendedModifiersInfiniteQueryError = ErrorResponse


export function useGetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햣햨쮏쨿왏쫧얧쮏쒫썛쫧쟴 햪쮏얧쟴혰햨햟혝쮐혰
 */

export function useGetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedModifiersQueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedModifiers>>, TError = ErrorResponse>(params: GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiers>>> = ({ signal }) => getRecommendedModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiers>>>
export type GetRecommendedModifiersQueryError = ErrorResponse


export function useGetRecommendedModifiers<TData = Awaited<ReturnType<typeof getRecommendedModifiers>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiers<TData = Awaited<ReturnType<typeof getRecommendedModifiers>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiers<TData = Awaited<ReturnType<typeof getRecommendedModifiers>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햣햨쮏쨿왏쫧얧쮏쒫썛쫧쟴 햪쮏얧쟴혰햨햟혝쮐혰
 */

export function useGetRecommendedModifiers<TData = Awaited<ReturnType<typeof getRecommendedModifiers>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 쮏얨뒗 햢햩혪 쮐쮐햫쮏 혜혝햟햫혞
 */
export const getAvailableEvents = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAvailableEvents200Item[]>(
      {url: `/v1/order-wizard/stage2/substep4/events/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAvailableEventsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/events/${sessionId}`] as const;
    }

    
export const getGetAvailableEventsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableEvents>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableEventsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableEvents>>> = ({ signal }) => getAvailableEvents(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableEventsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableEvents>>>
export type GetAvailableEventsInfiniteQueryError = ErrorResponse


export function useGetAvailableEventsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableEvents>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableEvents>>,
          TError,
          Awaited<ReturnType<typeof getAvailableEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableEventsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableEvents>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableEvents>>,
          TError,
          Awaited<ReturnType<typeof getAvailableEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableEventsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableEvents>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 쮏얨뒗 햢햩혪 쮐쮐햫쮏 혜혝햟햫혞
 */

export function useGetAvailableEventsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableEvents>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableEventsInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableEventsQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableEvents>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableEventsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableEvents>>> = ({ signal }) => getAvailableEvents(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableEventsQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableEvents>>>
export type GetAvailableEventsQueryError = ErrorResponse


export function useGetAvailableEvents<TData = Awaited<ReturnType<typeof getAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableEvents>>,
          TError,
          Awaited<ReturnType<typeof getAvailableEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableEvents<TData = Awaited<ReturnType<typeof getAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableEvents>>,
          TError,
          Awaited<ReturnType<typeof getAvailableEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableEvents<TData = Awaited<ReturnType<typeof getAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 쮏얨뒗 햢햩혪 쮐쮐햫쮏 혜혝햟햫혞
 */

export function useGetAvailableEvents<TData = Awaited<ReturnType<typeof getAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableEventsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫햦혠 햢햟햫햦혠 혜햣혜혰혱
 */
export const getCurrentData = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceDiscountDTO>(
      {url: `/v1/order-wizard/stage2/substep4/data/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCurrentDataQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/data/${sessionId}`] as const;
    }

    
export const getGetCurrentDataInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentData>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentData>>> = ({ signal }) => getCurrentData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentDataInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentData>>>
export type GetCurrentDataInfiniteQueryError = ErrorResponse


export function useGetCurrentDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentData>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentData>>,
          TError,
          Awaited<ReturnType<typeof getCurrentData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentData>>,
          TError,
          Awaited<ReturnType<typeof getCurrentData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫햦혠 햢햟햫햦혠 혜햣혜혰혱
 */

export function useGetCurrentDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentDataInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentDataQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentData>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentData>>> = ({ signal }) => getCurrentData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentDataQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentData>>>
export type GetCurrentDataQueryError = ErrorResponse


export function useGetCurrentData<TData = Awaited<ReturnType<typeof getCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentData>>,
          TError,
          Awaited<ReturnType<typeof getCurrentData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentData<TData = Awaited<ReturnType<typeof getCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentData>>,
          TError,
          Awaited<ReturnType<typeof getCurrentData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentData<TData = Awaited<ReturnType<typeof getCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫햦혠 햢햟햫햦혠 혜햣혜혰혱
 */

export function useGetCurrentData<TData = Awaited<ReturnType<typeof getCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentDataQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 혝햦혰 햩혪햪
 */
export const getAvailableStainTypes = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/v1/order-wizard/stage2/substep3/stain-types`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAvailableStainTypesQueryKey = () => {
    return [`/v1/order-wizard/stage2/substep3/stain-types`] as const;
    }

    
export const getGetAvailableStainTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableStainTypes>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableStainTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableStainTypes>>> = ({ signal }) => getAvailableStainTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableStainTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableStainTypes>>>
export type GetAvailableStainTypesInfiniteQueryError = ErrorResponse


export function useGetAvailableStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableStainTypes>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getAvailableStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableStainTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getAvailableStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableStainTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 혝햦혰 햩혪햪
 */

export function useGetAvailableStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableStainTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableStainTypesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableStainTypesQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableStainTypes>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableStainTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableStainTypes>>> = ({ signal }) => getAvailableStainTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableStainTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableStainTypes>>>
export type GetAvailableStainTypesQueryError = ErrorResponse


export function useGetAvailableStainTypes<TData = Awaited<ReturnType<typeof getAvailableStainTypes>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getAvailableStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableStainTypes<TData = Awaited<ReturnType<typeof getAvailableStainTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getAvailableStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableStainTypes<TData = Awaited<ReturnType<typeof getAvailableStainTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 혝햦혰 햩혪햪
 */

export function useGetAvailableStainTypes<TData = Awaited<ReturnType<typeof getAvailableStainTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableStainTypesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 혝햦혰 햢햣혟햣햨혝혰
 */
export const getAvailableDefectTypes = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/v1/order-wizard/stage2/substep3/defect-types`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAvailableDefectTypesQueryKey = () => {
    return [`/v1/order-wizard/stage2/substep3/defect-types`] as const;
    }

    
export const getGetAvailableDefectTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableDefectTypes>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableDefectTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableDefectTypes>>> = ({ signal }) => getAvailableDefectTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableDefectTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableDefectTypes>>>
export type GetAvailableDefectTypesInfiniteQueryError = ErrorResponse


export function useGetAvailableDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableDefectTypes>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getAvailableDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableDefectTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getAvailableDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableDefectTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 혝햦혰 햢햣혟햣햨혝혰
 */

export function useGetAvailableDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableDefectTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableDefectTypesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableDefectTypesQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableDefectTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableDefectTypes>>> = ({ signal }) => getAvailableDefectTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableDefectTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableDefectTypes>>>
export type GetAvailableDefectTypesQueryError = ErrorResponse


export function useGetAvailableDefectTypes<TData = Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getAvailableDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableDefectTypes<TData = Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getAvailableDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableDefectTypes<TData = Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 햢쮐혝혞햫햦혠 혝햦혰 햢햣혟햣햨혝혰
 */

export function useGetAvailableDefectTypes<TData = Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableDefectTypesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 햨쮏쫨햣햨혜혝혞
 */
export const getContext = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/context/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetContextQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep3/context/${sessionId}`] as const;
    }

    
export const getGetContextInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getContext>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetContextQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getContext>>> = ({ signal }) => getContext(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetContextInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getContext>>>
export type GetContextInfiniteQueryError = ErrorResponse


export function useGetContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getContext>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContext>>,
          TError,
          Awaited<ReturnType<typeof getContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContext>>,
          TError,
          Awaited<ReturnType<typeof getContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 햨쮏쫨햣햨혜혝혞
 */

export function useGetContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetContextInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetContextQueryOptions = <TData = Awaited<ReturnType<typeof getContext>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetContextQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getContext>>> = ({ signal }) => getContext(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetContextQueryResult = NonNullable<Awaited<ReturnType<typeof getContext>>>
export type GetContextQueryError = ErrorResponse


export function useGetContext<TData = Awaited<ReturnType<typeof getContext>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContext>>,
          TError,
          Awaited<ReturnType<typeof getContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetContext<TData = Awaited<ReturnType<typeof getContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContext>>,
          TError,
          Awaited<ReturnType<typeof getContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetContext<TData = Awaited<ReturnType<typeof getContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟햫햫혪 쮐쮐햫쮏 햨쮏쫨햣햨혜혝혞
 */

export function useGetContext<TData = Awaited<ReturnType<typeof getContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetContextQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 혜햦혜쮏 햢쮐혝혞햫햦혠 햪햟혝햣혰햟햩혰
 */
export const getAvailableMaterials = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/v1/order-wizard/stage2/substep2/materials/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAvailableMaterialsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep2/materials/${sessionId}`] as const;
    }

    
export const getGetAvailableMaterialsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableMaterials>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableMaterialsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableMaterials>>> = ({ signal }) => getAvailableMaterials(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableMaterialsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableMaterials>>>
export type GetAvailableMaterialsInfiniteQueryError = ErrorResponse


export function useGetAvailableMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableMaterials>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableMaterials>>,
          TError,
          Awaited<ReturnType<typeof getAvailableMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableMaterials>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableMaterials>>,
          TError,
          Awaited<ReturnType<typeof getAvailableMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableMaterials>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 혜햦혜쮏 햢쮐혝혞햫햦혠 햪햟혝햣혰햟햩혰
 */

export function useGetAvailableMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableMaterials>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableMaterialsInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableMaterialsQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableMaterials>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableMaterialsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableMaterials>>> = ({ signal }) => getAvailableMaterials(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableMaterialsQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableMaterials>>>
export type GetAvailableMaterialsQueryError = ErrorResponse


export function useGetAvailableMaterials<TData = Awaited<ReturnType<typeof getAvailableMaterials>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableMaterials>>,
          TError,
          Awaited<ReturnType<typeof getAvailableMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableMaterials<TData = Awaited<ReturnType<typeof getAvailableMaterials>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableMaterials>>,
          TError,
          Awaited<ReturnType<typeof getAvailableMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableMaterials<TData = Awaited<ReturnType<typeof getAvailableMaterials>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 혜햦혜쮏 햢쮐혝혞햫햦혠 햪햟혝햣혰햟햩혰
 */

export function useGetAvailableMaterials<TData = Awaited<ReturnType<typeof getAvailableMaterials>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableMaterialsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혰햢햣혝햟혞 2
 */
export const getCurrentCharacteristics = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemCharacteristicsDTO>(
      {url: `/v1/order-wizard/stage2/substep2/current-state/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCurrentCharacteristicsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep2/current-state/${sessionId}`] as const;
    }

    
export const getGetCurrentCharacteristicsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentCharacteristics>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentCharacteristicsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentCharacteristics>>> = ({ signal }) => getCurrentCharacteristics(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentCharacteristicsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentCharacteristics>>>
export type GetCurrentCharacteristicsInfiniteQueryError = ErrorResponse


export function useGetCurrentCharacteristicsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentCharacteristics>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentCharacteristics>>,
          TError,
          Awaited<ReturnType<typeof getCurrentCharacteristics>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentCharacteristicsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentCharacteristics>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentCharacteristics>>,
          TError,
          Awaited<ReturnType<typeof getCurrentCharacteristics>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentCharacteristicsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentCharacteristics>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혰햢햣혝햟혞 2
 */

export function useGetCurrentCharacteristicsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentCharacteristics>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentCharacteristicsInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentCharacteristicsQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentCharacteristicsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentCharacteristics>>> = ({ signal }) => getCurrentCharacteristics(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentCharacteristicsQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentCharacteristics>>>
export type GetCurrentCharacteristicsQueryError = ErrorResponse


export function useGetCurrentCharacteristics<TData = Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentCharacteristics>>,
          TError,
          Awaited<ReturnType<typeof getCurrentCharacteristics>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentCharacteristics<TData = Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentCharacteristics>>,
          TError,
          Awaited<ReturnType<typeof getCurrentCharacteristics>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentCharacteristics<TData = Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혰햢햣혝햟혞 2
 */

export function useGetCurrentCharacteristics<TData = Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentCharacteristicsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혰햢햣혝햟혞 1
 */
export const getSubstep1Status = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSubstep1StatusQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep1/${sessionId}/status`] as const;
    }

    
export const getGetSubstep1StatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSubstep1Status>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubstep1StatusQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubstep1Status>>> = ({ signal }) => getSubstep1Status(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubstep1StatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSubstep1Status>>>
export type GetSubstep1StatusInfiniteQueryError = ErrorResponse


export function useGetSubstep1StatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubstep1Status>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubstep1Status>>,
          TError,
          Awaited<ReturnType<typeof getSubstep1Status>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubstep1StatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubstep1Status>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubstep1Status>>,
          TError,
          Awaited<ReturnType<typeof getSubstep1Status>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubstep1StatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubstep1Status>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혰햢햣혝햟혞 1
 */

export function useGetSubstep1StatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubstep1Status>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubstep1StatusInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubstep1StatusQueryOptions = <TData = Awaited<ReturnType<typeof getSubstep1Status>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubstep1StatusQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubstep1Status>>> = ({ signal }) => getSubstep1Status(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubstep1StatusQueryResult = NonNullable<Awaited<ReturnType<typeof getSubstep1Status>>>
export type GetSubstep1StatusQueryError = ErrorResponse


export function useGetSubstep1Status<TData = Awaited<ReturnType<typeof getSubstep1Status>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubstep1Status>>,
          TError,
          Awaited<ReturnType<typeof getSubstep1Status>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubstep1Status<TData = Awaited<ReturnType<typeof getSubstep1Status>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubstep1Status>>,
          TError,
          Awaited<ReturnType<typeof getSubstep1Status>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubstep1Status<TData = Awaited<ReturnType<typeof getSubstep1Status>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혰햢햣혝햟혞 1
 */

export function useGetSubstep1Status<TData = Awaited<ReturnType<typeof getSubstep1Status>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubstep1Status>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubstep1StatusQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 혜햦혜쮏 햢쮐혝혞햫햦혠 햨햟혝햣햡쮐혰햧 쮐햩혞햡
 */
export const getServiceCategories = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ServiceCategoryDTO[]>(
      {url: `/v1/order-wizard/stage2/substep1/service-categories`, method: 'GET', signal
    },
      options);
    }
  

export const getGetServiceCategoriesQueryKey = () => {
    return [`/v1/order-wizard/stage2/substep1/service-categories`] as const;
    }

    
export const getGetServiceCategoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getServiceCategories>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceCategories>>> = ({ signal }) => getServiceCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetServiceCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceCategories>>>
export type GetServiceCategoriesInfiniteQueryError = ErrorResponse


export function useGetServiceCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getServiceCategories>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCategories>>,
          TError,
          Awaited<ReturnType<typeof getServiceCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetServiceCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getServiceCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCategories>>,
          TError,
          Awaited<ReturnType<typeof getServiceCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetServiceCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getServiceCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 혜햦혜쮏 햢쮐혝혞햫햦혠 햨햟혝햣햡쮐혰햧 쮐햩혞햡
 */

export function useGetServiceCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getServiceCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetServiceCategoriesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getServiceCategories>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceCategories>>> = ({ signal }) => getServiceCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetServiceCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceCategories>>>
export type GetServiceCategoriesQueryError = ErrorResponse


export function useGetServiceCategories<TData = Awaited<ReturnType<typeof getServiceCategories>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCategories>>,
          TError,
          Awaited<ReturnType<typeof getServiceCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetServiceCategories<TData = Awaited<ReturnType<typeof getServiceCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCategories>>,
          TError,
          Awaited<ReturnType<typeof getServiceCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetServiceCategories<TData = Awaited<ReturnType<typeof getServiceCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 혜햦혜쮏 햢쮐혝혞햫햦혠 햨햟혝햣햡쮐혰햧 쮐햩혞햡
 */

export function useGetServiceCategories<TData = Awaited<ReturnType<typeof getServiceCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetServiceCategoriesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 혜햦혜쮏 햣햢햪햣혝혰 햢햩혪 햨햟혝햣햡쮐혰혱
 */
export const getItemsForCategory = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceListItemDTO[]>(
      {url: `/v1/order-wizard/stage2/substep1/categories/${categoryId}/items`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemsForCategoryQueryKey = (categoryId: string,) => {
    return [`/v1/order-wizard/stage2/substep1/categories/${categoryId}/items`] as const;
    }

    
export const getGetItemsForCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemsForCategory>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsForCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsForCategory>>> = ({ signal }) => getItemsForCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsForCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsForCategory>>>
export type GetItemsForCategoryInfiniteQueryError = ErrorResponse


export function useGetItemsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 혜햦혜쮏 햣햢햪햣혝혰 햢햩혪 햨햟혝햣햡쮐혰혱
 */

export function useGetItemsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsForCategoryInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemsForCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getItemsForCategory>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsForCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsForCategory>>> = ({ signal }) => getItemsForCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsForCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsForCategory>>>
export type GetItemsForCategoryQueryError = ErrorResponse


export function useGetItemsForCategory<TData = Awaited<ReturnType<typeof getItemsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsForCategory<TData = Awaited<ReturnType<typeof getItemsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsForCategory<TData = Awaited<ReturnType<typeof getItemsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 혜햦혜쮏 햣햢햪햣혝혰 햢햩혪 햨햟혝햣햡쮐혰혱
 */

export function useGetItemsForCategory<TData = Awaited<ReturnType<typeof getItemsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsForCategoryQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혜햣혜혰혱
 */
export const getCurrentState2 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCurrentState2200>(
      {url: `/v1/order-wizard/stage2/state/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCurrentState2QueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/state/${sessionId}`] as const;
    }

    
export const getGetCurrentState2InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState2>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentState2QueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentState2>>> = ({ signal }) => getCurrentState2(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentState2InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentState2>>>
export type GetCurrentState2InfiniteQueryError = ErrorResponse


export function useGetCurrentState2Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState2>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState2>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentState2Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState2>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState2>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentState2Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState2>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혜햣혜혰혱
 */

export function useGetCurrentState2Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentState2>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentState2InfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentState2QueryOptions = <TData = Awaited<ReturnType<typeof getCurrentState2>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentState2QueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentState2>>> = ({ signal }) => getCurrentState2(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentState2QueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentState2>>>
export type GetCurrentState2QueryError = ErrorResponse


export function useGetCurrentState2<TData = Awaited<ReturnType<typeof getCurrentState2>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState2>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentState2<TData = Awaited<ReturnType<typeof getCurrentState2>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentState2>>,
          TError,
          Awaited<ReturnType<typeof getCurrentState2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentState2<TData = Awaited<ReturnType<typeof getCurrentState2>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혜햣혜혰혱
 */

export function useGetCurrentState2<TData = Awaited<ReturnType<typeof getCurrentState2>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentState2>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentState2QueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 햨혰햩혧햨혰혜혝혧 햟햨혝햦쒫쫧쟴 혜햣혜혰햧
 */
export const getActiveSessionCount = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<number>(
      {url: `/v1/order-wizard/stage2/sessions/count`, method: 'GET', signal
    },
      options);
    }
  

export const getGetActiveSessionCountQueryKey = () => {
    return [`/v1/order-wizard/stage2/sessions/count`] as const;
    }

    
export const getGetActiveSessionCountInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getActiveSessionCount>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveSessionCountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveSessionCount>>> = ({ signal }) => getActiveSessionCount(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveSessionCountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveSessionCount>>>
export type GetActiveSessionCountInfiniteQueryError = ErrorResponse


export function useGetActiveSessionCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveSessionCount>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveSessionCount>>,
          TError,
          Awaited<ReturnType<typeof getActiveSessionCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveSessionCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveSessionCount>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveSessionCount>>,
          TError,
          Awaited<ReturnType<typeof getActiveSessionCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveSessionCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveSessionCount>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 햨혰햩혧햨혰혜혝혧 햟햨혝햦쒫쫧쟴 혜햣혜혰햧
 */

export function useGetActiveSessionCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveSessionCount>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActiveSessionCountInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActiveSessionCountQueryOptions = <TData = Awaited<ReturnType<typeof getActiveSessionCount>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveSessionCountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveSessionCount>>> = ({ signal }) => getActiveSessionCount(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveSessionCountQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveSessionCount>>>
export type GetActiveSessionCountQueryError = ErrorResponse


export function useGetActiveSessionCount<TData = Awaited<ReturnType<typeof getActiveSessionCount>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveSessionCount>>,
          TError,
          Awaited<ReturnType<typeof getActiveSessionCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveSessionCount<TData = Awaited<ReturnType<typeof getActiveSessionCount>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveSessionCount>>,
          TError,
          Awaited<ReturnType<typeof getActiveSessionCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveSessionCount<TData = Awaited<ReturnType<typeof getActiveSessionCount>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 햨혰햩혧햨혰혜혝혧 햟햨혝햦쒫쫧쟴 혜햣혜혰햧
 */

export function useGetActiveSessionCount<TData = Awaited<ReturnType<typeof getActiveSessionCount>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActiveSessionCountQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햣햣쒬뒘혪혮 햡쮐쮏쒫쫨뒘혝혧 햢 햣햣혠쮏얨 햫햟 햫햟혜혝혞햫햦햧 햣혝햟
 */
export const checkReadinessToProceed = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage2/ready/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getCheckReadinessToProceedQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/ready/${sessionId}`] as const;
    }

    
export const getCheckReadinessToProceedInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof checkReadinessToProceed>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckReadinessToProceedQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkReadinessToProceed>>> = ({ signal }) => checkReadinessToProceed(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckReadinessToProceedInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof checkReadinessToProceed>>>
export type CheckReadinessToProceedInfiniteQueryError = ErrorResponse


export function useCheckReadinessToProceedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkReadinessToProceed>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkReadinessToProceed>>,
          TError,
          Awaited<ReturnType<typeof checkReadinessToProceed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckReadinessToProceedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkReadinessToProceed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkReadinessToProceed>>,
          TError,
          Awaited<ReturnType<typeof checkReadinessToProceed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckReadinessToProceedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkReadinessToProceed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘혪혮 햡쮐쮏쒫쫨뒘혝혧 햢 햣햣혠쮏얨 햫햟 햫햟혜혝혞햫햦햧 햣혝햟
 */

export function useCheckReadinessToProceedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof checkReadinessToProceed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckReadinessToProceedInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCheckReadinessToProceedQueryOptions = <TData = Awaited<ReturnType<typeof checkReadinessToProceed>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckReadinessToProceedQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkReadinessToProceed>>> = ({ signal }) => checkReadinessToProceed(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckReadinessToProceedQueryResult = NonNullable<Awaited<ReturnType<typeof checkReadinessToProceed>>>
export type CheckReadinessToProceedQueryError = ErrorResponse


export function useCheckReadinessToProceed<TData = Awaited<ReturnType<typeof checkReadinessToProceed>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkReadinessToProceed>>,
          TError,
          Awaited<ReturnType<typeof checkReadinessToProceed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckReadinessToProceed<TData = Awaited<ReturnType<typeof checkReadinessToProceed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkReadinessToProceed>>,
          TError,
          Awaited<ReturnType<typeof checkReadinessToProceed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckReadinessToProceed<TData = Awaited<ReturnType<typeof checkReadinessToProceed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘혪혮 햡쮐쮏쒫쫨뒘혝혧 햢 햣햣혠쮏얨 햫햟 햫햟혜혝혞햫햦햧 햣혝햟
 */

export function useCheckReadinessToProceed<TData = Awaited<ReturnType<typeof checkReadinessToProceed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckReadinessToProceedQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 햪햣햫햣햢햤햣햟 햣햢햪햣혝혰
 */
export const getCurrentManager = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/manager/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCurrentManagerQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/manager/${sessionId}`] as const;
    }

    
export const getGetCurrentManagerInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentManager>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentManagerQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentManager>>> = ({ signal }) => getCurrentManager(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentManagerInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentManager>>>
export type GetCurrentManagerInfiniteQueryError = ErrorResponse


export function useGetCurrentManagerInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentManager>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentManager>>,
          TError,
          Awaited<ReturnType<typeof getCurrentManager>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentManagerInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentManager>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentManager>>,
          TError,
          Awaited<ReturnType<typeof getCurrentManager>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentManagerInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentManager>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 햪햣햫햣햢햤햣햟 햣햢햪햣혝혰
 */

export function useGetCurrentManagerInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentManager>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentManagerInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentManagerQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentManager>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentManagerQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentManager>>> = ({ signal }) => getCurrentManager(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentManagerQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentManager>>>
export type GetCurrentManagerQueryError = ErrorResponse


export function useGetCurrentManager<TData = Awaited<ReturnType<typeof getCurrentManager>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentManager>>,
          TError,
          Awaited<ReturnType<typeof getCurrentManager>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentManager<TData = Awaited<ReturnType<typeof getCurrentManager>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentManager>>,
          TError,
          Awaited<ReturnType<typeof getCurrentManager>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentManager<TData = Awaited<ReturnType<typeof getCurrentManager>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 햪햣햫햣햢햤햣햟 햣햢햪햣혝혰
 */

export function useGetCurrentManager<TData = Awaited<ReturnType<typeof getCurrentManager>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentManagerQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혟쮐햪햦
 */
export const getNewClientFormState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetNewClientFormState200>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNewClientFormStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/new-client/session/${sessionId}/state`] as const;
    }

    
export const getGetNewClientFormStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getNewClientFormState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewClientFormStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewClientFormState>>> = ({ signal }) => getNewClientFormState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNewClientFormStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNewClientFormState>>>
export type GetNewClientFormStateInfiniteQueryError = ErrorResponse


export function useGetNewClientFormStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewClientFormState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewClientFormState>>,
          TError,
          Awaited<ReturnType<typeof getNewClientFormState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewClientFormStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewClientFormState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewClientFormState>>,
          TError,
          Awaited<ReturnType<typeof getNewClientFormState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewClientFormStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewClientFormState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혟쮐햪햦
 */

export function useGetNewClientFormStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewClientFormState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNewClientFormStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetNewClientFormStateQueryOptions = <TData = Awaited<ReturnType<typeof getNewClientFormState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewClientFormStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewClientFormState>>> = ({ signal }) => getNewClientFormState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNewClientFormStateQueryResult = NonNullable<Awaited<ReturnType<typeof getNewClientFormState>>>
export type GetNewClientFormStateQueryError = ErrorResponse


export function useGetNewClientFormState<TData = Awaited<ReturnType<typeof getNewClientFormState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewClientFormState>>,
          TError,
          Awaited<ReturnType<typeof getNewClientFormState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewClientFormState<TData = Awaited<ReturnType<typeof getNewClientFormState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewClientFormState>>,
          TError,
          Awaited<ReturnType<typeof getNewClientFormState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewClientFormState<TData = Awaited<ReturnType<typeof getNewClientFormState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 혟쮐햪햦
 */

export function useGetNewClientFormState<TData = Awaited<ReturnType<typeof getNewClientFormState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNewClientFormStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 쮐걤햨혞
 */
export const getClientSearchState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetClientSearchState200>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getGetClientSearchStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/client-search/session/${sessionId}/state`] as const;
    }

    
export const getGetClientSearchStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClientSearchState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClientSearchStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClientSearchState>>> = ({ signal }) => getClientSearchState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetClientSearchStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClientSearchState>>>
export type GetClientSearchStateInfiniteQueryError = ErrorResponse


export function useGetClientSearchStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientSearchState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientSearchState>>,
          TError,
          Awaited<ReturnType<typeof getClientSearchState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientSearchStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientSearchState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientSearchState>>,
          TError,
          Awaited<ReturnType<typeof getClientSearchState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientSearchStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientSearchState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 쮐걤햨혞
 */

export function useGetClientSearchStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientSearchState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetClientSearchStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClientSearchStateQueryOptions = <TData = Awaited<ReturnType<typeof getClientSearchState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClientSearchStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClientSearchState>>> = ({ signal }) => getClientSearchState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetClientSearchStateQueryResult = NonNullable<Awaited<ReturnType<typeof getClientSearchState>>>
export type GetClientSearchStateQueryError = ErrorResponse


export function useGetClientSearchState<TData = Awaited<ReturnType<typeof getClientSearchState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientSearchState>>,
          TError,
          Awaited<ReturnType<typeof getClientSearchState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientSearchState<TData = Awaited<ReturnType<typeof getClientSearchState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientSearchState>>,
          TError,
          Awaited<ReturnType<typeof getClientSearchState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientSearchState<TData = Awaited<ReturnType<typeof getClientSearchState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 쮐걤햨혞
 */

export function useGetClientSearchState<TData = Awaited<ReturnType<typeof getClientSearchState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetClientSearchStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 쮏쐄햟햫쮏 햨햩혰혮햫혝햟
 */
export const getSelectedClient = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/selected-client`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSelectedClientQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/client-search/session/${sessionId}/selected-client`] as const;
    }

    
export const getGetSelectedClientInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSelectedClient>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSelectedClientQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSelectedClient>>> = ({ signal }) => getSelectedClient(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSelectedClientInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSelectedClient>>>
export type GetSelectedClientInfiniteQueryError = ErrorResponse


export function useGetSelectedClientInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSelectedClient>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSelectedClient>>,
          TError,
          Awaited<ReturnType<typeof getSelectedClient>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSelectedClientInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSelectedClient>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSelectedClient>>,
          TError,
          Awaited<ReturnType<typeof getSelectedClient>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSelectedClientInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSelectedClient>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮏쐄햟햫쮏 햨햩혰혮햫혝햟
 */

export function useGetSelectedClientInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSelectedClient>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSelectedClientInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSelectedClientQueryOptions = <TData = Awaited<ReturnType<typeof getSelectedClient>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSelectedClientQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSelectedClient>>> = ({ signal }) => getSelectedClient(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSelectedClientQueryResult = NonNullable<Awaited<ReturnType<typeof getSelectedClient>>>
export type GetSelectedClientQueryError = ErrorResponse


export function useGetSelectedClient<TData = Awaited<ReturnType<typeof getSelectedClient>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSelectedClient>>,
          TError,
          Awaited<ReturnType<typeof getSelectedClient>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSelectedClient<TData = Awaited<ReturnType<typeof getSelectedClient>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSelectedClient>>,
          TError,
          Awaited<ReturnType<typeof getSelectedClient>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSelectedClient<TData = Awaited<ReturnType<typeof getSelectedClient>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮏쐄햟햫쮏 햨햩혰혮햫혝햟
 */

export function useGetSelectedClient<TData = Awaited<ReturnType<typeof getSelectedClient>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSelectedClientQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 햠햟향쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */
export const getBasicOrderInfoState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetBasicOrderInfoState200>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getGetBasicOrderInfoStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/basic-order/session/${sessionId}/state`] as const;
    }

    
export const getGetBasicOrderInfoStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getBasicOrderInfoState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBasicOrderInfoStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBasicOrderInfoState>>> = ({ signal }) => getBasicOrderInfoState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBasicOrderInfoStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getBasicOrderInfoState>>>
export type GetBasicOrderInfoStateInfiniteQueryError = ErrorResponse


export function useGetBasicOrderInfoStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasicOrderInfoState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasicOrderInfoState>>,
          TError,
          Awaited<ReturnType<typeof getBasicOrderInfoState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasicOrderInfoStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasicOrderInfoState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasicOrderInfoState>>,
          TError,
          Awaited<ReturnType<typeof getBasicOrderInfoState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasicOrderInfoStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasicOrderInfoState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 햠햟향쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */

export function useGetBasicOrderInfoStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasicOrderInfoState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBasicOrderInfoStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBasicOrderInfoStateQueryOptions = <TData = Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBasicOrderInfoStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBasicOrderInfoState>>> = ({ signal }) => getBasicOrderInfoState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBasicOrderInfoStateQueryResult = NonNullable<Awaited<ReturnType<typeof getBasicOrderInfoState>>>
export type GetBasicOrderInfoStateQueryError = ErrorResponse


export function useGetBasicOrderInfoState<TData = Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasicOrderInfoState>>,
          TError,
          Awaited<ReturnType<typeof getBasicOrderInfoState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasicOrderInfoState<TData = Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasicOrderInfoState>>,
          TError,
          Awaited<ReturnType<typeof getBasicOrderInfoState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasicOrderInfoState<TData = Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪혞혮 쮐쮐햫햦햧 혜혝햟햫 햠햟향쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */

export function useGetBasicOrderInfoState<TData = Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicOrderInfoState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBasicOrderInfoStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 쮏얧쟳쫧쟴혩 쒫쟳쩀뒘혞 햢햩혪 햣햢햪햣혝햟
 */
export const getRecommendedUnitOfMeasure = (
    params: GetRecommendedUnitOfMeasureParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/units-of-measure/recommend`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedUnitOfMeasureQueryKey = (params: GetRecommendedUnitOfMeasureParams,) => {
    return [`/units-of-measure/recommend`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedUnitOfMeasureInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedUnitOfMeasureQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>> = ({ signal }) => getRecommendedUnitOfMeasure(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedUnitOfMeasureInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>
export type GetRecommendedUnitOfMeasureInfiniteQueryError = ErrorResponse


export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 쮏얧쟳쫧쟴혩 쒫쟳쩀뒘혞 햢햩혪 햣햢햪햣혝햟
 */

export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedUnitOfMeasureInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedUnitOfMeasureQueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedUnitOfMeasureQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>> = ({ signal }) => getRecommendedUnitOfMeasure(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedUnitOfMeasureQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>
export type GetRecommendedUnitOfMeasureQueryError = ErrorResponse


export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 쮏얧쟳쫧쟴혩 쒫쟳쩀뒘혞 햢햩혪 햣햢햪햣혝햟
 */

export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedUnitOfMeasureQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햣햣쒬뒘햦혝햦 혰햢혝햦햪햨혞 쮏얧쟳쫧쟴혰 쒫쟳쩀뒘혞 햢햩혪 햣햢햪햣혝햟
 */
export const isUnitSupportedForItem = (
    params: IsUnitSupportedForItemParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/units-of-measure/check-support`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getIsUnitSupportedForItemQueryKey = (params: IsUnitSupportedForItemParams,) => {
    return [`/units-of-measure/check-support`, ...(params ? [params]: [])] as const;
    }

    
export const getIsUnitSupportedForItemInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsUnitSupportedForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isUnitSupportedForItem>>> = ({ signal }) => isUnitSupportedForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsUnitSupportedForItemInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof isUnitSupportedForItem>>>
export type IsUnitSupportedForItemInfiniteQueryError = ErrorResponse


export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 혰햢혝햦햪햨혞 쮏얧쟳쫧쟴혰 쒫쟳쩀뒘혞 햢햩혪 햣햢햪햣혝햟
 */

export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsUnitSupportedForItemInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getIsUnitSupportedForItemQueryOptions = <TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsUnitSupportedForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isUnitSupportedForItem>>> = ({ signal }) => isUnitSupportedForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsUnitSupportedForItemQueryResult = NonNullable<Awaited<ReturnType<typeof isUnitSupportedForItem>>>
export type IsUnitSupportedForItemQueryError = ErrorResponse


export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햦혝햦 혰햢혝햦햪햨혞 쮏얧쟳쫧쟴혰 쒫쟳쩀뒘혞 햢햩혪 햣햢햪햣혝햟
 */

export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsUnitSupportedForItemQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햢쮐혝혞햫혰 쮏얧쟳쫧쟴혰 쒫쟳쩀뒘혞 햢햩혪 햨햟혝햣햡쮐혰혱
 */
export const getAvailableUnitsForCategory = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/units-of-measure/category/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAvailableUnitsForCategoryQueryKey = (categoryId: string,) => {
    return [`/units-of-measure/category/${categoryId}`] as const;
    }

    
export const getGetAvailableUnitsForCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsForCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>> = ({ signal }) => getAvailableUnitsForCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsForCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>
export type GetAvailableUnitsForCategoryInfiniteQueryError = ErrorResponse


export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햢쮐혝혞햫혰 쮏얧쟳쫧쟴혰 쒫쟳쩀뒘혞 햢햩혪 햨햟혝햣햡쮐혰혱
 */

export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsForCategoryInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableUnitsForCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsForCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>> = ({ signal }) => getAvailableUnitsForCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsForCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>
export type GetAvailableUnitsForCategoryQueryError = ErrorResponse


export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햢쮐혝혞햫혰 쮏얧쟳쫧쟴혰 쒫쟳쩀뒘혞 햢햩혪 햨햟혝햣햡쮐혰혱
 */

export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsForCategoryQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혝햣혜혝쮏쒫 햦쒬뒘햟햫햫혪
 * @summary 햑햣혜혝쮏쒫쟳 햣햫햢쮐뒗쫨
 */
export const hello = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<TestResponse>(
      {url: `/test/hello`, method: 'GET', signal
    },
      options);
    }
  

export const getHelloQueryKey = () => {
    return [`/test/hello`] as const;
    }

    
export const getHelloInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof hello>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof hello>>> = ({ signal }) => hello(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HelloInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof hello>>>
export type HelloInfiniteQueryError = ErrorResponse


export function useHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof hello>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof hello>>,
          TError,
          Awaited<ReturnType<typeof hello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof hello>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof hello>>,
          TError,
          Awaited<ReturnType<typeof hello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof hello>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햑햣혜혝쮏쒫쟳 햣햫햢쮐뒗쫨
 */

export function useHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof hello>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHelloInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getHelloQueryOptions = <TData = Awaited<ReturnType<typeof hello>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof hello>>> = ({ signal }) => hello(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HelloQueryResult = NonNullable<Awaited<ReturnType<typeof hello>>>
export type HelloQueryError = ErrorResponse


export function useHello<TData = Awaited<ReturnType<typeof hello>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof hello>>,
          TError,
          Awaited<ReturnType<typeof hello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHello<TData = Awaited<ReturnType<typeof hello>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof hello>>,
          TError,
          Awaited<ReturnType<typeof hello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHello<TData = Awaited<ReturnType<typeof hello>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햑햣혜혝쮏쒫쟳 햣햫햢쮐뒗쫨
 */

export function useHello<TData = Awaited<ReturnType<typeof hello>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHelloQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혝햦 햩혪햪햦 향햟 쒫쥃썛햟햫햦햪 햨쮏얧쮏
 * @summary 뤰햦햪햟혝햦 혝햦 햩혪햪햦 향햟 햨쮏얧쮏
 */
export const getStainTypeByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetStainTypeByCode200>(
      {url: `/stain-types/by-code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStainTypeByCodeQueryKey = (code: string,) => {
    return [`/stain-types/by-code/${code}`] as const;
    }

    
export const getGetStainTypeByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeByCode>>> = ({ signal }) => getStainTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeByCode>>>
export type GetStainTypeByCodeInfiniteQueryError = ErrorResponse


export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦 햩혪햪햦 향햟 햨쮏얧쮏
 */

export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypeByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeByCode>>> = ({ signal }) => getStainTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeByCode>>>
export type GetStainTypeByCodeQueryError = ErrorResponse


export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦 햩혪햪햦 향햟 햨쮏얧쮏
 */

export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혰햢햦혜 햨햩혰혮햫혝햟 향햟 햧쮏 ID
 * @summary 뤰햦햪햟혝햦 혰햢햦혜 향햟 ID
 */
export const getSignatureById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CustomerSignatureResponse>(
      {url: `/signatures/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSignatureByIdQueryKey = (id: string,) => {
    return [`/signatures/${id}`] as const;
    }

    
export const getGetSignatureByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSignatureById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignatureByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignatureById>>> = ({ signal }) => getSignatureById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignatureByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSignatureById>>>
export type GetSignatureByIdInfiniteQueryError = ErrorResponse


export function useGetSignatureByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureById>>,
          TError,
          Awaited<ReturnType<typeof getSignatureById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureById>>,
          TError,
          Awaited<ReturnType<typeof getSignatureById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혰햢햦혜 향햟 ID
 */

export function useGetSignatureByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignatureByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSignatureByIdQueryOptions = <TData = Awaited<ReturnType<typeof getSignatureById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignatureByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignatureById>>> = ({ signal }) => getSignatureById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignatureByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSignatureById>>>
export type GetSignatureByIdQueryError = ErrorResponse


export function useGetSignatureById<TData = Awaited<ReturnType<typeof getSignatureById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureById>>,
          TError,
          Awaited<ReturnType<typeof getSignatureById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureById<TData = Awaited<ReturnType<typeof getSignatureById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureById>>,
          TError,
          Awaited<ReturnType<typeof getSignatureById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureById<TData = Awaited<ReturnType<typeof getSignatureById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혰햢햦혜 향햟 ID
 */

export function useGetSignatureById<TData = Awaited<ReturnType<typeof getSignatureById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignatureByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 쒬혰 혰햢햦혜햦 햢햩혪 햨쮏쫧쥄햣혝햫쮏 향햟햪쮏쒫햣햫햫혪
 * @summary 뤰햦햪햟혝햦 쒬혰 혰햢햦혜햦 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */
export const getSignaturesByOrderId = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CustomerSignatureResponse[]>(
      {url: `/signatures/orders/${orderId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSignaturesByOrderIdQueryKey = (orderId: string,) => {
    return [`/signatures/orders/${orderId}`] as const;
    }

    
export const getGetSignaturesByOrderIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSignaturesByOrderId>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignaturesByOrderIdQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignaturesByOrderId>>> = ({ signal }) => getSignaturesByOrderId(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignaturesByOrderIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSignaturesByOrderId>>>
export type GetSignaturesByOrderIdInfiniteQueryError = ErrorResponse


export function useGetSignaturesByOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignaturesByOrderId>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignaturesByOrderId>>,
          TError,
          Awaited<ReturnType<typeof getSignaturesByOrderId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignaturesByOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignaturesByOrderId>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignaturesByOrderId>>,
          TError,
          Awaited<ReturnType<typeof getSignaturesByOrderId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignaturesByOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignaturesByOrderId>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 혰햢햦혜햦 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */

export function useGetSignaturesByOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignaturesByOrderId>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignaturesByOrderIdInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSignaturesByOrderIdQueryOptions = <TData = Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignaturesByOrderIdQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignaturesByOrderId>>> = ({ signal }) => getSignaturesByOrderId(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignaturesByOrderIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSignaturesByOrderId>>>
export type GetSignaturesByOrderIdQueryError = ErrorResponse


export function useGetSignaturesByOrderId<TData = Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignaturesByOrderId>>,
          TError,
          Awaited<ReturnType<typeof getSignaturesByOrderId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignaturesByOrderId<TData = Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignaturesByOrderId>>,
          TError,
          Awaited<ReturnType<typeof getSignaturesByOrderId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignaturesByOrderId<TData = Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 혰햢햦혜햦 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */

export function useGetSignaturesByOrderId<TData = Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignaturesByOrderIdQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혰햢햦혜 햨쮏쫧쥄햣혝햫쮏 혝햦혞 햢햩혪 향햟햪쮏쒫햣햫햫혪
 * @summary 뤰햦햪햟혝햦 혰햢햦혜 향햟 혝햦쮏 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */
export const getSignatureByOrderIdAndType = (
    orderId: string,
    signatureType: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CustomerSignatureResponse>(
      {url: `/signatures/orders/${orderId}/types/${signatureType}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSignatureByOrderIdAndTypeQueryKey = (orderId: string,
    signatureType: string,) => {
    return [`/signatures/orders/${orderId}/types/${signatureType}`] as const;
    }

    
export const getGetSignatureByOrderIdAndTypeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>, TError = ErrorResponse>(orderId: string,
    signatureType: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignatureByOrderIdAndTypeQueryKey(orderId,signatureType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>> = ({ signal }) => getSignatureByOrderIdAndType(orderId,signatureType, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId && signatureType),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignatureByOrderIdAndTypeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>
export type GetSignatureByOrderIdAndTypeInfiniteQueryError = ErrorResponse


export function useGetSignatureByOrderIdAndTypeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>,
          TError,
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByOrderIdAndTypeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>,
          TError,
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByOrderIdAndTypeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혰햢햦혜 향햟 혝햦쮏 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */

export function useGetSignatureByOrderIdAndTypeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignatureByOrderIdAndTypeInfiniteQueryOptions(orderId,signatureType,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSignatureByOrderIdAndTypeQueryOptions = <TData = Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError = ErrorResponse>(orderId: string,
    signatureType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignatureByOrderIdAndTypeQueryKey(orderId,signatureType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>> = ({ signal }) => getSignatureByOrderIdAndType(orderId,signatureType, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId && signatureType),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignatureByOrderIdAndTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>
export type GetSignatureByOrderIdAndTypeQueryError = ErrorResponse


export function useGetSignatureByOrderIdAndType<TData = Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>,
          TError,
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByOrderIdAndType<TData = Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>,
          TError,
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByOrderIdAndType<TData = Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혰햢햦혜 향햟 혝햦쮏 햢햩혪 향햟햪쮏쒫햣햫햫혪
 */

export function useGetSignatureByOrderIdAndType<TData = Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignatureByOrderIdAndTypeQueryOptions(orderId,signatureType,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 혜햦혜쮏 쒬혰혠 햟햨혝햦쒫쫧쟴 햨햟혝햣햡쮐혰햧 쮐햩혞햡
 */
export const getAllActiveCategories = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAllActiveCategories200>(
      {url: `/service-categories`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllActiveCategoriesQueryKey = () => {
    return [`/service-categories`] as const;
    }

    
export const getGetAllActiveCategoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllActiveCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllActiveCategories>>> = ({ signal }) => getAllActiveCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllActiveCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllActiveCategories>>>
export type GetAllActiveCategoriesInfiniteQueryError = ErrorResponse


export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혜햦혜쮏 쒬혰혠 햟햨혝햦쒫쫧쟴 햨햟혝햣햡쮐혰햧 쮐햩혞햡
 */

export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllActiveCategoriesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllActiveCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllActiveCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllActiveCategories>>> = ({ signal }) => getAllActiveCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllActiveCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllActiveCategories>>>
export type GetAllActiveCategoriesQueryError = ErrorResponse


export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혜햦혜쮏 쒬혰혠 햟햨혝햦쒫쫧쟴 햨햟혝햣햡쮐혰햧 쮐햩혞햡
 */

export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllActiveCategoriesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 ID
 */
export const getCategoryById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryById200>(
      {url: `/service-categories/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByIdQueryKey = (id: string,) => {
    return [`/service-categories/${id}`] as const;
    }

    
export const getGetCategoryByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdInfiniteQueryError = ErrorResponse


export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 ID
 */

export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdQueryError = ErrorResponse


export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 ID
 */

export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 햨쮏얧쮏
 */
export const getCategoryByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryByCode200>(
      {url: `/service-categories/code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByCodeQueryKey = (code: string,) => {
    return [`/service-categories/code/${code}`] as const;
    }

    
export const getGetCategoryByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode>>> = ({ signal }) => getCategoryByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode>>>
export type GetCategoryByCodeInfiniteQueryError = ErrorResponse


export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 햨쮏얧쮏
 */

export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode>>> = ({ signal }) => getCategoryByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode>>>
export type GetCategoryByCodeQueryError = ErrorResponse


export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 햨쮏얧쮏
 */

export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혜혝혞햨혝혞쮏쒫썛쫨 햢햟햫혰 햢햩혪 혟쮐햪혞쒫썛쫧쫨 햨쒫쟴햟햫혡혰혱 향햟 ID 향햟햪쮏쒫햣햫햫혪
 * @summary 뤰햦햪햟혝햦 햢햟햫혰 햢햩혪 햨쒫쟴햟햫혡혰혱
 */
export const getReceiptData = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ReceiptDTO>(
      {url: `/receipts/${orderId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetReceiptDataQueryKey = (orderId: string,) => {
    return [`/receipts/${orderId}`] as const;
    }

    
export const getGetReceiptDataInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getReceiptData>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReceiptDataQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReceiptData>>> = ({ signal }) => getReceiptData(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReceiptDataInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getReceiptData>>>
export type GetReceiptDataInfiniteQueryError = ErrorResponse


export function useGetReceiptDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReceiptData>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptData>>,
          TError,
          Awaited<ReturnType<typeof getReceiptData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReceiptData>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptData>>,
          TError,
          Awaited<ReturnType<typeof getReceiptData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReceiptData>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢햟햫혰 햢햩혪 햨쒫쟴햟햫혡혰혱
 */

export function useGetReceiptDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReceiptData>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReceiptDataInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetReceiptDataQueryOptions = <TData = Awaited<ReturnType<typeof getReceiptData>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReceiptDataQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReceiptData>>> = ({ signal }) => getReceiptData(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReceiptDataQueryResult = NonNullable<Awaited<ReturnType<typeof getReceiptData>>>
export type GetReceiptDataQueryError = ErrorResponse


export function useGetReceiptData<TData = Awaited<ReturnType<typeof getReceiptData>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptData>>,
          TError,
          Awaited<ReturnType<typeof getReceiptData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptData<TData = Awaited<ReturnType<typeof getReceiptData>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptData>>,
          TError,
          Awaited<ReturnType<typeof getReceiptData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptData<TData = Awaited<ReturnType<typeof getReceiptData>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢햟햫혰 햢햩혪 햨쒫쟴햟햫혡혰혱
 */

export function useGetReceiptData<TData = Awaited<ReturnType<typeof getReceiptData>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReceiptDataQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 행햟쒫썛쫨햟햤혞혮 PDF-햨쒫쟴햟햫혡혰혩 햢햩혪 향햟햪쮏쒫햣햫햫혪 혪햨 혟햟햧햩
 * @summary 행햟쒫썛쫨햟햤햦혝햦 PDF-햨쒫쟴햟햫혡혰혩
 */
export const downloadPdfReceipt = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<DownloadPdfReceipt200>(
      {url: `/receipts/pdf/download/${orderId}`, method: 'GET', signal
    },
      options);
    }
  

export const getDownloadPdfReceiptQueryKey = (orderId: string,) => {
    return [`/receipts/pdf/download/${orderId}`] as const;
    }

    
export const getDownloadPdfReceiptInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof downloadPdfReceipt>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadPdfReceiptQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadPdfReceipt>>> = ({ signal }) => downloadPdfReceipt(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DownloadPdfReceiptInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof downloadPdfReceipt>>>
export type DownloadPdfReceiptInfiniteQueryError = ErrorResponse


export function useDownloadPdfReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof downloadPdfReceipt>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadPdfReceipt>>,
          TError,
          Awaited<ReturnType<typeof downloadPdfReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadPdfReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof downloadPdfReceipt>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadPdfReceipt>>,
          TError,
          Awaited<ReturnType<typeof downloadPdfReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadPdfReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof downloadPdfReceipt>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 행햟쒫썛쫨햟햤햦혝햦 PDF-햨쒫쟴햟햫혡혰혩
 */

export function useDownloadPdfReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof downloadPdfReceipt>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadPdfReceiptInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getDownloadPdfReceiptQueryOptions = <TData = Awaited<ReturnType<typeof downloadPdfReceipt>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadPdfReceiptQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadPdfReceipt>>> = ({ signal }) => downloadPdfReceipt(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DownloadPdfReceiptQueryResult = NonNullable<Awaited<ReturnType<typeof downloadPdfReceipt>>>
export type DownloadPdfReceiptQueryError = ErrorResponse


export function useDownloadPdfReceipt<TData = Awaited<ReturnType<typeof downloadPdfReceipt>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadPdfReceipt>>,
          TError,
          Awaited<ReturnType<typeof downloadPdfReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadPdfReceipt<TData = Awaited<ReturnType<typeof downloadPdfReceipt>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadPdfReceipt>>,
          TError,
          Awaited<ReturnType<typeof downloadPdfReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadPdfReceipt<TData = Awaited<ReturnType<typeof downloadPdfReceipt>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 행햟쒫썛쫨햟햤햦혝햦 PDF-햨쒫쟴햟햫혡혰혩
 */

export function useDownloadPdfReceipt<TData = Awaited<ReturnType<typeof downloadPdfReceipt>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadPdfReceiptQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 햅햣햫햣혞혮 혞햫혰햨햟햩혧햫햦햧 햫쮏쨿왐 햨쒫쟴햟햫혡혰혱 햢햩혪 햫쮏쒫쮏 향햟햪쮏쒫햣햫햫혪
 * @summary 햅햣햫햣혞쒫썜햦 햫쮏쨿왐 햨쒫쟴햟햫혡혰혱
 */
export const generateReceiptNumber1 = (
    params?: GenerateReceiptNumber1Params,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GenerateReceiptNumber1200>(
      {url: `/receipts/generate-number`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGenerateReceiptNumber1QueryKey = (params?: GenerateReceiptNumber1Params,) => {
    return [`/receipts/generate-number`, ...(params ? [params]: [])] as const;
    }

    
export const getGenerateReceiptNumber1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof generateReceiptNumber1>>>, TError = ErrorResponse | GenerateReceiptNumber1500>(params?: GenerateReceiptNumber1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGenerateReceiptNumber1QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof generateReceiptNumber1>>> = ({ signal }) => generateReceiptNumber1(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GenerateReceiptNumber1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof generateReceiptNumber1>>>
export type GenerateReceiptNumber1InfiniteQueryError = ErrorResponse | GenerateReceiptNumber1500


export function useGenerateReceiptNumber1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof generateReceiptNumber1>>>, TError = ErrorResponse | GenerateReceiptNumber1500>(
 params: undefined |  GenerateReceiptNumber1Params, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof generateReceiptNumber1>>,
          TError,
          Awaited<ReturnType<typeof generateReceiptNumber1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGenerateReceiptNumber1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof generateReceiptNumber1>>>, TError = ErrorResponse | GenerateReceiptNumber1500>(
 params?: GenerateReceiptNumber1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof generateReceiptNumber1>>,
          TError,
          Awaited<ReturnType<typeof generateReceiptNumber1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGenerateReceiptNumber1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof generateReceiptNumber1>>>, TError = ErrorResponse | GenerateReceiptNumber1500>(
 params?: GenerateReceiptNumber1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햅햣햫햣혞쒫썜햦 햫쮏쨿왐 햨쒫쟴햟햫혡혰혱
 */

export function useGenerateReceiptNumber1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof generateReceiptNumber1>>>, TError = ErrorResponse | GenerateReceiptNumber1500>(
 params?: GenerateReceiptNumber1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGenerateReceiptNumber1InfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGenerateReceiptNumber1QueryOptions = <TData = Awaited<ReturnType<typeof generateReceiptNumber1>>, TError = ErrorResponse | GenerateReceiptNumber1500>(params?: GenerateReceiptNumber1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGenerateReceiptNumber1QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof generateReceiptNumber1>>> = ({ signal }) => generateReceiptNumber1(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GenerateReceiptNumber1QueryResult = NonNullable<Awaited<ReturnType<typeof generateReceiptNumber1>>>
export type GenerateReceiptNumber1QueryError = ErrorResponse | GenerateReceiptNumber1500


export function useGenerateReceiptNumber1<TData = Awaited<ReturnType<typeof generateReceiptNumber1>>, TError = ErrorResponse | GenerateReceiptNumber1500>(
 params: undefined |  GenerateReceiptNumber1Params, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof generateReceiptNumber1>>,
          TError,
          Awaited<ReturnType<typeof generateReceiptNumber1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGenerateReceiptNumber1<TData = Awaited<ReturnType<typeof generateReceiptNumber1>>, TError = ErrorResponse | GenerateReceiptNumber1500>(
 params?: GenerateReceiptNumber1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof generateReceiptNumber1>>,
          TError,
          Awaited<ReturnType<typeof generateReceiptNumber1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGenerateReceiptNumber1<TData = Awaited<ReturnType<typeof generateReceiptNumber1>>, TError = ErrorResponse | GenerateReceiptNumber1500>(
 params?: GenerateReceiptNumber1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햅햣햫햣혞쒫썜햦 햫쮏쨿왐 햨쒫쟴햟햫혡혰혱
 */

export function useGenerateReceiptNumber1<TData = Awaited<ReturnType<typeof generateReceiptNumber1>>, TError = ErrorResponse | GenerateReceiptNumber1500>(
 params?: GenerateReceiptNumber1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof generateReceiptNumber1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGenerateReceiptNumber1QueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐햦 햢햩혪 햨햟혝햣햡쮐혰혱 쮐햩혞햡
 */
export const getModifiersForServiceCategory = (
    categoryCode: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersForServiceCategory200>(
      {url: `/price-modifiers/service-category/${categoryCode}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifiersForServiceCategoryQueryKey = (categoryCode: string,) => {
    return [`/price-modifiers/service-category/${categoryCode}`] as const;
    }

    
export const getGetModifiersForServiceCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersForServiceCategoryQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersForServiceCategory>>> = ({ signal }) => getModifiersForServiceCategory(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersForServiceCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>
export type GetModifiersForServiceCategoryInfiniteQueryError = ErrorResponse


export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐햦 햢햩혪 햨햟혝햣햡쮐혰혱 쮐햩혞햡
 */

export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersForServiceCategoryInfiniteQueryOptions(categoryCode,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifiersForServiceCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersForServiceCategoryQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersForServiceCategory>>> = ({ signal }) => getModifiersForServiceCategory(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersForServiceCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>
export type GetModifiersForServiceCategoryQueryError = ErrorResponse


export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐햦 햢햩혪 햨햟혝햣햡쮐혰혱 쮐햩혞햡
 */

export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersForServiceCategoryQueryOptions(categoryCode,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐 향햟 햨쮏얧쮏
 */
export const getModifierByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifierByCode200>(
      {url: `/price-modifiers/code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifierByCodeQueryKey = (code: string,) => {
    return [`/price-modifiers/code/${code}`] as const;
    }

    
export const getGetModifierByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierByCode>>> = ({ signal }) => getModifierByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierByCode>>>
export type GetModifierByCodeInfiniteQueryError = ErrorResponse


export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐 향햟 햨쮏얧쮏
 */

export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifierByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierByCode>>> = ({ signal }) => getModifierByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierByCode>>>
export type GetModifierByCodeQueryError = ErrorResponse


export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐 향햟 햨쮏얧쮏
 */

export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐햦 향햟 햨햟혝햣햡쮐혰혮혩
 */
export const getModifiersByCategory = (
    params: GetModifiersByCategoryParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersByCategory200>(
      {url: `/price-modifiers/category`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetModifiersByCategoryQueryKey = (params: GetModifiersByCategoryParams,) => {
    return [`/price-modifiers/category`, ...(params ? [params]: [])] as const;
    }

    
export const getGetModifiersByCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersByCategoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersByCategory>>> = ({ signal }) => getModifiersByCategory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersByCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCategory>>>
export type GetModifiersByCategoryInfiniteQueryError = ErrorResponse


export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐햦 향햟 햨햟혝햣햡쮐혰혮혩
 */

export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersByCategoryInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifiersByCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersByCategoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersByCategory>>> = ({ signal }) => getModifiersByCategory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersByCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCategory>>>
export type GetModifiersByCategoryQueryError = ErrorResponse


export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐햦 향햟 햨햟혝햣햡쮐혰혮혩
 */

export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersByCategoryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햨햟혝햣햡쮐혰혱 쮐햩혞햡
 */
export const getAllCategories = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAllCategories200>(
      {url: `/price-list`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllCategoriesQueryKey = () => {
    return [`/price-list`] as const;
    }

    
export const getGetAllCategoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCategories>>> = ({ signal }) => getAllCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllCategories>>>
export type GetAllCategoriesInfiniteQueryError = ErrorResponse


export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햨햟혝햣햡쮐혰혱 쮐햩혞햡
 */

export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllCategoriesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCategories>>> = ({ signal }) => getAllCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllCategories>>>
export type GetAllCategoriesQueryError = ErrorResponse


export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햨햟혝햣햡쮐혰혱 쮐햩혞햡
 */

export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllCategoriesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 혰햢햣햫혝햦혟혰햨햟혝쮐쮏
 */
export const getCategoryById1 = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryById1200>(
      {url: `/price-list/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryById1QueryKey = (categoryId: string,) => {
    return [`/price-list/${categoryId}`] as const;
    }

    
export const getGetCategoryById1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryById1QueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById1>>> = ({ signal }) => getCategoryById1(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryById1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById1>>>
export type GetCategoryById1InfiniteQueryError = ErrorResponse


export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 혰햢햣햫혝햦혟혰햨햟혝쮐쮏
 */

export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryById1InfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryById1QueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryById1QueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById1>>> = ({ signal }) => getCategoryById1(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryById1QueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById1>>>
export type GetCategoryById1QueryError = ErrorResponse


export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 혰햢햣햫혝햦혟혰햨햟혝쮐쮏
 */

export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryById1QueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 햨쮏얧쮏
 */
export const getCategoryByCode1 = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryByCode1200>(
      {url: `/price-list/category/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByCode1QueryKey = (code: string,) => {
    return [`/price-list/category/${code}`] as const;
    }

    
export const getGetCategoryByCode1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCode1QueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode1>>> = ({ signal }) => getCategoryByCode1(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCode1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode1>>>
export type GetCategoryByCode1InfiniteQueryError = ErrorResponse


export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 햨쮏얧쮏
 */

export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCode1InfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByCode1QueryOptions = <TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCode1QueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode1>>> = ({ signal }) => getCategoryByCode1(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCode1QueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode1>>>
export type GetCategoryByCode1QueryError = ErrorResponse


export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햨햟혝햣햡쮐혰혩 쮐햩혞햡 향햟 햨쮏얧쮏
 */

export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCode1QueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햢쮐혝혞햫혰 쮏얧쟳쫧쟴혰 쒫쟳쩀뒘혞 햢햩혪 햨햟혝햣햡쮐혰혱
 */
export const getAvailableUnitsOfMeasure = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAvailableUnitsOfMeasure200>(
      {url: `/price-list/category/${categoryId}/units-of-measure`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAvailableUnitsOfMeasureQueryKey = (categoryId: string,) => {
    return [`/price-list/category/${categoryId}/units-of-measure`] as const;
    }

    
export const getGetAvailableUnitsOfMeasureInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsOfMeasureQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>> = ({ signal }) => getAvailableUnitsOfMeasure(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsOfMeasureInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>
export type GetAvailableUnitsOfMeasureInfiniteQueryError = ErrorResponse


export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢쮐혝혞햫혰 쮏얧쟳쫧쟴혰 쒫쟳쩀뒘혞 햢햩혪 햨햟혝햣햡쮐혰혱
 */

export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsOfMeasureInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableUnitsOfMeasureQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsOfMeasureQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>> = ({ signal }) => getAvailableUnitsOfMeasure(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsOfMeasureQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>
export type GetAvailableUnitsOfMeasureQueryError = ErrorResponse


export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢쮐혝혞햫혰 쮏얧쟳쫧쟴혰 쒫쟳쩀뒘혞 햢햩혪 햨햟혝햣햡쮐혰혱
 */

export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsOfMeasureQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햣햩햣햪햣햫혝햦 햟햧혜-햩햦혜혝햟 향햟 햨햟혝햣햡쮐혰혮혩
 */
export const getItemsByCategory = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemsByCategory200>(
      {url: `/price-list/category/${categoryId}/items`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemsByCategoryQueryKey = (categoryId: string,) => {
    return [`/price-list/category/${categoryId}/items`] as const;
    }

    
export const getGetItemsByCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategory>>> = ({ signal }) => getItemsByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategory>>>
export type GetItemsByCategoryInfiniteQueryError = ErrorResponse


export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햣햩햣햪햣햫혝햦 햟햧혜-햩햦혜혝햟 향햟 햨햟혝햣햡쮐혰혮혩
 */

export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemsByCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategory>>> = ({ signal }) => getItemsByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategory>>>
export type GetItemsByCategoryQueryError = ErrorResponse


export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햣햩햣햪햣햫혝햦 햟햧혜-햩햦혜혝햟 향햟 햨햟혝햣햡쮐혰혮혩
 */

export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 혜햦혜쮏 햫햟햧햪햣햫혞쒫썛쫨 쒫쟴쮏쐄뒗 향햟 햨햟혝햣햡쮐혰혮혩
 */
export const getItemNamesByCategory = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemNamesByCategory200>(
      {url: `/price-list/category/${categoryId}/item-names`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemNamesByCategoryQueryKey = (categoryId: string,) => {
    return [`/price-list/category/${categoryId}/item-names`] as const;
    }

    
export const getGetItemNamesByCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemNamesByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemNamesByCategory>>> = ({ signal }) => getItemNamesByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemNamesByCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemNamesByCategory>>>
export type GetItemNamesByCategoryInfiniteQueryError = ErrorResponse


export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혜햦혜쮏 햫햟햧햪햣햫혞쒫썛쫨 쒫쟴쮏쐄뒗 향햟 햨햟혝햣햡쮐혰혮혩
 */

export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemNamesByCategoryInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemNamesByCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemNamesByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemNamesByCategory>>> = ({ signal }) => getItemNamesByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemNamesByCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getItemNamesByCategory>>>
export type GetItemNamesByCategoryQueryError = ErrorResponse


export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혜햦혜쮏 햫햟햧햪햣햫혞쒫썛쫨 쒫쟴쮏쐄뒗 향햟 햨햟혝햣햡쮐혰혮혩
 */

export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemNamesByCategoryQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햣햩햣햪햣햫혝햦 햟햧혜-햩햦혜혝햟 향햟 햨쮏얧쮏 햨햟혝햣햡쮐혰혱
 */
export const getItemsByCategoryCode = (
    categoryCode: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemsByCategoryCode200>(
      {url: `/price-list/category/code/${categoryCode}/items`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemsByCategoryCodeQueryKey = (categoryCode: string,) => {
    return [`/price-list/category/code/${categoryCode}/items`] as const;
    }

    
export const getGetItemsByCategoryCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryCodeQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategoryCode>>> = ({ signal }) => getItemsByCategoryCode(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategoryCode>>>
export type GetItemsByCategoryCodeInfiniteQueryError = ErrorResponse


export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햣햩햣햪햣햫혝햦 햟햧혜-햩햦혜혝햟 향햟 햨쮏얧쮏 햨햟혝햣햡쮐혰혱
 */

export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryCodeInfiniteQueryOptions(categoryCode,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemsByCategoryCodeQueryOptions = <TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryCodeQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategoryCode>>> = ({ signal }) => getItemsByCategoryCode(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategoryCode>>>
export type GetItemsByCategoryCodeQueryError = ErrorResponse


export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햣햩햣햪햣햫혝햦 햟햧혜-햩햦혜혝햟 향햟 햨쮏얧쮏 햨햟혝햣햡쮐혰혱
 */

export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryCodeQueryOptions(categoryCode,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 쮏햣햣햢햤햣햫혧  햦향햦햨햦 햢햩혪 햣햢햪햣혝햟 햫햟 쮐햫쮏쒬 햧쮏 햩혪햪, 햢햣혟햣햨혝혰, 햨햟혝햣햡쮐혰혱 혝햟 햪햟혝햣혰햟햩혞
 * @summary 뤰햦햪햟혝햦 쮏햣햣햢햤햣햫햫혪  햦향햦햨햦
 */
export const getRiskWarnings = (
    params?: GetRiskWarningsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetRiskWarnings200>(
      {url: `/price-calculation/risk-warnings`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRiskWarningsQueryKey = (params?: GetRiskWarningsParams,) => {
    return [`/price-calculation/risk-warnings`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRiskWarningsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarnings>>>, TError = ErrorResponse>(params?: GetRiskWarningsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRiskWarningsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRiskWarnings>>> = ({ signal }) => getRiskWarnings(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRiskWarningsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRiskWarnings>>>
export type GetRiskWarningsInfiniteQueryError = ErrorResponse


export function useGetRiskWarningsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarnings>>>, TError = ErrorResponse>(
 params: undefined |  GetRiskWarningsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarnings>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarnings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarnings>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarnings>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarnings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarnings>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쮏햣햣햢햤햣햫햫혪  햦향햦햨햦
 */

export function useGetRiskWarningsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarnings>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRiskWarningsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRiskWarningsQueryOptions = <TData = Awaited<ReturnType<typeof getRiskWarnings>>, TError = ErrorResponse>(params?: GetRiskWarningsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRiskWarningsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRiskWarnings>>> = ({ signal }) => getRiskWarnings(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRiskWarningsQueryResult = NonNullable<Awaited<ReturnType<typeof getRiskWarnings>>>
export type GetRiskWarningsQueryError = ErrorResponse


export function useGetRiskWarnings<TData = Awaited<ReturnType<typeof getRiskWarnings>>, TError = ErrorResponse>(
 params: undefined |  GetRiskWarningsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarnings>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarnings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarnings<TData = Awaited<ReturnType<typeof getRiskWarnings>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarnings>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarnings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarnings<TData = Awaited<ReturnType<typeof getRiskWarnings>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쮏햣햣햢햤햣햫햫혪  햦향햦햨햦
 */

export function useGetRiskWarnings<TData = Awaited<ReturnType<typeof getRiskWarnings>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRiskWarningsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 햣햨쮏쨿왏쫧얧쮏쒫썛쫧쟴 햪쮏얧쟴혰햨햟혝쮐혰 햢햩혪 햣햢햪햣혝햟 햫햟 쮐햫쮏쒬 햧쮏 햩혪햪, 햢햣혟햣햨혝혰, 햨햟혝햣햡쮐혰혱 혝햟 햪햟혝햣혰햟햩혞
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 햪쮏얧쟴혰햨햟혝쮐햦 햫햟 쮐햫쮏쒬 햩혪햪 혝햟 햢햣혟햣햨혝혰
 */
export const getRecommendedModifiers1 = (
    params?: GetRecommendedModifiers1Params,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetRecommendedModifiers1200>(
      {url: `/price-calculation/recommended-modifiers`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedModifiers1QueryKey = (params?: GetRecommendedModifiers1Params,) => {
    return [`/price-calculation/recommended-modifiers`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedModifiers1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers1>>>, TError = ErrorResponse>(params?: GetRecommendedModifiers1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiers1QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiers1>>> = ({ signal }) => getRecommendedModifiers1(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiers1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiers1>>>
export type GetRecommendedModifiers1InfiniteQueryError = ErrorResponse


export function useGetRecommendedModifiers1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers1>>>, TError = ErrorResponse>(
 params: undefined |  GetRecommendedModifiers1Params, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers1>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiers1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers1>>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiers1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers1>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiers1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers1>>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiers1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 햪쮏얧쟴혰햨햟혝쮐햦 햫햟 쮐햫쮏쒬 햩혪햪 혝햟 햢햣혟햣햨혝혰
 */

export function useGetRecommendedModifiers1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers1>>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiers1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiers1InfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedModifiers1QueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError = ErrorResponse>(params?: GetRecommendedModifiers1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiers1QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiers1>>> = ({ signal }) => getRecommendedModifiers1(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiers1QueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiers1>>>
export type GetRecommendedModifiers1QueryError = ErrorResponse


export function useGetRecommendedModifiers1<TData = Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError = ErrorResponse>(
 params: undefined |  GetRecommendedModifiers1Params, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers1>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiers1<TData = Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiers1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers1>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiers1<TData = Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiers1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 햪쮏얧쟴혰햨햟혝쮐햦 햫햟 쮐햫쮏쒬 햩혪햪 혝햟 햢햣혟햣햨혝혰
 */

export function useGetRecommendedModifiers1<TData = Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiers1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiers1QueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 쮏쒫쫨 혰햫혟쮐햪햟혡혰혩  햪쮏얧쟴혰햨햟혝쮐 향햟 햧쮏 햨쮏얧쮏
 * @summary 뤰햦햪햟혝햦 햢햣혝햟햩혧햫혞 혰햫혟쮐햪햟혡혰혩  햪쮏얧쟴혰햨햟혝쮐
 */
export const getModifierByCode1 = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifierByCode1200>(
      {url: `/price-calculation/modifiers/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifierByCode1QueryKey = (code: string,) => {
    return [`/price-calculation/modifiers/${code}`] as const;
    }

    
export const getGetModifierByCode1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode1>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByCode1QueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierByCode1>>> = ({ signal }) => getModifierByCode1(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByCode1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierByCode1>>>
export type GetModifierByCode1InfiniteQueryError = ErrorResponse


export function useGetModifierByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode1>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode1>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode1>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢햣혝햟햩혧햫혞 혰햫혟쮐햪햟혡혰혩  햪쮏얧쟴혰햨햟혝쮐
 */

export function useGetModifierByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByCode1InfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifierByCode1QueryOptions = <TData = Awaited<ReturnType<typeof getModifierByCode1>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByCode1QueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierByCode1>>> = ({ signal }) => getModifierByCode1(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByCode1QueryResult = NonNullable<Awaited<ReturnType<typeof getModifierByCode1>>>
export type GetModifierByCode1QueryError = ErrorResponse


export function useGetModifierByCode1<TData = Awaited<ReturnType<typeof getModifierByCode1>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode1>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode1<TData = Awaited<ReturnType<typeof getModifierByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode1>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode1<TData = Awaited<ReturnType<typeof getModifierByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢햣혝햟햩혧햫혞 혰햫혟쮐햪햟혡혰혩  햪쮏얧쟴혰햨햟혝쮐
 */

export function useGetModifierByCode1<TData = Awaited<ReturnType<typeof getModifierByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByCode1QueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 햪쮏얧쟴혰햨햟혝쮐햦 향햟 혝햦쮏 (향햟햡햟햩혧햫혰, 혝햣햨혜혝햦햩혧햫혰, 혣햨혰혪햫혰)
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐햦 향햟 혝햦쮏
 */
export const getModifiersByCategory1 = (
    category: 'GENERAL' | 'TEXTILE' | 'LEATHER',
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersByCategory1200>(
      {url: `/price-calculation/modifiers/by-type/${category}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifiersByCategory1QueryKey = (category: 'GENERAL' | 'TEXTILE' | 'LEATHER',) => {
    return [`/price-calculation/modifiers/by-type/${category}`] as const;
    }

    
export const getGetModifiersByCategory1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory1>>>, TError = ErrorResponse>(category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersByCategory1QueryKey(category);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersByCategory1>>> = ({ signal }) => getModifiersByCategory1(category, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(category),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersByCategory1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCategory1>>>
export type GetModifiersByCategory1InfiniteQueryError = ErrorResponse


export function useGetModifiersByCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory1>>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory1>>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory1>>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐햦 향햟 혝햦쮏
 */

export function useGetModifiersByCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory1>>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersByCategory1InfiniteQueryOptions(category,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifiersByCategory1QueryOptions = <TData = Awaited<ReturnType<typeof getModifiersByCategory1>>, TError = ErrorResponse>(category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersByCategory1QueryKey(category);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersByCategory1>>> = ({ signal }) => getModifiersByCategory1(category, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(category),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersByCategory1QueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCategory1>>>
export type GetModifiersByCategory1QueryError = ErrorResponse


export function useGetModifiersByCategory1<TData = Awaited<ReturnType<typeof getModifiersByCategory1>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory1<TData = Awaited<ReturnType<typeof getModifiersByCategory1>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory1<TData = Awaited<ReturnType<typeof getModifiersByCategory1>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햪쮏얧쟴혰햨햟혝쮐햦 향햟 혝햦쮏
 */

export function useGetModifiersByCategory1<TData = Awaited<ReturnType<typeof getModifiersByCategory1>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersByCategory1QueryOptions(category,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 쮏쒫쫨 햢햟햫혰  햪쮏얧쟴혰햨햟혝쮐햦 햢햩혪 쒫쥃썛햟햫쮐 햨햟혝햣햡쮐혰혱 쮐햩혞햡
 * @summary 뤰햦햪햟혝햦 쒬혰 햪쮏얧쟴혰햨햟혝쮐햦 햢햩혪 햨쮏쫧쥄햣혝햫쮐 햨햟혝햣햡쮐혰혱 쮐햩혞햡
 */
export const getModifiersForServiceCategory1 = (
    categoryCode: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersForServiceCategory1200>(
      {url: `/price-calculation/modifiers/by-category/${categoryCode}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifiersForServiceCategory1QueryKey = (categoryCode: string,) => {
    return [`/price-calculation/modifiers/by-category/${categoryCode}`] as const;
    }

    
export const getGetModifiersForServiceCategory1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersForServiceCategory1QueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>> = ({ signal }) => getModifiersForServiceCategory1(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersForServiceCategory1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>
export type GetModifiersForServiceCategory1InfiniteQueryError = ErrorResponse


export function useGetModifiersForServiceCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햪쮏얧쟴혰햨햟혝쮐햦 햢햩혪 햨쮏쫧쥄햣혝햫쮐 햨햟혝햣햡쮐혰혱 쮐햩혞햡
 */

export function useGetModifiersForServiceCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersForServiceCategory1InfiniteQueryOptions(categoryCode,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifiersForServiceCategory1QueryOptions = <TData = Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersForServiceCategory1QueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>> = ({ signal }) => getModifiersForServiceCategory1(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersForServiceCategory1QueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>
export type GetModifiersForServiceCategory1QueryError = ErrorResponse


export function useGetModifiersForServiceCategory1<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory1<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory1<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쒬혰 햪쮏얧쟴혰햨햟혝쮐햦 햢햩혪 햨쮏쫧쥄햣혝햫쮐 햨햟혝햣햡쮐혰혱 쮐햩혞햡
 */

export function useGetModifiersForServiceCategory1<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersForServiceCategory1QueryOptions(categoryCode,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햠햟향쮏쒬 혡혰햫혞 햢햩혪 햣햢햪햣혝혞 향 햟햧혜-햩햦혜혝햟
 */
export const getBasePrice = (
    params: GetBasePriceParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetBasePrice200>(
      {url: `/price-calculation/base-price`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetBasePriceQueryKey = (params: GetBasePriceParams,) => {
    return [`/price-calculation/base-price`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBasePriceInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getBasePrice>>>, TError = ErrorResponse>(params: GetBasePriceParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBasePriceQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBasePrice>>> = ({ signal }) => getBasePrice(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBasePriceInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getBasePrice>>>
export type GetBasePriceInfiniteQueryError = ErrorResponse


export function useGetBasePriceInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasePrice>>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasePrice>>,
          TError,
          Awaited<ReturnType<typeof getBasePrice>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasePriceInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasePrice>>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasePrice>>,
          TError,
          Awaited<ReturnType<typeof getBasePrice>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasePriceInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasePrice>>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햠햟향쮏쒬 혡혰햫혞 햢햩혪 햣햢햪햣혝혞 향 햟햧혜-햩햦혜혝햟
 */

export function useGetBasePriceInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasePrice>>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBasePriceInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBasePriceQueryOptions = <TData = Awaited<ReturnType<typeof getBasePrice>>, TError = ErrorResponse>(params: GetBasePriceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBasePriceQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBasePrice>>> = ({ signal }) => getBasePrice(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBasePriceQueryResult = NonNullable<Awaited<ReturnType<typeof getBasePrice>>>
export type GetBasePriceQueryError = ErrorResponse


export function useGetBasePrice<TData = Awaited<ReturnType<typeof getBasePrice>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasePrice>>,
          TError,
          Awaited<ReturnType<typeof getBasePrice>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasePrice<TData = Awaited<ReturnType<typeof getBasePrice>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasePrice>>,
          TError,
          Awaited<ReturnType<typeof getBasePrice>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasePrice<TData = Awaited<ReturnType<typeof getBasePrice>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햠햟향쮏쒬 혡혰햫혞 햢햩혪 햣햢햪햣혝혞 향 햟햧혜-햩햦혜혝햟
 */

export function useGetBasePrice<TData = Awaited<ReturnType<typeof getBasePrice>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBasePriceQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햢쮐혝혞햫혰 햪쮏얧쟴혰햨햟혝쮐햦 햢햩혪 햨햟혝햣햡쮐혰혱
 */
export const getAvailableModifiersForCategory = (
    params: GetAvailableModifiersForCategoryParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAvailableModifiersForCategory200>(
      {url: `/price-calculation/available-modifiers`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAvailableModifiersForCategoryQueryKey = (params: GetAvailableModifiersForCategoryParams,) => {
    return [`/price-calculation/available-modifiers`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAvailableModifiersForCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>, TError = ErrorResponse>(params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableModifiersForCategoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>> = ({ signal }) => getAvailableModifiersForCategory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableModifiersForCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>
export type GetAvailableModifiersForCategoryInfiniteQueryError = ErrorResponse


export function useGetAvailableModifiersForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiersForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiersForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢쮐혝혞햫혰 햪쮏얧쟴혰햨햟혝쮐햦 햢햩혪 햨햟혝햣햡쮐혰혱
 */

export function useGetAvailableModifiersForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableModifiersForCategoryInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableModifiersForCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError = ErrorResponse>(params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableModifiersForCategoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>> = ({ signal }) => getAvailableModifiersForCategory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableModifiersForCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>
export type GetAvailableModifiersForCategoryQueryError = ErrorResponse


export function useGetAvailableModifiersForCategory<TData = Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiersForCategory<TData = Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiersForCategory<TData = Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢쮐혝혞햫혰 햪쮏얧쟴혰햨햟혝쮐햦 햢햩혪 햨햟혝햣햡쮐혰혱
 */

export function useGetAvailableModifiersForCategory<TData = Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableModifiersForCategoryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 햢햣혝햟햩혧햫햦햧 혰햢혜혞햪쮏 향햟햪쮏쒫햣햫햫혪 향 쮏햟혠혞햫햨쮏 쒫썜혝쮐혝혰 햢햩혪 햣햣햡햩혪햢혞 혝햟 혰햢혝쒫왐햢햤햣햫햫혪. 뉋쥃혩혢햟혮 혰햫혟쮐햪햟혡혰혩  햨햩혰혮햫혝햟, 혜햦혜쮏 햣햢햪햣혝혰 향 햢햣혝햟햩혰향햟혡혰혮혩 쒫썜혝쮐혝혰, 향햟햡햟햩혧햫혰 혜혞햪햦 혝햟 햢햟혝햦.
 * @summary 뤰햦햪햟혝햦 햢햣혝햟햩혧햫햦햧 혰햢혜혞햪쮏 향햟햪쮏쒫햣햫햫혪
 */
export const getOrderDetailedSummary = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDetailedSummaryResponse>(
      {url: `/orders/${orderId}/detailed-summary`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderDetailedSummaryQueryKey = (orderId: string,) => {
    return [`/orders/${orderId}/detailed-summary`] as const;
    }

    
export const getGetOrderDetailedSummaryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderDetailedSummary>>>, TError = ErrorResponse | void>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderDetailedSummaryQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderDetailedSummary>>> = ({ signal }) => getOrderDetailedSummary(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderDetailedSummaryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderDetailedSummary>>>
export type GetOrderDetailedSummaryInfiniteQueryError = ErrorResponse | void


export function useGetOrderDetailedSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDetailedSummary>>>, TError = ErrorResponse | void>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDetailedSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderDetailedSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDetailedSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDetailedSummary>>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDetailedSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderDetailedSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDetailedSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDetailedSummary>>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢햣혝햟햩혧햫햦햧 혰햢혜혞햪쮏 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderDetailedSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDetailedSummary>>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderDetailedSummaryInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderDetailedSummaryQueryOptions = <TData = Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError = ErrorResponse | void>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderDetailedSummaryQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderDetailedSummary>>> = ({ signal }) => getOrderDetailedSummary(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderDetailedSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderDetailedSummary>>>
export type GetOrderDetailedSummaryQueryError = ErrorResponse | void


export function useGetOrderDetailedSummary<TData = Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError = ErrorResponse | void>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDetailedSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderDetailedSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDetailedSummary<TData = Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDetailedSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderDetailedSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDetailedSummary<TData = Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢햣혝햟햩혧햫햦햧 혰햢혜혞햪쮏 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderDetailedSummary<TData = Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderDetailedSummaryQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 향햟햪쮏쒫햣햫햫혪 향햟 햧쮏 ID
 * @summary 뤰햦햪햟혝햦 향햟햪쮏쒫햣햫햫혪 향햟 ID
 */
export const getOrderById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderByIdQueryKey = (id: string,) => {
    return [`/orders/${id}`] as const;
    }

    
export const getGetOrderByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({ signal }) => getOrderById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderById>>>
export type GetOrderByIdInfiniteQueryError = ErrorResponse


export function useGetOrderByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 향햟햪쮏쒫햣햫햫혪 향햟 ID
 */

export function useGetOrderByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderByIdQueryOptions = <TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({ signal }) => getOrderById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderById>>>
export type GetOrderByIdQueryError = ErrorResponse


export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 향햟햪쮏쒫햣햫햫혪 향햟 ID
 */

export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 PDF-혟햟햧햩 향 혢햣햨쮏 햢햩혪 향햟쒫썛쫨햟햤햣햫햫혪
 * @summary 뤰햦햪햟혝햦 PDF-혢햣햨 향햟햪쮏쒫햣햫햫혪
 */
export const getOrderReceipt = (
    orderId: string,
    params?: GetOrderReceiptParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetOrderReceipt200>(
      {url: `/orders/finalization/${orderId}/receipt`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetOrderReceiptQueryKey = (orderId: string,
    params?: GetOrderReceiptParams,) => {
    return [`/orders/finalization/${orderId}/receipt`, ...(params ? [params]: [])] as const;
    }

    
export const getGetOrderReceiptInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderReceipt>>>, TError = ErrorResponse>(orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderReceiptQueryKey(orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderReceipt>>> = ({ signal }) => getOrderReceipt(orderId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderReceiptInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderReceipt>>>
export type GetOrderReceiptInfiniteQueryError = ErrorResponse


export function useGetOrderReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderReceipt>>>, TError = ErrorResponse>(
 orderId: string,
    params: undefined |  GetOrderReceiptParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderReceipt>>,
          TError,
          Awaited<ReturnType<typeof getOrderReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderReceipt>>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderReceipt>>,
          TError,
          Awaited<ReturnType<typeof getOrderReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderReceipt>>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 PDF-혢햣햨 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderReceipt>>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderReceiptInfiniteQueryOptions(orderId,params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderReceiptQueryOptions = <TData = Awaited<ReturnType<typeof getOrderReceipt>>, TError = ErrorResponse>(orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderReceiptQueryKey(orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderReceipt>>> = ({ signal }) => getOrderReceipt(orderId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderReceiptQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderReceipt>>>
export type GetOrderReceiptQueryError = ErrorResponse


export function useGetOrderReceipt<TData = Awaited<ReturnType<typeof getOrderReceipt>>, TError = ErrorResponse>(
 orderId: string,
    params: undefined |  GetOrderReceiptParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderReceipt>>,
          TError,
          Awaited<ReturnType<typeof getOrderReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderReceipt<TData = Awaited<ReturnType<typeof getOrderReceipt>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderReceipt>>,
          TError,
          Awaited<ReturnType<typeof getOrderReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderReceipt<TData = Awaited<ReturnType<typeof getOrderReceipt>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 PDF-혢햣햨 향햟햪쮏쒫햣햫햫혪
 */

export function useGetOrderReceipt<TData = Awaited<ReturnType<typeof getOrderReceipt>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderReceiptQueryOptions(orderId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 혢햣햫햣혝쮏 향햟햪쮏쒫햣햫혧
 * @summary 뤰햦햪햟혝햦 혢햣햫햣혝햨햦 향햟햪쮏쒫햣햫혧
 */
export const getDraftOrders = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO[]>(
      {url: `/orders/drafts`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDraftOrdersQueryKey = () => {
    return [`/orders/drafts`] as const;
    }

    
export const getGetDraftOrdersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDraftOrders>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDraftOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDraftOrders>>> = ({ signal }) => getDraftOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDraftOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDraftOrders>>>
export type GetDraftOrdersInfiniteQueryError = ErrorResponse


export function useGetDraftOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDraftOrders>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftOrders>>,
          TError,
          Awaited<ReturnType<typeof getDraftOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDraftOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDraftOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftOrders>>,
          TError,
          Awaited<ReturnType<typeof getDraftOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDraftOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDraftOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혢햣햫햣혝햨햦 향햟햪쮏쒫햣햫혧
 */

export function useGetDraftOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDraftOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDraftOrdersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDraftOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getDraftOrders>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDraftOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDraftOrders>>> = ({ signal }) => getDraftOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDraftOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getDraftOrders>>>
export type GetDraftOrdersQueryError = ErrorResponse


export function useGetDraftOrders<TData = Awaited<ReturnType<typeof getDraftOrders>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftOrders>>,
          TError,
          Awaited<ReturnType<typeof getDraftOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDraftOrders<TData = Awaited<ReturnType<typeof getDraftOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftOrders>>,
          TError,
          Awaited<ReturnType<typeof getDraftOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDraftOrders<TData = Awaited<ReturnType<typeof getDraftOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혢햣햫햣혝햨햦 향햟햪쮏쒫햣햫혧
 */

export function useGetDraftOrders<TData = Awaited<ReturnType<typeof getDraftOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDraftOrdersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 햢햣혝햟햩혧햫혞 혰햫혟쮐햪햟혡혰혩  향햫햦햤햨혞 햢 향햟햪쮏쒫햣햫햫혪
 * @summary 뤰햦햪햟혝햦 혰햫혟쮐햪햟혡혰혩  향햫햦햤햨혞
 */
export const getOrderDiscount = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetOrderDiscount200>(
      {url: `/orders/discounts/${orderId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderDiscountQueryKey = (orderId: string,) => {
    return [`/orders/discounts/${orderId}`] as const;
    }

    
export const getGetOrderDiscountInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderDiscount>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderDiscountQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderDiscount>>> = ({ signal }) => getOrderDiscount(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderDiscountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderDiscount>>>
export type GetOrderDiscountInfiniteQueryError = ErrorResponse


export function useGetOrderDiscountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDiscount>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDiscount>>,
          TError,
          Awaited<ReturnType<typeof getOrderDiscount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDiscountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDiscount>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDiscount>>,
          TError,
          Awaited<ReturnType<typeof getOrderDiscount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDiscountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDiscount>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혰햫혟쮐햪햟혡혰혩  향햫햦햤햨혞
 */

export function useGetOrderDiscountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDiscount>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderDiscountInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderDiscountQueryOptions = <TData = Awaited<ReturnType<typeof getOrderDiscount>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderDiscountQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderDiscount>>> = ({ signal }) => getOrderDiscount(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderDiscountQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderDiscount>>>
export type GetOrderDiscountQueryError = ErrorResponse


export function useGetOrderDiscount<TData = Awaited<ReturnType<typeof getOrderDiscount>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDiscount>>,
          TError,
          Awaited<ReturnType<typeof getOrderDiscount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDiscount<TData = Awaited<ReturnType<typeof getOrderDiscount>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDiscount>>,
          TError,
          Awaited<ReturnType<typeof getOrderDiscount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDiscount<TData = Awaited<ReturnType<typeof getOrderDiscount>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혰햫혟쮐햪햟혡혰혩  향햫햦햤햨혞
 */

export function useGetOrderDiscount<TData = Awaited<ReturnType<typeof getOrderDiscount>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderDiscountQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 뉋쟳얧썛혪혮 향햫햦햤햨혞 향 향햟햪쮏쒫햣햫햫혪
 * @summary 햐햨햟혜혞쒫썜햦 향햫햦햤햨혞
 */
export const removeDiscount = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<RemoveDiscount200>(
      {url: `/orders/discounts/${orderId}`, method: 'DELETE'
    },
      options);
    }
  


export const getRemoveDiscountMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeDiscount>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof removeDiscount>>, TError,{orderId: string}, TContext> => {

const mutationKey = ['removeDiscount'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeDiscount>>, {orderId: string}> = (props) => {
          const {orderId} = props ?? {};

          return  removeDiscount(orderId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveDiscountMutationResult = NonNullable<Awaited<ReturnType<typeof removeDiscount>>>
    
    export type RemoveDiscountMutationError = ErrorResponse

    /**
 * @summary 햐햨햟혜혞쒫썜햦 향햫햦햤햨혞
 */
export const useRemoveDiscount = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeDiscount>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeDiscount>>,
        TError,
        {orderId: string},
        TContext
      > => {

      const mutationOptions = getRemoveDiscountMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 햟햨혝햦쒫쫧쟴 향햟햪쮏쒫햣햫혧
 * @summary 뤰햦햪햟혝햦 햟햨혝햦쒫쫨 향햟햪쮏쒫햣햫햫혪
 */
export const getActiveOrders = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO[]>(
      {url: `/orders/active`, method: 'GET', signal
    },
      options);
    }
  

export const getGetActiveOrdersQueryKey = () => {
    return [`/orders/active`] as const;
    }

    
export const getGetActiveOrdersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getActiveOrders>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveOrders>>> = ({ signal }) => getActiveOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveOrders>>>
export type GetActiveOrdersInfiniteQueryError = ErrorResponse


export function useGetActiveOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveOrders>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveOrders>>,
          TError,
          Awaited<ReturnType<typeof getActiveOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveOrders>>,
          TError,
          Awaited<ReturnType<typeof getActiveOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햟햨혝햦쒫쫨 향햟햪쮏쒫햣햫햫혪
 */

export function useGetActiveOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActiveOrdersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActiveOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getActiveOrders>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveOrders>>> = ({ signal }) => getActiveOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveOrders>>>
export type GetActiveOrdersQueryError = ErrorResponse


export function useGetActiveOrders<TData = Awaited<ReturnType<typeof getActiveOrders>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveOrders>>,
          TError,
          Awaited<ReturnType<typeof getActiveOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveOrders<TData = Awaited<ReturnType<typeof getActiveOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveOrders>>,
          TError,
          Awaited<ReturnType<typeof getActiveOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveOrders<TData = Awaited<ReturnType<typeof getActiveOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햟햨혝햦쒫쫨 향햟햪쮏쒫햣햫햫혪
 */

export function useGetActiveOrders<TData = Awaited<ReturnType<typeof getActiveOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActiveOrdersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햓햩쮐-햨햟혝햟 Order Wizard 햢햩혪 혟쮏쫨햣햫햢혞
 */
export const getWorkflow = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<WorkflowMap>(
      {url: `/order-wizard/workflow`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWorkflowQueryKey = () => {
    return [`/order-wizard/workflow`] as const;
    }

    
export const getGetWorkflowInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getWorkflow>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflow>>> = ({ signal }) => getWorkflow(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflow>>>
export type GetWorkflowInfiniteQueryError = ErrorResponse


export function useGetWorkflowInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWorkflow>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getWorkflow>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWorkflow>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getWorkflow>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWorkflow>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햓햩쮐-햨햟혝햟 Order Wizard 햢햩혪 혟쮏쫨햣햫햢혞
 */

export function useGetWorkflowInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWorkflow>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflow>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflow>>> = ({ signal }) => getWorkflow(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflow>>>
export type GetWorkflowQueryError = ErrorResponse


export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getWorkflow>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getWorkflow>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햓햩쮐-햨햟혝햟 Order Wizard 햢햩혪 혟쮏쫨햣햫햢혞
 */

export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 행햟햡햟햩혧햫햟 혜혝햟혝햦혜혝햦햨햟 혜햦혜혝햣햪햦
 */
export const getSystemStats = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SystemStats>(
      {url: `/order-wizard/stats`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSystemStatsQueryKey = () => {
    return [`/order-wizard/stats`] as const;
    }

    
export const getGetSystemStatsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSystemStats>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSystemStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemStats>>> = ({ signal }) => getSystemStats(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSystemStatsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSystemStats>>>
export type GetSystemStatsInfiniteQueryError = ErrorResponse


export function useGetSystemStatsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSystemStats>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemStats>>,
          TError,
          Awaited<ReturnType<typeof getSystemStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSystemStatsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSystemStats>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemStats>>,
          TError,
          Awaited<ReturnType<typeof getSystemStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSystemStatsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSystemStats>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 행햟햡햟햩혧햫햟 혜혝햟혝햦혜혝햦햨햟 혜햦혜혝햣햪햦
 */

export function useGetSystemStatsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSystemStats>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSystemStatsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSystemStatsQueryOptions = <TData = Awaited<ReturnType<typeof getSystemStats>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSystemStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemStats>>> = ({ signal }) => getSystemStats(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSystemStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getSystemStats>>>
export type GetSystemStatsQueryError = ErrorResponse


export function useGetSystemStats<TData = Awaited<ReturnType<typeof getSystemStats>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemStats>>,
          TError,
          Awaited<ReturnType<typeof getSystemStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSystemStats<TData = Awaited<ReturnType<typeof getSystemStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemStats>>,
          TError,
          Awaited<ReturnType<typeof getSystemStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSystemStats<TData = Awaited<ReturnType<typeof getSystemStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 행햟햡햟햩혧햫햟 혜혝햟혝햦혜혝햦햨햟 혜햦혜혝햣햪햦
 */

export function useGetSystemStats<TData = Awaited<ReturnType<typeof getSystemStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSystemStatsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햆햣혝햟햩혧햫햦햧 혜혝햟혝혞혜 햨쮏쫧쥄햣혝햫쮏 햣혝햟혞
 */
export const getStageStatus = (
    stageNumber: number,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StageStatus>(
      {url: `/order-wizard/stages/${stageNumber}/status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStageStatusQueryKey = (stageNumber: number,) => {
    return [`/order-wizard/stages/${stageNumber}/status`] as const;
    }

    
export const getGetStageStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStageStatus>>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStageStatusQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStageStatus>>> = ({ signal }) => getStageStatus(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStageStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStageStatus>>>
export type GetStageStatusInfiniteQueryError = ErrorResponse


export function useGetStageStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageStatus>>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageStatus>>,
          TError,
          Awaited<ReturnType<typeof getStageStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageStatus>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageStatus>>,
          TError,
          Awaited<ReturnType<typeof getStageStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageStatus>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햆햣혝햟햩혧햫햦햧 혜혝햟혝혞혜 햨쮏쫧쥄햣혝햫쮏 햣혝햟혞
 */

export function useGetStageStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageStatus>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStageStatusInfiniteQueryOptions(stageNumber,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStageStatusQueryOptions = <TData = Awaited<ReturnType<typeof getStageStatus>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStageStatusQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStageStatus>>> = ({ signal }) => getStageStatus(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStageStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getStageStatus>>>
export type GetStageStatusQueryError = ErrorResponse


export function useGetStageStatus<TData = Awaited<ReturnType<typeof getStageStatus>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageStatus>>,
          TError,
          Awaited<ReturnType<typeof getStageStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageStatus<TData = Awaited<ReturnType<typeof getStageStatus>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageStatus>>,
          TError,
          Awaited<ReturnType<typeof getStageStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageStatus<TData = Awaited<ReturnType<typeof getStageStatus>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햆햣혝햟햩혧햫햦햧 혜혝햟혝혞혜 햨쮏쫧쥄햣혝햫쮏 햣혝햟혞
 */

export function useGetStageStatus<TData = Awaited<ReturnType<typeof getStageStatus>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStageStatusQueryOptions(stageNumber,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햆쮏쥄햪햣햫혝햟혡혰혪  햪햣혝쮏얧썜 햨쮏쫧쥄햣혝햫쮏 햣혝햟혞
 */
export const getStageMethods = (
    stageNumber: number,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StageMethods>(
      {url: `/order-wizard/stages/${stageNumber}/methods`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStageMethodsQueryKey = (stageNumber: number,) => {
    return [`/order-wizard/stages/${stageNumber}/methods`] as const;
    }

    
export const getGetStageMethodsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStageMethods>>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStageMethodsQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStageMethods>>> = ({ signal }) => getStageMethods(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStageMethodsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStageMethods>>>
export type GetStageMethodsInfiniteQueryError = ErrorResponse


export function useGetStageMethodsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageMethods>>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageMethods>>,
          TError,
          Awaited<ReturnType<typeof getStageMethods>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageMethodsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageMethods>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageMethods>>,
          TError,
          Awaited<ReturnType<typeof getStageMethods>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageMethodsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageMethods>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햆쮏쥄햪햣햫혝햟혡혰혪  햪햣혝쮏얧썜 햨쮏쫧쥄햣혝햫쮏 햣혝햟혞
 */

export function useGetStageMethodsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageMethods>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStageMethodsInfiniteQueryOptions(stageNumber,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStageMethodsQueryOptions = <TData = Awaited<ReturnType<typeof getStageMethods>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStageMethodsQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStageMethods>>> = ({ signal }) => getStageMethods(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStageMethodsQueryResult = NonNullable<Awaited<ReturnType<typeof getStageMethods>>>
export type GetStageMethodsQueryError = ErrorResponse


export function useGetStageMethods<TData = Awaited<ReturnType<typeof getStageMethods>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageMethods>>,
          TError,
          Awaited<ReturnType<typeof getStageMethods>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageMethods<TData = Awaited<ReturnType<typeof getStageMethods>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageMethods>>,
          TError,
          Awaited<ReturnType<typeof getStageMethods>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageMethods<TData = Awaited<ReturnType<typeof getStageMethods>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햆쮏쥄햪햣햫혝햟혡혰혪  햪햣혝쮏얧썜 햨쮏쫧쥄햣혝햫쮏 햣혝햟혞
 */

export function useGetStageMethods<TData = Awaited<ReturnType<typeof getStageMethods>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStageMethodsQueryOptions(stageNumber,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햆햣혝햟햩혧햫햟 혰햫혟쮐햪햟혡혰혪  햨쮏쫧쥄햣혝햫햦햧 햣혝햟
 */
export const getStageInfo = (
    stageNumber: number,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StageInfo>(
      {url: `/order-wizard/stages/${stageNumber}/info`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStageInfoQueryKey = (stageNumber: number,) => {
    return [`/order-wizard/stages/${stageNumber}/info`] as const;
    }

    
export const getGetStageInfoInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStageInfo>>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStageInfoQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStageInfo>>> = ({ signal }) => getStageInfo(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStageInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStageInfo>>>
export type GetStageInfoInfiniteQueryError = ErrorResponse


export function useGetStageInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageInfo>>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageInfo>>,
          TError,
          Awaited<ReturnType<typeof getStageInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageInfo>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageInfo>>,
          TError,
          Awaited<ReturnType<typeof getStageInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageInfo>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햆햣혝햟햩혧햫햟 혰햫혟쮐햪햟혡혰혪  햨쮏쫧쥄햣혝햫햦햧 햣혝햟
 */

export function useGetStageInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStageInfo>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStageInfoInfiniteQueryOptions(stageNumber,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStageInfoQueryOptions = <TData = Awaited<ReturnType<typeof getStageInfo>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStageInfoQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStageInfo>>> = ({ signal }) => getStageInfo(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStageInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getStageInfo>>>
export type GetStageInfoQueryError = ErrorResponse


export function useGetStageInfo<TData = Awaited<ReturnType<typeof getStageInfo>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageInfo>>,
          TError,
          Awaited<ReturnType<typeof getStageInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageInfo<TData = Awaited<ReturnType<typeof getStageInfo>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStageInfo>>,
          TError,
          Awaited<ReturnType<typeof getStageInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStageInfo<TData = Awaited<ReturnType<typeof getStageInfo>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햆햣혝햟햩혧햫햟 혰햫혟쮐햪햟혡혰혪  햨쮏쫧쥄햣혝햫햦햧 햣혝햟
 */

export function useGetStageInfo<TData = Awaited<ReturnType<typeof getStageInfo>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStageInfoQueryOptions(stageNumber,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햐혝햟혝혞혜햦 햡쮐쮏쒫쫧쮐혝혰 쒬혰혠 햣혝햟혰
 */
export const getStagesStatus = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StagesStatus>(
      {url: `/order-wizard/stages/status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStagesStatusQueryKey = () => {
    return [`/order-wizard/stages/status`] as const;
    }

    
export const getGetStagesStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStagesStatus>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStagesStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStagesStatus>>> = ({ signal }) => getStagesStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStagesStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStagesStatus>>>
export type GetStagesStatusInfiniteQueryError = ErrorResponse


export function useGetStagesStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStagesStatus>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStagesStatus>>,
          TError,
          Awaited<ReturnType<typeof getStagesStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStagesStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStagesStatus>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStagesStatus>>,
          TError,
          Awaited<ReturnType<typeof getStagesStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStagesStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStagesStatus>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햐혝햟혝혞혜햦 햡쮐쮏쒫쫧쮐혝혰 쒬혰혠 햣혝햟혰
 */

export function useGetStagesStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStagesStatus>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStagesStatusInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStagesStatusQueryOptions = <TData = Awaited<ReturnType<typeof getStagesStatus>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStagesStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStagesStatus>>> = ({ signal }) => getStagesStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStagesStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getStagesStatus>>>
export type GetStagesStatusQueryError = ErrorResponse


export function useGetStagesStatus<TData = Awaited<ReturnType<typeof getStagesStatus>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStagesStatus>>,
          TError,
          Awaited<ReturnType<typeof getStagesStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStagesStatus<TData = Awaited<ReturnType<typeof getStagesStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStagesStatus>>,
          TError,
          Awaited<ReturnType<typeof getStagesStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStagesStatus<TData = Awaited<ReturnType<typeof getStagesStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햐혝햟혝혞혜햦 햡쮐쮏쒫쫧쮐혝혰 쒬혰혠 햣혝햟혰
 */

export function useGetStagesStatus<TData = Awaited<ReturnType<typeof getStagesStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStagesStatusQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 햣햣쒬뒘햨햟 햡쮐쮏쒫쫧쮐혝혰 Order Wizard API
 */
export const health = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<HealthStatus>(
      {url: `/order-wizard/health`, method: 'GET', signal
    },
      options);
    }
  

export const getHealthQueryKey = () => {
    return [`/order-wizard/health`] as const;
    }

    
export const getHealthInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof health>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof health>>> = ({ signal }) => health(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof health>>>
export type HealthInfiniteQueryError = ErrorResponse


export function useHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof health>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof health>>,
          TError,
          Awaited<ReturnType<typeof health>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof health>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof health>>,
          TError,
          Awaited<ReturnType<typeof health>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof health>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햨햟 햡쮐쮏쒫쫧쮐혝혰 Order Wizard API
 */

export function useHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof health>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getHealthQueryOptions = <TData = Awaited<ReturnType<typeof health>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof health>>> = ({ signal }) => health(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthQueryResult = NonNullable<Awaited<ReturnType<typeof health>>>
export type HealthQueryError = ErrorResponse


export function useHealth<TData = Awaited<ReturnType<typeof health>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof health>>,
          TError,
          Awaited<ReturnType<typeof health>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealth<TData = Awaited<ReturnType<typeof health>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof health>>,
          TError,
          Awaited<ReturnType<typeof health>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealth<TData = Awaited<ReturnType<typeof health>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햨햟 햡쮐쮏쒫쫧쮐혝혰 Order Wizard API
 */

export function useHealth<TData = Awaited<ReturnType<typeof health>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 쮏쒫쫧 햪햟햟 쒬혰혠 햢쮐혝혞햫햦혠 API endpoints
 */
export const getCompleteApiMap = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CompleteApiMap>(
      {url: `/order-wizard/api-map`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCompleteApiMapQueryKey = () => {
    return [`/order-wizard/api-map`] as const;
    }

    
export const getGetCompleteApiMapInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCompleteApiMap>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCompleteApiMapQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompleteApiMap>>> = ({ signal }) => getCompleteApiMap(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCompleteApiMapInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCompleteApiMap>>>
export type GetCompleteApiMapInfiniteQueryError = ErrorResponse


export function useGetCompleteApiMapInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCompleteApiMap>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompleteApiMap>>,
          TError,
          Awaited<ReturnType<typeof getCompleteApiMap>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCompleteApiMapInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCompleteApiMap>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompleteApiMap>>,
          TError,
          Awaited<ReturnType<typeof getCompleteApiMap>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCompleteApiMapInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCompleteApiMap>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 쮏쒫쫧 햪햟햟 쒬혰혠 햢쮐혝혞햫햦혠 API endpoints
 */

export function useGetCompleteApiMapInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCompleteApiMap>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCompleteApiMapInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCompleteApiMapQueryOptions = <TData = Awaited<ReturnType<typeof getCompleteApiMap>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCompleteApiMapQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompleteApiMap>>> = ({ signal }) => getCompleteApiMap(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCompleteApiMapQueryResult = NonNullable<Awaited<ReturnType<typeof getCompleteApiMap>>>
export type GetCompleteApiMapQueryError = ErrorResponse


export function useGetCompleteApiMap<TData = Awaited<ReturnType<typeof getCompleteApiMap>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompleteApiMap>>,
          TError,
          Awaited<ReturnType<typeof getCompleteApiMap>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCompleteApiMap<TData = Awaited<ReturnType<typeof getCompleteApiMap>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompleteApiMap>>,
          TError,
          Awaited<ReturnType<typeof getCompleteApiMap>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCompleteApiMap<TData = Awaited<ReturnType<typeof getCompleteApiMap>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 쮏쒫쫧 햪햟햟 쒬혰혠 햢쮐혝혞햫햦혠 API endpoints
 */

export function useGetCompleteApiMap<TData = Awaited<ReturnType<typeof getCompleteApiMap>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCompleteApiMapQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 쮏쒫쫧 혰햫혟쮐햪햟혡혰혪  쒬혰 햟햢햟혝햣햦
 */
export const getAdaptersInfo = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<AdaptersInfo>(
      {url: `/order-wizard/adapters`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdaptersInfoQueryKey = () => {
    return [`/order-wizard/adapters`] as const;
    }

    
export const getGetAdaptersInfoInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdaptersInfo>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdaptersInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdaptersInfo>>> = ({ signal }) => getAdaptersInfo(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdaptersInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdaptersInfo>>>
export type GetAdaptersInfoInfiniteQueryError = ErrorResponse


export function useGetAdaptersInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdaptersInfo>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdaptersInfo>>,
          TError,
          Awaited<ReturnType<typeof getAdaptersInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdaptersInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdaptersInfo>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdaptersInfo>>,
          TError,
          Awaited<ReturnType<typeof getAdaptersInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdaptersInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdaptersInfo>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 쮏쒫쫧 혰햫혟쮐햪햟혡혰혪  쒬혰 햟햢햟혝햣햦
 */

export function useGetAdaptersInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdaptersInfo>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdaptersInfoInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdaptersInfoQueryOptions = <TData = Awaited<ReturnType<typeof getAdaptersInfo>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdaptersInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdaptersInfo>>> = ({ signal }) => getAdaptersInfo(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdaptersInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getAdaptersInfo>>>
export type GetAdaptersInfoQueryError = ErrorResponse


export function useGetAdaptersInfo<TData = Awaited<ReturnType<typeof getAdaptersInfo>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdaptersInfo>>,
          TError,
          Awaited<ReturnType<typeof getAdaptersInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdaptersInfo<TData = Awaited<ReturnType<typeof getAdaptersInfo>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdaptersInfo>>,
          TError,
          Awaited<ReturnType<typeof getAdaptersInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdaptersInfo<TData = Awaited<ReturnType<typeof getAdaptersInfo>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 쮏쒫쫧 혰햫혟쮐햪햟혡혰혪  쒬혰 햟햢햟혝햣햦
 */

export function useGetAdaptersInfo<TData = Awaited<ReturnType<typeof getAdaptersInfo>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdaptersInfoQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 뤰햦햪혞혮 혰햫혟쮐햪햟혡혰혩  햨쮏쫧쥄햣혝햫혞 혟쮐쮏햟혟혰혩 햣햢햪햣혝햟 향햟햪쮏쒫햣햫햫혪
 * @summary 뤰햦햪햟혝햦 혟쮐쮏햟혟혰혩 향햟 ID
 */
export const getPhotoById = (
    itemId: string,
    photoId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderItemPhotoDTO>(
      {url: `/order-items/${itemId}/photos/${photoId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPhotoByIdQueryKey = (itemId: string,
    photoId: string,) => {
    return [`/order-items/${itemId}/photos/${photoId}`] as const;
    }

    
export const getGetPhotoByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPhotoById>>>, TError = ErrorResponse>(itemId: string,
    photoId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhotoByIdQueryKey(itemId,photoId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotoById>>> = ({ signal }) => getPhotoById(itemId,photoId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId && photoId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPhotoByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotoById>>>
export type GetPhotoByIdInfiniteQueryError = ErrorResponse


export function useGetPhotoByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotoById>>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotoById>>,
          TError,
          Awaited<ReturnType<typeof getPhotoById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotoByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotoById>>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotoById>>,
          TError,
          Awaited<ReturnType<typeof getPhotoById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotoByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotoById>>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혟쮐쮏햟혟혰혩 향햟 ID
 */

export function useGetPhotoByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotoById>>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPhotoByIdInfiniteQueryOptions(itemId,photoId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPhotoByIdQueryOptions = <TData = Awaited<ReturnType<typeof getPhotoById>>, TError = ErrorResponse>(itemId: string,
    photoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhotoByIdQueryKey(itemId,photoId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotoById>>> = ({ signal }) => getPhotoById(itemId,photoId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId && photoId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPhotoByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotoById>>>
export type GetPhotoByIdQueryError = ErrorResponse


export function useGetPhotoById<TData = Awaited<ReturnType<typeof getPhotoById>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotoById>>,
          TError,
          Awaited<ReturnType<typeof getPhotoById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotoById<TData = Awaited<ReturnType<typeof getPhotoById>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotoById>>,
          TError,
          Awaited<ReturnType<typeof getPhotoById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotoById<TData = Awaited<ReturnType<typeof getPhotoById>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혟쮐쮏햟혟혰혩 향햟 ID
 */

export function useGetPhotoById<TData = Awaited<ReturnType<typeof getPhotoById>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPhotoByIdQueryOptions(itemId,photoId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 뉋쟳얧썛혪혮 쒫쥃썛햟햫혞 혟쮐쮏햟혟혰혩 햣햢햪햣혝햟 향햟햪쮏쒫햣햫햫혪
 * @summary 뉋쟳얧썛햦혝햦 혟쮐쮏햟혟혰혩
 */
export const deletePhoto = (
    itemId: string,
    photoId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeletePhoto204>(
      {url: `/order-items/${itemId}/photos/${photoId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeletePhotoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePhoto>>, TError,{itemId: string;photoId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePhoto>>, TError,{itemId: string;photoId: string}, TContext> => {

const mutationKey = ['deletePhoto'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePhoto>>, {itemId: string;photoId: string}> = (props) => {
          const {itemId,photoId} = props ?? {};

          return  deletePhoto(itemId,photoId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePhotoMutationResult = NonNullable<Awaited<ReturnType<typeof deletePhoto>>>
    
    export type DeletePhotoMutationError = ErrorResponse

    /**
 * @summary 뉋쟳얧썛햦혝햦 혟쮐쮏햟혟혰혩
 */
export const useDeletePhoto = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePhoto>>, TError,{itemId: string;photoId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePhoto>>,
        TError,
        {itemId: string;photoId: string},
        TContext
      > => {

      const mutationOptions = getDeletePhotoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 햣햨쮏쨿왏쫧얧쮏쒫썛쫧쟴 햪쮏얧쟴혰햨햟혝쮐혰 혡혰햫 햫햟 쮐햫쮏쒬 쒫쥃썛햟햫햦혠 혝햦혰 햩혪햪, 햨햟혝햣햡쮐혰혱 혝햟 햪햟혝햣혰햟햩혞
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 햪쮏얧쟴혰햨햟혝쮐햦 햫햟 쮐햫쮏쒬 햩혪햪
 */
export const getRecommendedModifiersForStains = (
    params: GetRecommendedModifiersForStainsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ModifierRecommendationDTO[]>(
      {url: `/modifier-recommendations/stains`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedModifiersForStainsQueryKey = (params: GetRecommendedModifiersForStainsParams,) => {
    return [`/modifier-recommendations/stains`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedModifiersForStainsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForStainsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>> = ({ signal }) => getRecommendedModifiersForStains(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForStainsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>
export type GetRecommendedModifiersForStainsInfiniteQueryError = ErrorResponse


export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 햪쮏얧쟴혰햨햟혝쮐햦 햫햟 쮐햫쮏쒬 햩혪햪
 */

export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForStainsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedModifiersForStainsQueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForStainsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>> = ({ signal }) => getRecommendedModifiersForStains(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForStainsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>
export type GetRecommendedModifiersForStainsQueryError = ErrorResponse


export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 햪쮏얧쟴혰햨햟혝쮐햦 햫햟 쮐햫쮏쒬 햩혪햪
 */

export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForStainsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 쮏햣햣햢햤햣햫혧  햦향햦햨햦 햫햟 쮐햫쮏쒬 쒫쥃썛햟햫햦혠 햩혪햪, 햢햣혟햣햨혝혰, 햪햟혝햣혰햟햩혞 혝햟 햨햟혝햣햡쮐혰혱
 * @summary 뤰햦햪햟혝햦 쮏햣햣햢햤햣햫햫혪  햦향햦햨햦
 */
export const getRiskWarningsForItem = (
    params?: GetRiskWarningsForItemParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/modifier-recommendations/risks`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRiskWarningsForItemQueryKey = (params?: GetRiskWarningsForItemParams,) => {
    return [`/modifier-recommendations/risks`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRiskWarningsForItemInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRiskWarningsForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRiskWarningsForItem>>> = ({ signal }) => getRiskWarningsForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRiskWarningsForItemInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRiskWarningsForItem>>>
export type GetRiskWarningsForItemInfiniteQueryError = ErrorResponse


export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params: undefined |  GetRiskWarningsForItemParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쮏햣햣햢햤햣햫햫혪  햦향햦햨햦
 */

export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRiskWarningsForItemInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRiskWarningsForItemQueryOptions = <TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRiskWarningsForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRiskWarningsForItem>>> = ({ signal }) => getRiskWarningsForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRiskWarningsForItemQueryResult = NonNullable<Awaited<ReturnType<typeof getRiskWarningsForItem>>>
export type GetRiskWarningsForItemQueryError = ErrorResponse


export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params: undefined |  GetRiskWarningsForItemParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 쮏햣햣햢햤햣햫햫혪  햦향햦햨햦
 */

export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRiskWarningsForItemQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혜햦혜쮏 햣햨쮏쨿왏쫧얧쮏쒫썛쫧쟴 햪쮏얧쟴혰햨햟혝쮐혰 혡혰햫 햫햟 쮐햫쮏쒬 쒫쥃썛햟햫햦혠 혝햦혰 햢햣혟햣햨혝혰, 햨햟혝햣햡쮐혰혱 혝햟 햪햟혝햣혰햟햩혞
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 햪쮏얧쟴혰햨햟혝쮐햦 햫햟 쮐햫쮏쒬 햢햣혟햣햨혝혰
 */
export const getRecommendedModifiersForDefects = (
    params: GetRecommendedModifiersForDefectsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ModifierRecommendationDTO[]>(
      {url: `/modifier-recommendations/defects`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedModifiersForDefectsQueryKey = (params: GetRecommendedModifiersForDefectsParams,) => {
    return [`/modifier-recommendations/defects`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedModifiersForDefectsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForDefectsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>> = ({ signal }) => getRecommendedModifiersForDefects(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForDefectsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>
export type GetRecommendedModifiersForDefectsInfiniteQueryError = ErrorResponse


export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 햪쮏얧쟴혰햨햟혝쮐햦 햫햟 쮐햫쮏쒬 햢햣혟햣햨혝혰
 */

export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForDefectsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedModifiersForDefectsQueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForDefectsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>> = ({ signal }) => getRecommendedModifiersForDefects(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForDefectsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>
export type GetRecommendedModifiersForDefectsQueryError = ErrorResponse


export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햣햨쮏쨿왏쫧얧쮏쒫썛쫨 햪쮏얧쟴혰햨햟혝쮐햦 햫햟 쮐햫쮏쒬 햢햣혟햣햨혝혰
 */

export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForDefectsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 혜혝혞햣햫혰 향햫쮐혞 햢햩혪 햣햢햪햣혝혰
 */
export const getWearDegrees = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/wear-degrees`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWearDegreesQueryKey = () => {
    return [`/item-characteristics/wear-degrees`] as const;
    }

    
export const getGetWearDegreesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWearDegreesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWearDegrees>>> = ({ signal }) => getWearDegrees(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWearDegreesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWearDegrees>>>
export type GetWearDegreesInfiniteQueryError = ErrorResponse


export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혜혝혞햣햫혰 향햫쮐혞 햢햩혪 햣햢햪햣혝혰
 */

export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWearDegreesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWearDegreesQueryOptions = <TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWearDegreesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWearDegrees>>> = ({ signal }) => getWearDegrees(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWearDegreesQueryResult = NonNullable<Awaited<ReturnType<typeof getWearDegrees>>>
export type GetWearDegreesQueryError = ErrorResponse


export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혜혝혞햣햫혰 향햫쮐혞 햢햩혪 햣햢햪햣혝혰
 */

export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWearDegreesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 혝햦햦 햩혪햪 햢햩혪 햣햢햪햣혝혰
 */
export const getStainTypes1 = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/stain-types`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStainTypes1QueryKey = () => {
    return [`/item-characteristics/stain-types`] as const;
    }

    
export const getGetStainTypes1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypes1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes1>>> = ({ signal }) => getStainTypes1(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypes1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes1>>>
export type GetStainTypes1InfiniteQueryError = ErrorResponse


export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦햦 햩혪햪 햢햩혪 햣햢햪햣혝혰
 */

export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypes1InfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypes1QueryOptions = <TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypes1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes1>>> = ({ signal }) => getStainTypes1(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypes1QueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes1>>>
export type GetStainTypes1QueryError = ErrorResponse


export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦햦 햩혪햪 햢햩혪 햣햢햪햣혝혰
 */

export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypes1QueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 혝혰햩혧햨햦 햦향햦햨햦 햢햩혪 햣햢햪햣혝혰
 */
export const getRisks = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/risks`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRisksQueryKey = () => {
    return [`/item-characteristics/risks`] as const;
    }

    
export const getGetRisksInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRisks>>> = ({ signal }) => getRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRisksInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRisks>>>
export type GetRisksInfiniteQueryError = ErrorResponse


export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝혰햩혧햨햦 햦향햦햨햦 햢햩혪 햣햢햪햣혝혰
 */

export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRisksInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRisksQueryOptions = <TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRisks>>> = ({ signal }) => getRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRisksQueryResult = NonNullable<Awaited<ReturnType<typeof getRisks>>>
export type GetRisksQueryError = ErrorResponse


export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝혰햩혧햨햦 햦향햦햨햦 햢햩혪 햣햢햪햣혝혰
 */

export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRisksQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햢쮐혝혞햫혰 햪햟혝햣혰햟햩햦 햢햩혪 햣햢햪햣혝혰
 */
export const getMaterials = (
    params?: GetMaterialsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/materials`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetMaterialsQueryKey = (params?: GetMaterialsParams,) => {
    return [`/item-characteristics/materials`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMaterialsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterials>>> = ({ signal }) => getMaterials(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMaterialsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterials>>>
export type GetMaterialsInfiniteQueryError = ErrorResponse


export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params: undefined |  GetMaterialsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢쮐혝혞햫혰 햪햟혝햣혰햟햩햦 햢햩혪 햣햢햪햣혝혰
 */

export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMaterialsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialsQueryOptions = <TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterials>>> = ({ signal }) => getMaterials(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMaterialsQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterials>>>
export type GetMaterialsQueryError = ErrorResponse


export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params: undefined |  GetMaterialsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢쮐혝혞햫혰 햪햟혝햣혰햟햩햦 햢햩혪 햣햢햪햣혝혰
 */

export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMaterialsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 혝햦햦 햫햟쮏쒫쫨꿿쒫썜혰 햢햩혪 햣햢햪햣혝혰
 */
export const getFillerTypes = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/filler-types`, method: 'GET', signal
    },
      options);
    }
  

export const getGetFillerTypesQueryKey = () => {
    return [`/item-characteristics/filler-types`] as const;
    }

    
export const getGetFillerTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFillerTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFillerTypes>>> = ({ signal }) => getFillerTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFillerTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFillerTypes>>>
export type GetFillerTypesInfiniteQueryError = ErrorResponse


export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦햦 햫햟쮏쒫쫨꿿쒫썜혰 햢햩혪 햣햢햪햣혝혰
 */

export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFillerTypesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFillerTypesQueryOptions = <TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFillerTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFillerTypes>>> = ({ signal }) => getFillerTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFillerTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getFillerTypes>>>
export type GetFillerTypesQueryError = ErrorResponse


export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦햦 햫햟쮏쒫쫨꿿쒫썜혰 햢햩혪 햣햢햪햣혝혰
 */

export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFillerTypesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 혝혰햩혧햨햦 햢햣혟햣햨혝햦 햢햩혪 햣햢햪햣혝혰
 */
export const getDefects = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/defects`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectsQueryKey = () => {
    return [`/item-characteristics/defects`] as const;
    }

    
export const getGetDefectsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefects>>> = ({ signal }) => getDefects(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefects>>>
export type GetDefectsInfiniteQueryError = ErrorResponse


export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝혰햩혧햨햦 햢햣혟햣햨혝햦 햢햩혪 햣햢햪햣혝혰
 */

export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectsQueryOptions = <TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefects>>> = ({ signal }) => getDefects(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsQueryResult = NonNullable<Awaited<ReturnType<typeof getDefects>>>
export type GetDefectsQueryError = ErrorResponse


export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝혰햩혧햨햦 햢햣혟햣햨혝햦 햢햩혪 햣햢햪햣혝혰
 */

export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햢햣혟햣햨혝햦 혝햟 햦향햦햨햦 햢햩혪 햣햢햪햣혝혰
 */
export const getDefectsAndRisks = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/defects-and-risks`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectsAndRisksQueryKey = () => {
    return [`/item-characteristics/defects-and-risks`] as const;
    }

    
export const getGetDefectsAndRisksInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsAndRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectsAndRisks>>> = ({ signal }) => getDefectsAndRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsAndRisksInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectsAndRisks>>>
export type GetDefectsAndRisksInfiniteQueryError = ErrorResponse


export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢햣혟햣햨혝햦 혝햟 햦향햦햨햦 햢햩혪 햣햢햪햣혝혰
 */

export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsAndRisksInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectsAndRisksQueryOptions = <TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsAndRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectsAndRisks>>> = ({ signal }) => getDefectsAndRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsAndRisksQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectsAndRisks>>>
export type GetDefectsAndRisksQueryError = ErrorResponse


export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햢햣혟햣햨혝햦 혝햟 햦향햦햨햦 햢햩혪 햣햢햪햣혝혰
 */

export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsAndRisksQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 뤰햦햪햟혝햦 햠햟향쮏쒬 햨쮏혧쮐햦 햢햩혪 햣햢햪햣혝혰
 */
export const getColors = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/colors`, method: 'GET', signal
    },
      options);
    }
  

export const getGetColorsQueryKey = () => {
    return [`/item-characteristics/colors`] as const;
    }

    
export const getGetColorsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetColorsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getColors>>> = ({ signal }) => getColors(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetColorsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getColors>>>
export type GetColorsInfiniteQueryError = ErrorResponse


export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햠햟향쮏쒬 햨쮏혧쮐햦 햢햩혪 햣햢햪햣혝혰
 */

export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetColorsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetColorsQueryOptions = <TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetColorsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getColors>>> = ({ signal }) => getColors(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetColorsQueryResult = NonNullable<Awaited<ReturnType<typeof getColors>>>
export type GetColorsQueryError = ErrorResponse


export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 햠햟향쮏쒬 햨쮏혧쮐햦 햢햩혪 햣햢햪햣혝혰
 */

export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetColorsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혟햟햧햩 향햟 햧쮏 혞햫혰햨햟햩혧햫햦햪 혰햪햣햫햣햪
 * @summary 뤰햦햪햟혝햦 혟햟햧햩
 */
export const getFile = (
    fileName: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetFile200>(
      {url: `/files/${fileName}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetFileQueryKey = (fileName: string,) => {
    return [`/files/${fileName}`] as const;
    }

    
export const getGetFileInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getFile>>>, TError = ErrorResponse>(fileName: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileQueryKey(fileName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFile>>> = ({ signal }) => getFile(fileName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(fileName),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFile>>>
export type GetFileInfiniteQueryError = ErrorResponse


export function useGetFileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFile>>>, TError = ErrorResponse>(
 fileName: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFile>>,
          TError,
          Awaited<ReturnType<typeof getFile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFile>>>, TError = ErrorResponse>(
 fileName: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFile>>,
          TError,
          Awaited<ReturnType<typeof getFile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFile>>>, TError = ErrorResponse>(
 fileName: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혟햟햧햩
 */

export function useGetFileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFile>>>, TError = ErrorResponse>(
 fileName: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileInfiniteQueryOptions(fileName,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFileQueryOptions = <TData = Awaited<ReturnType<typeof getFile>>, TError = ErrorResponse>(fileName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileQueryKey(fileName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFile>>> = ({ signal }) => getFile(fileName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(fileName),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileQueryResult = NonNullable<Awaited<ReturnType<typeof getFile>>>
export type GetFileQueryError = ErrorResponse


export function useGetFile<TData = Awaited<ReturnType<typeof getFile>>, TError = ErrorResponse>(
 fileName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFile>>,
          TError,
          Awaited<ReturnType<typeof getFile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFile<TData = Awaited<ReturnType<typeof getFile>>, TError = ErrorResponse>(
 fileName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFile>>,
          TError,
          Awaited<ReturnType<typeof getFile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFile<TData = Awaited<ReturnType<typeof getFile>>, TError = ErrorResponse>(
 fileName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혟햟햧햩
 */

export function useGetFile<TData = Awaited<ReturnType<typeof getFile>>, TError = ErrorResponse>(
 fileName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileQueryOptions(fileName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혝햦 햢햣혟햣햨혝혞 향햟 쒫쥃썛햟햫햦햪 햨쮏얧쮏
 * @summary 뤰햦햪햟혝햦 혝햦 햢햣혟햣햨혝혞 향햟 햨쮏얧쮏
 */
export const getDefectTypeByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetDefectTypeByCode200>(
      {url: `/defect-types/by-code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectTypeByCodeQueryKey = (code: string,) => {
    return [`/defect-types/by-code/${code}`] as const;
    }

    
export const getGetDefectTypeByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeByCode>>> = ({ signal }) => getDefectTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeByCode>>>
export type GetDefectTypeByCodeInfiniteQueryError = ErrorResponse


export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦 햢햣혟햣햨혝혞 향햟 햨쮏얧쮏
 */

export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectTypeByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeByCode>>> = ({ signal }) => getDefectTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeByCode>>>
export type GetDefectTypeByCodeQueryError = ErrorResponse


export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혝햦 햢햣혟햣햨혝혞 향햟 햨쮏얧쮏
 */

export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮐걤햨 햨햩혰혮햫혝혰 향햟 햨햩혩혢쮏쒫쟳 혜햩쮏쒫쮏
 * @deprecated
 * @summary 쮐걤햨 햨햩혰혮햫혝혰
 */
export const searchClients1 = (
    params: SearchClients1Params,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/clients/search`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSearchClients1QueryKey = (params: SearchClients1Params,) => {
    return [`/clients/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchClients1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof searchClients1>>>, TError = ErrorResponse>(params: SearchClients1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchClients1QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchClients1>>> = ({ signal }) => searchClients1(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchClients1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchClients1>>>
export type SearchClients1InfiniteQueryError = ErrorResponse


export function useSearchClients1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof searchClients1>>>, TError = ErrorResponse>(
 params: SearchClients1Params, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchClients1>>,
          TError,
          Awaited<ReturnType<typeof searchClients1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchClients1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof searchClients1>>>, TError = ErrorResponse>(
 params: SearchClients1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchClients1>>,
          TError,
          Awaited<ReturnType<typeof searchClients1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchClients1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof searchClients1>>>, TError = ErrorResponse>(
 params: SearchClients1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @deprecated
 * @summary 쮐걤햨 햨햩혰혮햫혝혰
 */

export function useSearchClients1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof searchClients1>>>, TError = ErrorResponse>(
 params: SearchClients1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchClients1InfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSearchClients1QueryOptions = <TData = Awaited<ReturnType<typeof searchClients1>>, TError = ErrorResponse>(params: SearchClients1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchClients1QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchClients1>>> = ({ signal }) => searchClients1(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchClients1QueryResult = NonNullable<Awaited<ReturnType<typeof searchClients1>>>
export type SearchClients1QueryError = ErrorResponse


export function useSearchClients1<TData = Awaited<ReturnType<typeof searchClients1>>, TError = ErrorResponse>(
 params: SearchClients1Params, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchClients1>>,
          TError,
          Awaited<ReturnType<typeof searchClients1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchClients1<TData = Awaited<ReturnType<typeof searchClients1>>, TError = ErrorResponse>(
 params: SearchClients1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchClients1>>,
          TError,
          Awaited<ReturnType<typeof searchClients1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchClients1<TData = Awaited<ReturnType<typeof searchClients1>>, TError = ErrorResponse>(
 params: SearchClients1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @deprecated
 * @summary 쮐걤햨 햨햩혰혮햫혝혰
 */

export function useSearchClients1<TData = Awaited<ReturnType<typeof searchClients1>>, TError = ErrorResponse>(
 params: SearchClients1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchClients1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchClients1QueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 쮏쒫왐혝햟혮 혞햫햨혝 햦햧쮏쩀 향햟 쒫쥃썛햟햫햦햪 햨쮏얧쮏
 * @summary 뤰햦햪햟혝햦 혞햫햨혝 햦햧쮏쩀 향햟 햨쮏얧쮏
 */
export const getBranchLocationByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations/code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetBranchLocationByCodeQueryKey = (code: string,) => {
    return [`/branch-locations/code/${code}`] as const;
    }

    
export const getGetBranchLocationByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchLocationByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranchLocationByCode>>> = ({ signal }) => getBranchLocationByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBranchLocationByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getBranchLocationByCode>>>
export type GetBranchLocationByCodeInfiniteQueryError = ErrorResponse


export function useGetBranchLocationByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationByCode>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationByCode>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혞햫햨혝 햦햧쮏쩀 향햟 햨쮏얧쮏
 */

export function useGetBranchLocationByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBranchLocationByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBranchLocationByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getBranchLocationByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchLocationByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranchLocationByCode>>> = ({ signal }) => getBranchLocationByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBranchLocationByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getBranchLocationByCode>>>
export type GetBranchLocationByCodeQueryError = ErrorResponse


export function useGetBranchLocationByCode<TData = Awaited<ReturnType<typeof getBranchLocationByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationByCode>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByCode<TData = Awaited<ReturnType<typeof getBranchLocationByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationByCode>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByCode<TData = Awaited<ReturnType<typeof getBranchLocationByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 뤰햦햪햟혝햦 혞햫햨혝 햦햧쮏쩀 향햟 햨쮏얧쮏
 */

export function useGetBranchLocationByCode<TData = Awaited<ReturnType<typeof getBranchLocationByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBranchLocationByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 햑햣혜혝쮏쒫쟳 햣햫햢쮐뒗쫨 햢햩혪 햣햣쒬뒘햨햦 햢쮐혝혞햫쮐혝혰 API 햟혞혝햣햫혝햦혟혰햨햟혡혰혱
 * @summary 햣햣쒬뒘햨햟 햢쮐혝혞햫쮐혝혰
 */
export const testAuthEndpoint = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/auth/test`, method: 'GET', signal
    },
      options);
    }
  

export const getTestAuthEndpointQueryKey = () => {
    return [`/auth/test`] as const;
    }

    
export const getTestAuthEndpointInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof testAuthEndpoint>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTestAuthEndpointQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof testAuthEndpoint>>> = ({ signal }) => testAuthEndpoint(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TestAuthEndpointInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof testAuthEndpoint>>>
export type TestAuthEndpointInfiniteQueryError = ErrorResponse


export function useTestAuthEndpointInfinite<TData = InfiniteData<Awaited<ReturnType<typeof testAuthEndpoint>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof testAuthEndpoint>>,
          TError,
          Awaited<ReturnType<typeof testAuthEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestAuthEndpointInfinite<TData = InfiniteData<Awaited<ReturnType<typeof testAuthEndpoint>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof testAuthEndpoint>>,
          TError,
          Awaited<ReturnType<typeof testAuthEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestAuthEndpointInfinite<TData = InfiniteData<Awaited<ReturnType<typeof testAuthEndpoint>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햨햟 햢쮐혝혞햫쮐혝혰
 */

export function useTestAuthEndpointInfinite<TData = InfiniteData<Awaited<ReturnType<typeof testAuthEndpoint>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTestAuthEndpointInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getTestAuthEndpointQueryOptions = <TData = Awaited<ReturnType<typeof testAuthEndpoint>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTestAuthEndpointQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof testAuthEndpoint>>> = ({ signal }) => testAuthEndpoint(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TestAuthEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof testAuthEndpoint>>>
export type TestAuthEndpointQueryError = ErrorResponse


export function useTestAuthEndpoint<TData = Awaited<ReturnType<typeof testAuthEndpoint>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof testAuthEndpoint>>,
          TError,
          Awaited<ReturnType<typeof testAuthEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestAuthEndpoint<TData = Awaited<ReturnType<typeof testAuthEndpoint>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof testAuthEndpoint>>,
          TError,
          Awaited<ReturnType<typeof testAuthEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestAuthEndpoint<TData = Awaited<ReturnType<typeof testAuthEndpoint>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 햣햣쒬뒘햨햟 햢쮐혝혞햫쮐혝혰
 */

export function useTestAuthEndpoint<TData = Awaited<ReturnType<typeof testAuthEndpoint>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTestAuthEndpointQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const healthCheck = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<HealthCheck200>(
      {url: `/api/health`, method: 'GET', signal
    },
      options);
    }
  

export const getHealthCheckQueryKey = () => {
    return [`/api/health`] as const;
    }

    
export const getHealthCheckInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckInfiniteQueryError = ErrorResponse


export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthCheck>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckQueryError = ErrorResponse


export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ping = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/api/health/ping`, method: 'GET', signal
    },
      options);
    }
  

export const getPingQueryKey = () => {
    return [`/api/health/ping`] as const;
    }

    
export const getPingInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof ping>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPingQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ping>>> = ({ signal }) => ping(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PingInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof ping>>>
export type PingInfiniteQueryError = ErrorResponse


export function usePingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof ping>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ping>>,
          TError,
          Awaited<ReturnType<typeof ping>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof ping>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ping>>,
          TError,
          Awaited<ReturnType<typeof ping>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof ping>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof ping>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPingInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getPingQueryOptions = <TData = Awaited<ReturnType<typeof ping>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPingQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ping>>> = ({ signal }) => ping(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PingQueryResult = NonNullable<Awaited<ReturnType<typeof ping>>>
export type PingQueryError = ErrorResponse


export function usePing<TData = Awaited<ReturnType<typeof ping>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ping>>,
          TError,
          Awaited<ReturnType<typeof ping>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePing<TData = Awaited<ReturnType<typeof ping>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ping>>,
          TError,
          Awaited<ReturnType<typeof ping>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePing<TData = Awaited<ReturnType<typeof ping>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePing<TData = Awaited<ReturnType<typeof ping>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPingQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 행햟햨햦혝혝혪 혜햣혜혰혱 혟쮐쮏얧쮏쥄햪햣햫혝햟혡혰혱
 */
export const closeSession2 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getCloseSession2MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof closeSession2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof closeSession2>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['closeSession2'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof closeSession2>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  closeSession2(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CloseSession2MutationResult = NonNullable<Awaited<ReturnType<typeof closeSession2>>>
    
    export type CloseSession2MutationError = ErrorResponse

    /**
 * @summary 행햟햨햦혝혝혪 혜햣혜혰혱 혟쮐쮏얧쮏쥄햪햣햫혝햟혡혰혱
 */
export const useCloseSession2 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof closeSession2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof closeSession2>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCloseSession2MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳얧썛햣햫햫혪 혟쮐쮏햟혟혰혱
 */
export const removePhoto = (
    sessionId: string,
    photoId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}/photos/${photoId}`, method: 'DELETE'
    },
      options);
    }
  


export const getRemovePhotoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removePhoto>>, TError,{sessionId: string;photoId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof removePhoto>>, TError,{sessionId: string;photoId: string}, TContext> => {

const mutationKey = ['removePhoto'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removePhoto>>, {sessionId: string;photoId: string}> = (props) => {
          const {sessionId,photoId} = props ?? {};

          return  removePhoto(sessionId,photoId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemovePhotoMutationResult = NonNullable<Awaited<ReturnType<typeof removePhoto>>>
    
    export type RemovePhotoMutationError = ErrorResponse

    /**
 * @summary 뉋쟳얧썛햣햫햫혪 혟쮐쮏햟혟혰혱
 */
export const useRemovePhoto = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removePhoto>>, TError,{sessionId: string;photoId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removePhoto>>,
        TError,
        {sessionId: string;photoId: string},
        TContext
      > => {

      const mutationOptions = getRemovePhotoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳얧썛햣햫햫혪 혜햣혜혰혱
 */
export const removeSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/substep4/session/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getRemoveSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['removeSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  removeSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSessionMutationResult = NonNullable<Awaited<ReturnType<typeof removeSession>>>
    
    export type RemoveSessionMutationError = ErrorResponse

    /**
 * @summary 뉋쟳얧썛햣햫햫혪 혜햣혜혰혱
 */
export const useRemoveSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 뉋쟳얧썛햣햫햫혪 햪쮏얧쟴혰햨햟혝쮐햟 향 쮏햟혠혞햫햨혞
 */
export const removeModifier = (
    sessionId: string,
    modifierId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers/${sessionId}/${modifierId}`, method: 'DELETE'
    },
      options);
    }
  


export const getRemoveModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeModifier>>, TError,{sessionId: string;modifierId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof removeModifier>>, TError,{sessionId: string;modifierId: string}, TContext> => {

const mutationKey = ['removeModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeModifier>>, {sessionId: string;modifierId: string}> = (props) => {
          const {sessionId,modifierId} = props ?? {};

          return  removeModifier(sessionId,modifierId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveModifierMutationResult = NonNullable<Awaited<ReturnType<typeof removeModifier>>>
    
    export type RemoveModifierMutationError = ErrorResponse

    /**
 * @summary 뉋쟳얧썛햣햫햫혪 햪쮏얧쟴혰햨햟혝쮐햟 향 쮏햟혠혞햫햨혞
 */
export const useRemoveModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeModifier>>, TError,{sessionId: string;modifierId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeModifier>>,
        TError,
        {sessionId: string;modifierId: string},
        TContext
      > => {

      const mutationOptions = getRemoveModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟쒫왐혣혞혮 혜햣혜혰혩 혰햢햣혝햟혞 1
 */
export const finalizeSubstep1Session = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getFinalizeSubstep1SessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalizeSubstep1Session>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof finalizeSubstep1Session>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['finalizeSubstep1Session'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalizeSubstep1Session>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  finalizeSubstep1Session(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalizeSubstep1SessionMutationResult = NonNullable<Awaited<ReturnType<typeof finalizeSubstep1Session>>>
    
    export type FinalizeSubstep1SessionMutationError = ErrorResponse

    /**
 * @summary 행햟쒫왐혣혞혮 혜햣혜혰혩 혰햢햣혝햟혞 1
 */
export const useFinalizeSubstep1Session = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalizeSubstep1Session>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof finalizeSubstep1Session>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getFinalizeSubstep1SessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 행햟쒫왐혣혞혮 혜햣혜혰혩 혝햟 향쒬뒗혧햫혪혮 햣혜혞혜햦
 */
export const terminateSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/session/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getTerminateSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminateSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof terminateSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['terminateSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof terminateSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  terminateSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TerminateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof terminateSession>>>
    
    export type TerminateSessionMutationError = ErrorResponse

    /**
 * @summary 행햟쒫왐혣혞혮 혜햣혜혰혩 혝햟 향쒬뒗혧햫혪혮 햣혜혞혜햦
 */
export const useTerminateSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminateSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof terminateSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getTerminateSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐햨햟혜쮏쒬혮 혜혝쒫쮐햣햫햫혪 햨햩혰혮햫혝햟
 */
export const cancelNewClientCreation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getCancelNewClientCreationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelNewClientCreation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelNewClientCreation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['cancelNewClientCreation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelNewClientCreation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  cancelNewClientCreation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelNewClientCreationMutationResult = NonNullable<Awaited<ReturnType<typeof cancelNewClientCreation>>>
    
    export type CancelNewClientCreationMutationError = ErrorResponse

    /**
 * @summary 햐햨햟혜쮏쒬혮 혜혝쒫쮐햣햫햫혪 햨햩혰혮햫혝햟
 */
export const useCancelNewClientCreation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelNewClientCreation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelNewClientCreation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCancelNewClientCreationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐햨햟혜쮏쒬혮 쮐걤햨 햨햩혰혮햫혝햟
 */
export const cancelClientSearch = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getCancelClientSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelClientSearch>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['cancelClientSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelClientSearch>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  cancelClientSearch(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelClientSearchMutationResult = NonNullable<Awaited<ReturnType<typeof cancelClientSearch>>>
    
    export type CancelClientSearchMutationError = ErrorResponse

    /**
 * @summary 햐햨햟혜쮏쒬혮 쮐걤햨 햨햩혰혮햫혝햟
 */
export const useCancelClientSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelClientSearch>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCancelClientSearchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary 햐햨햟혜쮏쒬혮 향햠혰 햠햟향쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */
export const cancelBasicOrderInfo = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getCancelBasicOrderInfoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelBasicOrderInfo>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelBasicOrderInfo>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['cancelBasicOrderInfo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelBasicOrderInfo>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  cancelBasicOrderInfo(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelBasicOrderInfoMutationResult = NonNullable<Awaited<ReturnType<typeof cancelBasicOrderInfo>>>
    
    export type CancelBasicOrderInfoMutationError = ErrorResponse

    /**
 * @summary 햐햨햟혜쮏쒬혮 향햠혰 햠햟향쮏쒫쮐 혰햫혟쮐햪햟혡혰혱
 */
export const useCancelBasicOrderInfo = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelBasicOrderInfo>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelBasicOrderInfo>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getCancelBasicOrderInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 햐햨햟혜쮏쒬혮 향햟햪쮏쒫햣햫햫혪
 * @summary 햐햨햟혜혞쒫썜햦 향햟햪쮏쒫햣햫햫혪
 */
export const cancelOrder = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<CancelOrder204>(
      {url: `/orders/${id}/cancel`, method: 'DELETE'
    },
      options);
    }
  


export const getCancelOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelOrder>>, TError,{id: string}, TContext> => {

const mutationKey = ['cancelOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelOrder>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  cancelOrder(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelOrderMutationResult = NonNullable<Awaited<ReturnType<typeof cancelOrder>>>
    
    export type CancelOrderMutationError = ErrorResponse

    /**
 * @summary 햐햨햟혜혞쒫썜햦 향햟햪쮏쒫햣햫햫혪
 */
export const useCancelOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelOrder>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getCancelOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
