/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * AKSI API
 * API –¥–ª—è —Å–∏—Å—Ç–µ–º–∏ –∫–µ—Ä—É–≤–∞–Ω–Ω—è –∫–ª—ñ–Ω—ñ–Ω–≥–æ–≤–æ—é –∫–æ–º–ø–∞–Ω—ñ—î—é AKSI
 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AdditionalRequirementsRequest,
  ApplyDiscount1200,
  ApplyPayment200,
  BranchLocationCreateRequest,
  BranchLocationDTO,
  BranchLocationUpdateRequest,
  CalculateCompletionDate200,
  CalculatePayment200,
  CancelOrder204,
  CancelWizard200,
  ClientPageResponse,
  ClientResponse,
  ClientSearchRequest,
  CompleteWizard200,
  CompletionDateCalculationRequest,
  CreateCategory200,
  CreateClientRequest,
  CreateModifier200,
  CreateOrderRequest,
  CreatePriceListItem200,
  CreateStainType200,
  CustomerSignatureRequest,
  CustomerSignatureResponse,
  DeactivateModifier200,
  DefectTypeDTO,
  DeleteBranchLocation204,
  DeleteClient204,
  DeleteOrderItem204,
  DeletePhoto204,
  DeleteStainType200,
  DownloadPdfReceipt200,
  EmailReceipt200,
  EmailReceiptRequest,
  EmailReceiptResponse,
  ErrorResponse,
  ExecuteAction200,
  ExecuteActionBody,
  GetActiveWizards200,
  GetAllActiveCategories200,
  GetAllAvailableActions200,
  GetAllBranchLocationsParams,
  GetAllCategories200,
  GetAllClientsParams,
  GetAllModifiers200,
  GetAvailableActions200,
  GetAvailableModifiersForCategory200,
  GetAvailableModifiersForCategoryParams,
  GetAvailableUnitsOfMeasure200,
  GetBasePrice200,
  GetBasePriceParams,
  GetCategoryByCode1200,
  GetCategoryByCode200,
  GetCategoryById1200,
  GetCategoryById200,
  GetDefectTypeByCode200,
  GetDefectTypeById200,
  GetDefectTypesParams,
  GetItemById200,
  GetItemNamesByCategory200,
  GetItemsByCategory200,
  GetItemsByCategoryCode200,
  GetMaterialsParams,
  GetModifierByCode1200,
  GetModifierByCode200,
  GetModifierById200,
  GetModifiersByCategory1200,
  GetModifiersByCategory200,
  GetModifiersByCategoryParams,
  GetModifiersByCodes200,
  GetModifiersForServiceCategory1200,
  GetModifiersForServiceCategory200,
  GetOrderDiscount200,
  GetOrderPayment200,
  GetOrderReceipt200,
  GetOrderReceiptParams,
  GetRecommendedModifiers200,
  GetRecommendedModifiersForDefectsParams,
  GetRecommendedModifiersForStainsParams,
  GetRecommendedModifiersParams,
  GetRecommendedUnitOfMeasureParams,
  GetRequirements200,
  GetRiskWarnings200,
  GetRiskWarningsForItemParams,
  GetRiskWarningsParams,
  GetStage1Data200,
  GetStainTypeByCode200,
  GetStainTypeById200,
  GetStainTypesParams,
  HealthCheck200,
  IsUnitSupportedForItemParams,
  Login200,
  LoginRequest,
  ModifierRecommendationDTO,
  OrderBasicInfoRequest,
  OrderCompletionUpdateRequest,
  OrderDTO,
  OrderDetailedSummaryResponse,
  OrderDiscountRequest,
  OrderFinalizationRequest,
  OrderItemDTO,
  OrderItemPhotoDTO,
  OrderWizardDataResponse,
  OrderWizardSessionResponse,
  PaymentCalculationRequest,
  PdfReceiptResponse,
  PriceCalculationRequestDTO,
  PriceCalculationResponseDTO,
  PriceListItemDTO,
  PriceModifierDTO,
  ReceiptDTO,
  ReceiptGenerationRequest,
  RefreshToken200,
  Register200,
  RegisterRequest,
  RemoveDiscount200,
  SearchClientsParams,
  ServiceCategoryDTO,
  SetActiveStatusParams,
  StainTypeDTO,
  SubmitClientData200,
  SubmitOrderBasicInfo200,
  TestResponse,
  UpdateCategory200,
  UpdateClientRequest,
  UpdateModifier200,
  UpdateOrderCompletion200,
  UpdatePhotoAnnotationsParams,
  UpdatePriceListItem200,
  UpdateRequirements200,
  UpdateStainType200,
  UploadPhotoBody,
  UploadPhotoParams
} from './aksiApi.schemas';

import orvalFetcher from '../../../../lib/api/orval-fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ ID
 */
export const getStainTypeById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetStainTypeById200>(
      {url: `/stain-types/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStainTypeByIdQueryKey = (id: string,) => {
    return [`/stain-types/${id}`] as const;
    }

    
export const getGetStainTypeByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeById>>> = ({ signal }) => getStainTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeById>>>
export type GetStainTypeByIdInfiniteQueryError = ErrorResponse


export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ ID
 */

export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeById>>> = ({ signal }) => getStainTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeById>>>
export type GetStainTypeByIdQueryError = ErrorResponse


export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ ID
 */

export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–Ω–æ–≤–ª—é—î —ñ—Å–Ω—É—é—á–∏–π —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const updateStainType = (
    id: string,
    stainTypeDTO: StainTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdateStainType200>(
      {url: `/stain-types/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: stainTypeDTO
    },
      options);
    }
  


export const getUpdateStainTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStainType>>, TError,{id: string;data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateStainType>>, TError,{id: string;data: StainTypeDTO}, TContext> => {

const mutationKey = ['updateStainType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateStainType>>, {id: string;data: StainTypeDTO}> = (props) => {
          const {id,data} = props ?? {};

          return  updateStainType(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateStainTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateStainType>>>
    export type UpdateStainTypeMutationBody = StainTypeDTO
    export type UpdateStainTypeMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const useUpdateStainType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStainType>>, TError,{id: string;data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateStainType>>,
        TError,
        {id: string;data: StainTypeDTO},
        TContext
      > => {

      const mutationOptions = getUpdateStainTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –í–∏–¥–∞–ª—è—î —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const deleteStainType = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeleteStainType200>(
      {url: `/stain-types/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteStainTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStainType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteStainType>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteStainType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteStainType>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteStainType(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteStainTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStainType>>>
    
    export type DeleteStainTypeMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const useDeleteStainType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStainType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteStainType>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteStainTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ ID
 */
export const getModifierById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifierById200>(
      {url: `/price-modifiers/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifierByIdQueryKey = (id: string,) => {
    return [`/price-modifiers/${id}`] as const;
    }

    
export const getGetModifierByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierById>>> = ({ signal }) => getModifierById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierById>>>
export type GetModifierByIdInfiniteQueryError = ErrorResponse


export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ ID
 */

export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifierByIdQueryOptions = <TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierById>>> = ({ signal }) => getModifierById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierById>>>
export type GetModifierByIdQueryError = ErrorResponse


export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ ID
 */

export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —ñ—Å–Ω—É—é—á–∏–π –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const updateModifier = (
    id: string,
    priceModifierDTO: PriceModifierDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdateModifier200>(
      {url: `/price-modifiers/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: priceModifierDTO
    },
      options);
    }
  


export const getUpdateModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModifier>>, TError,{id: string;data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateModifier>>, TError,{id: string;data: PriceModifierDTO}, TContext> => {

const mutationKey = ['updateModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateModifier>>, {id: string;data: PriceModifierDTO}> = (props) => {
          const {id,data} = props ?? {};

          return  updateModifier(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateModifierMutationResult = NonNullable<Awaited<ReturnType<typeof updateModifier>>>
    export type UpdateModifierMutationBody = PriceModifierDTO
    export type UpdateModifierMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —ñ—Å–Ω—É—é—á–∏–π –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const useUpdateModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModifier>>, TError,{id: string;data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateModifier>>,
        TError,
        {id: string;data: PriceModifierDTO},
        TContext
      > => {

      const mutationOptions = getUpdateModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –î–µ–∞–∫—Ç–∏–≤—É–≤–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const deactivateModifier = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeactivateModifier200>(
      {url: `/price-modifiers/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeactivateModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateModifier>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deactivateModifier>>, TError,{id: string}, TContext> => {

const mutationKey = ['deactivateModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deactivateModifier>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deactivateModifier(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeactivateModifierMutationResult = NonNullable<Awaited<ReturnType<typeof deactivateModifier>>>
    
    export type DeactivateModifierMutationError = ErrorResponse

    /**
 * @summary –î–µ–∞–∫—Ç–∏–≤—É–≤–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const useDeactivateModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateModifier>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deactivateModifier>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeactivateModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ ID
 */
export const getItemById = (
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemById200>(
      {url: `/price-list/item/${itemId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemByIdQueryKey = (itemId: string,) => {
    return [`/price-list/item/${itemId}`] as const;
    }

    
export const getGetItemByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemByIdQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemById>>> = ({ signal }) => getItemById(itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemById>>>
export type GetItemByIdInfiniteQueryError = ErrorResponse


export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ ID
 */

export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemByIdInfiniteQueryOptions(itemId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemByIdQueryOptions = <TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemByIdQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemById>>> = ({ signal }) => getItemById(itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getItemById>>>
export type GetItemByIdQueryError = ErrorResponse


export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ ID
 */

export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemByIdQueryOptions(itemId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞
 */
export const updatePriceListItem = (
    itemId: string,
    priceListItemDTO: PriceListItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdatePriceListItem200>(
      {url: `/price-list/item/${itemId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: priceListItemDTO
    },
      options);
    }
  


export const getUpdatePriceListItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePriceListItem>>, TError,{itemId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePriceListItem>>, TError,{itemId: string;data: PriceListItemDTO}, TContext> => {

const mutationKey = ['updatePriceListItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePriceListItem>>, {itemId: string;data: PriceListItemDTO}> = (props) => {
          const {itemId,data} = props ?? {};

          return  updatePriceListItem(itemId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePriceListItemMutationResult = NonNullable<Awaited<ReturnType<typeof updatePriceListItem>>>
    export type UpdatePriceListItemMutationBody = PriceListItemDTO
    export type UpdatePriceListItemMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞
 */
export const useUpdatePriceListItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePriceListItem>>, TError,{itemId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePriceListItem>>,
        TError,
        {itemId: string;data: PriceListItemDTO},
        TContext
      > => {

      const mutationOptions = getUpdatePriceListItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥
 */
export const updateCategory = (
    categoryId: string,
    serviceCategoryDTO: ServiceCategoryDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdateCategory200>(
      {url: `/price-list/category/${categoryId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: serviceCategoryDTO
    },
      options);
    }
  


export const getUpdateCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: ServiceCategoryDTO}, TContext> => {

const mutationKey = ['updateCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCategory>>, {categoryId: string;data: ServiceCategoryDTO}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  updateCategory(categoryId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategory>>>
    export type UpdateCategoryMutationBody = ServiceCategoryDTO
    export type UpdateCategoryMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥
 */
export const useUpdateCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCategory>>,
        TError,
        {categoryId: string;data: ServiceCategoryDTO},
        TContext
      > => {

      const mutationOptions = getUpdateCategoryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –ø—Ä–µ–¥–º–µ—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –∑–∞ –π–æ–≥–æ ID
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π –ø—Ä–µ–¥–º–µ—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const getOrderItem = (
    orderId: string,
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderItemDTO>(
      {url: `/orders/${orderId}/items/${itemId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderItemQueryKey = (orderId: string,
    itemId: string,) => {
    return [`/orders/${orderId}/items/${itemId}`] as const;
    }

    
export const getGetOrderItemInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderItem>>>, TError = ErrorResponse>(orderId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderItemQueryKey(orderId,itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderItem>>> = ({ signal }) => getOrderItem(orderId,itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId && itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderItemInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderItem>>>
export type GetOrderItemInfiniteQueryError = ErrorResponse


export function useGetOrderItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItem>>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItem>>,
          TError,
          Awaited<ReturnType<typeof getOrderItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItem>>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItem>>,
          TError,
          Awaited<ReturnType<typeof getOrderItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItem>>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π –ø—Ä–µ–¥–º–µ—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetOrderItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItem>>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderItemInfiniteQueryOptions(orderId,itemId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderItemQueryOptions = <TData = Awaited<ReturnType<typeof getOrderItem>>, TError = ErrorResponse>(orderId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderItemQueryKey(orderId,itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderItem>>> = ({ signal }) => getOrderItem(orderId,itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId && itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderItemQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderItem>>>
export type GetOrderItemQueryError = ErrorResponse


export function useGetOrderItem<TData = Awaited<ReturnType<typeof getOrderItem>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItem>>,
          TError,
          Awaited<ReturnType<typeof getOrderItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItem<TData = Awaited<ReturnType<typeof getOrderItem>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItem>>,
          TError,
          Awaited<ReturnType<typeof getOrderItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItem<TData = Awaited<ReturnType<typeof getOrderItem>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π –ø—Ä–µ–¥–º–µ—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetOrderItem<TData = Awaited<ReturnType<typeof getOrderItem>>, TError = ErrorResponse>(
 orderId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderItemQueryOptions(orderId,itemId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–Ω–æ–≤–ª—é—î —ñ—Å–Ω—É—é—á–∏–π –ø—Ä–µ–¥–º–µ—Ç —É –∑–∞–º–æ–≤–ª–µ–Ω–Ω—ñ
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –ø—Ä–µ–¥–º–µ—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const updateOrderItem = (
    orderId: string,
    itemId: string,
    orderItemDTO: OrderItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderItemDTO>(
      {url: `/orders/${orderId}/items/${itemId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: orderItemDTO
    },
      options);
    }
  


export const getUpdateOrderItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderItem>>, TError,{orderId: string;itemId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateOrderItem>>, TError,{orderId: string;itemId: string;data: OrderItemDTO}, TContext> => {

const mutationKey = ['updateOrderItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOrderItem>>, {orderId: string;itemId: string;data: OrderItemDTO}> = (props) => {
          const {orderId,itemId,data} = props ?? {};

          return  updateOrderItem(orderId,itemId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateOrderItemMutationResult = NonNullable<Awaited<ReturnType<typeof updateOrderItem>>>
    export type UpdateOrderItemMutationBody = OrderItemDTO
    export type UpdateOrderItemMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –ø—Ä–µ–¥–º–µ—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useUpdateOrderItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderItem>>, TError,{orderId: string;itemId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateOrderItem>>,
        TError,
        {orderId: string;itemId: string;data: OrderItemDTO},
        TContext
      > => {

      const mutationOptions = getUpdateOrderItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –í–∏–¥–∞–ª—è—î –ø—Ä–µ–¥–º–µ—Ç —ñ–∑ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ –ø—Ä–µ–¥–º–µ—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const deleteOrderItem = (
    orderId: string,
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeleteOrderItem204>(
      {url: `/orders/${orderId}/items/${itemId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteOrderItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOrderItem>>, TError,{orderId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteOrderItem>>, TError,{orderId: string;itemId: string}, TContext> => {

const mutationKey = ['deleteOrderItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteOrderItem>>, {orderId: string;itemId: string}> = (props) => {
          const {orderId,itemId} = props ?? {};

          return  deleteOrderItem(orderId,itemId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteOrderItemMutationResult = NonNullable<Awaited<ReturnType<typeof deleteOrderItem>>>
    
    export type DeleteOrderItemMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ –ø—Ä–µ–¥–º–µ—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useDeleteOrderItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOrderItem>>, TError,{orderId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteOrderItem>>,
        TError,
        {orderId: string;itemId: string},
        TContext
      > => {

      const mutationOptions = getDeleteOrderItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –û–Ω–æ–≤–ª—é—î —Å—Ç–∞—Ç—É—Å –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —Å—Ç–∞—Ç—É—Å –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const updateOrderStatus = (
    id: string,
    status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED',
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}/status/${status}`, method: 'PUT'
    },
      options);
    }
  


export const getUpdateOrderStatusMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderStatus>>, TError,{id: string;status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED'}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateOrderStatus>>, TError,{id: string;status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED'}, TContext> => {

const mutationKey = ['updateOrderStatus'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOrderStatus>>, {id: string;status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED'}> = (props) => {
          const {id,status} = props ?? {};

          return  updateOrderStatus(id,status,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateOrderStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateOrderStatus>>>
    
    export type UpdateOrderStatusMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —Å—Ç–∞—Ç—É—Å –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useUpdateOrderStatus = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderStatus>>, TError,{id: string;status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED'}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateOrderStatus>>,
        TError,
        {id: string;status: 'DRAFT' | 'NEW' | 'IN_PROGRESS' | 'COMPLETED' | 'DELIVERED' | 'CANCELLED'},
        TContext
      > => {

      const mutationOptions = getUpdateOrderStatusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –î–æ–¥–∞—î –ø–µ—Ä–µ–¥–æ–ø–ª–∞—Ç—É –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –î–æ–¥–∞—Ç–∏ –ø–µ—Ä–µ–¥–æ–ø–ª–∞—Ç—É
 */
export const addPrepayment = (
    id: string,
    amount: number,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}/prepayment/${amount}`, method: 'PUT'
    },
      options);
    }
  


export const getAddPrepaymentMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPrepayment>>, TError,{id: string;amount: number}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof addPrepayment>>, TError,{id: string;amount: number}, TContext> => {

const mutationKey = ['addPrepayment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPrepayment>>, {id: string;amount: number}> = (props) => {
          const {id,amount} = props ?? {};

          return  addPrepayment(id,amount,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddPrepaymentMutationResult = NonNullable<Awaited<ReturnType<typeof addPrepayment>>>
    
    export type AddPrepaymentMutationError = ErrorResponse

    /**
 * @summary –î–æ–¥–∞—Ç–∏ –ø–µ—Ä–µ–¥–æ–ø–ª–∞—Ç—É
 */
export const useAddPrepayment = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPrepayment>>, TError,{id: string;amount: number}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addPrepayment>>,
        TError,
        {id: string;amount: number},
        TContext
      > => {

      const mutationOptions = getAddPrepaymentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ó–∞—Å—Ç–æ—Å–æ–≤—É—î –∑–Ω–∏–∂–∫—É –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –∑–Ω–∏–∂–∫—É
 */
export const applyDiscount = (
    id: string,
    amount: number,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}/discount/${amount}`, method: 'PUT'
    },
      options);
    }
  


export const getApplyDiscountMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyDiscount>>, TError,{id: string;amount: number}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof applyDiscount>>, TError,{id: string;amount: number}, TContext> => {

const mutationKey = ['applyDiscount'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof applyDiscount>>, {id: string;amount: number}> = (props) => {
          const {id,amount} = props ?? {};

          return  applyDiscount(id,amount,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApplyDiscountMutationResult = NonNullable<Awaited<ReturnType<typeof applyDiscount>>>
    
    export type ApplyDiscountMutationError = ErrorResponse

    /**
 * @summary –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –∑–Ω–∏–∂–∫—É
 */
export const useApplyDiscount = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyDiscount>>, TError,{id: string;amount: number}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof applyDiscount>>,
        TError,
        {id: string;amount: number},
        TContext
      > => {

      const mutationOptions = getApplyDiscountMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–µ—Ä–µ—Ç–≤–æ—Ä—é—î —á–µ—Ä–Ω–µ—Ç–∫—É –Ω–∞ –∞–∫—Ç–∏–≤–Ω–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –ü–µ—Ä–µ—Ç–≤–æ—Ä–∏—Ç–∏ —á–µ—Ä–Ω–µ—Ç–∫—É –Ω–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const convertDraftToOrder = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}/convert-draft`, method: 'PUT'
    },
      options);
    }
  


export const getConvertDraftToOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof convertDraftToOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof convertDraftToOrder>>, TError,{id: string}, TContext> => {

const mutationKey = ['convertDraftToOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof convertDraftToOrder>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  convertDraftToOrder(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConvertDraftToOrderMutationResult = NonNullable<Awaited<ReturnType<typeof convertDraftToOrder>>>
    
    export type ConvertDraftToOrderMutationError = ErrorResponse

    /**
 * @summary –ü–µ—Ä–µ—Ç–≤–æ—Ä–∏—Ç–∏ —á–µ—Ä–Ω–µ—Ç–∫—É –Ω–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useConvertDraftToOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof convertDraftToOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof convertDraftToOrder>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getConvertDraftToOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –í—ñ–¥–∑–Ω–∞—á–∞—î –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è —è–∫ –≤–∏–∫–æ–Ω–∞–Ω–µ
 * @summary –í—ñ–¥–∑–Ω–∞—á–∏—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è —è–∫ –≤–∏–∫–æ–Ω–∞–Ω–µ
 */
export const completeOrder = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}/complete`, method: 'PUT'
    },
      options);
    }
  


export const getCompleteOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof completeOrder>>, TError,{id: string}, TContext> => {

const mutationKey = ['completeOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeOrder>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  completeOrder(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteOrderMutationResult = NonNullable<Awaited<ReturnType<typeof completeOrder>>>
    
    export type CompleteOrderMutationError = ErrorResponse

    /**
 * @summary –í—ñ–¥–∑–Ω–∞—á–∏—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è —è–∫ –≤–∏–∫–æ–Ω–∞–Ω–µ
 */
export const useCompleteOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeOrder>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getCompleteOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –û–Ω–æ–≤–ª—é—î —Ç–∏–ø —Ç–µ—Ä–º—ñ–Ω–æ–≤–æ—Å—Ç—ñ —Ç–∞ –æ—á—ñ–∫—É–≤–∞–Ω—É –¥–∞—Ç—É –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const updateOrderCompletion = (
    orderCompletionUpdateRequest: OrderCompletionUpdateRequest,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdateOrderCompletion200>(
      {url: `/orders/completion/update`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: orderCompletionUpdateRequest
    },
      options);
    }
  


export const getUpdateOrderCompletionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderCompletion>>, TError,{data: OrderCompletionUpdateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateOrderCompletion>>, TError,{data: OrderCompletionUpdateRequest}, TContext> => {

const mutationKey = ['updateOrderCompletion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOrderCompletion>>, {data: OrderCompletionUpdateRequest}> = (props) => {
          const {data} = props ?? {};

          return  updateOrderCompletion(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateOrderCompletionMutationResult = NonNullable<Awaited<ReturnType<typeof updateOrderCompletion>>>
    export type UpdateOrderCompletionMutationBody = OrderCompletionUpdateRequest
    export type UpdateOrderCompletionMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useUpdateOrderCompletion = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderCompletion>>, TError,{data: OrderCompletionUpdateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateOrderCompletion>>,
        TError,
        {data: OrderCompletionUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateOrderCompletionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –û–Ω–æ–≤–ª—é—î –∞–Ω–æ—Ç–∞—Ü—ñ—ó (–ø–æ–∑–Ω–∞—á–∫–∏) —Ç–∞ –æ–ø–∏—Å –¥–ª—è –≤–∫–∞–∑–∞–Ω–æ—ó —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—ó
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∞–Ω–æ—Ç–∞—Ü—ñ—ó —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—ó
 */
export const updatePhotoAnnotations = (
    itemId: string,
    photoId: string,
    params: UpdatePhotoAnnotationsParams,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<OrderItemPhotoDTO>(
      {url: `/order-items/${itemId}/photos/${photoId}/annotations`, method: 'PUT',
        params
    },
      options);
    }
  


export const getUpdatePhotoAnnotationsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePhotoAnnotations>>, TError,{itemId: string;photoId: string;params: UpdatePhotoAnnotationsParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePhotoAnnotations>>, TError,{itemId: string;photoId: string;params: UpdatePhotoAnnotationsParams}, TContext> => {

const mutationKey = ['updatePhotoAnnotations'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePhotoAnnotations>>, {itemId: string;photoId: string;params: UpdatePhotoAnnotationsParams}> = (props) => {
          const {itemId,photoId,params} = props ?? {};

          return  updatePhotoAnnotations(itemId,photoId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePhotoAnnotationsMutationResult = NonNullable<Awaited<ReturnType<typeof updatePhotoAnnotations>>>
    
    export type UpdatePhotoAnnotationsMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∞–Ω–æ—Ç–∞—Ü—ñ—ó —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—ó
 */
export const useUpdatePhotoAnnotations = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePhotoAnnotations>>, TError,{itemId: string;photoId: string;params: UpdatePhotoAnnotationsParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePhotoAnnotations>>,
        TError,
        {itemId: string;photoId: string;params: UpdatePhotoAnnotationsParams},
        TContext
      > => {

      const mutationOptions = getUpdatePhotoAnnotationsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ ID
 */
export const getDefectTypeById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetDefectTypeById200>(
      {url: `/defect-types/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectTypeByIdQueryKey = (id: string,) => {
    return [`/defect-types/${id}`] as const;
    }

    
export const getGetDefectTypeByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeById>>> = ({ signal }) => getDefectTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeById>>>
export type GetDefectTypeByIdInfiniteQueryError = ErrorResponse


export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ ID
 */

export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectTypeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeById>>> = ({ signal }) => getDefectTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeById>>>
export type GetDefectTypeByIdQueryError = ErrorResponse


export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ ID
 */

export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–Ω–æ–≤–ª—é—î —ñ—Å–Ω—É—é—á–∏–π —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const updateDefectType = (
    id: string,
    defectTypeDTO: DefectTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DefectTypeDTO>(
      {url: `/defect-types/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: defectTypeDTO
    },
      options);
    }
  


export const getUpdateDefectTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDefectType>>, TError,{id: string;data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateDefectType>>, TError,{id: string;data: DefectTypeDTO}, TContext> => {

const mutationKey = ['updateDefectType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDefectType>>, {id: string;data: DefectTypeDTO}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDefectType(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDefectTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateDefectType>>>
    export type UpdateDefectTypeMutationBody = DefectTypeDTO
    export type UpdateDefectTypeMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const useUpdateDefectType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDefectType>>, TError,{id: string;data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDefectType>>,
        TError,
        {id: string;data: DefectTypeDTO},
        TContext
      > => {

      const mutationOptions = getUpdateDefectTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –í–∏–¥–∞–ª—è—î —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const deleteDefectType = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/defect-types/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteDefectTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDefectType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDefectType>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteDefectType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDefectType>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteDefectType(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDefectTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDefectType>>>
    
    export type DeleteDefectTypeMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const useDeleteDefectType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDefectType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDefectType>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteDefectTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –¥–∞–Ω—ñ –∫–ª—ñ—î–Ω—Ç–∞ –∑–∞ –π–æ–≥–æ ID
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–ª—ñ—î–Ω—Ç–∞ –∑–∞ ID
 */
export const getClientById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/clients/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetClientByIdQueryKey = (id: string,) => {
    return [`/clients/${id}`] as const;
    }

    
export const getGetClientByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClientById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClientByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClientById>>> = ({ signal }) => getClientById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetClientByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClientById>>>
export type GetClientByIdInfiniteQueryError = ErrorResponse


export function useGetClientByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientById>>,
          TError,
          Awaited<ReturnType<typeof getClientById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientById>>,
          TError,
          Awaited<ReturnType<typeof getClientById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–ª—ñ—î–Ω—Ç–∞ –∑–∞ ID
 */

export function useGetClientByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClientById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetClientByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClientByIdQueryOptions = <TData = Awaited<ReturnType<typeof getClientById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClientByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClientById>>> = ({ signal }) => getClientById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetClientByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getClientById>>>
export type GetClientByIdQueryError = ErrorResponse


export function useGetClientById<TData = Awaited<ReturnType<typeof getClientById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientById>>,
          TError,
          Awaited<ReturnType<typeof getClientById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientById<TData = Awaited<ReturnType<typeof getClientById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientById>>,
          TError,
          Awaited<ReturnType<typeof getClientById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetClientById<TData = Awaited<ReturnType<typeof getClientById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–ª—ñ—î–Ω—Ç–∞ –∑–∞ ID
 */

export function useGetClientById<TData = Awaited<ReturnType<typeof getClientById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetClientByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–Ω–æ–≤–ª—é—î –¥–∞–Ω—ñ —ñ—Å–Ω—É—é—á–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const updateClient = (
    id: string,
    updateClientRequest: UpdateClientRequest,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/clients/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateClientRequest
    },
      options);
    }
  


export const getUpdateClientMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClient>>, TError,{id: string;data: UpdateClientRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateClient>>, TError,{id: string;data: UpdateClientRequest}, TContext> => {

const mutationKey = ['updateClient'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateClient>>, {id: string;data: UpdateClientRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateClient(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateClientMutationResult = NonNullable<Awaited<ReturnType<typeof updateClient>>>
    export type UpdateClientMutationBody = UpdateClientRequest
    export type UpdateClientMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useUpdateClient = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClient>>, TError,{id: string;data: UpdateClientRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateClient>>,
        TError,
        {id: string;data: UpdateClientRequest},
        TContext
      > => {

      const mutationOptions = getUpdateClientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –í–∏–¥–∞–ª—è—î –∫–ª—ñ—î–Ω—Ç–∞ –∑–∞ –π–æ–≥–æ ID
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const deleteClient = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeleteClient204>(
      {url: `/clients/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteClientMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClient>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteClient>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteClient'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteClient>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteClient(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteClientMutationResult = NonNullable<Awaited<ReturnType<typeof deleteClient>>>
    
    export type DeleteClientMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useDeleteClient = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClient>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteClient>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteClientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É –∑–∞ ID
 */
export const getBranchLocationById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetBranchLocationByIdQueryKey = (id: string,) => {
    return [`/branch-locations/${id}`] as const;
    }

    
export const getGetBranchLocationByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchLocationByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranchLocationById>>> = ({ signal }) => getBranchLocationById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBranchLocationByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getBranchLocationById>>>
export type GetBranchLocationByIdInfiniteQueryError = ErrorResponse


export function useGetBranchLocationByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationById>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationById>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É –∑–∞ ID
 */

export function useGetBranchLocationByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBranchLocationByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBranchLocationByIdQueryOptions = <TData = Awaited<ReturnType<typeof getBranchLocationById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchLocationByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranchLocationById>>> = ({ signal }) => getBranchLocationById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBranchLocationByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBranchLocationById>>>
export type GetBranchLocationByIdQueryError = ErrorResponse


export function useGetBranchLocationById<TData = Awaited<ReturnType<typeof getBranchLocationById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationById>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationById<TData = Awaited<ReturnType<typeof getBranchLocationById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationById>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationById<TData = Awaited<ReturnType<typeof getBranchLocationById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É –∑–∞ ID
 */

export function useGetBranchLocationById<TData = Awaited<ReturnType<typeof getBranchLocationById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBranchLocationByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–Ω–æ–≤–ª—é—î —ñ—Å–Ω—É—é—á–∏–π –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É –∑–∞–º–æ–≤–ª–µ–Ω—å
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É
 */
export const updateBranchLocation = (
    id: string,
    branchLocationUpdateRequest: BranchLocationUpdateRequest,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: branchLocationUpdateRequest
    },
      options);
    }
  


export const getUpdateBranchLocationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBranchLocation>>, TError,{id: string;data: BranchLocationUpdateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateBranchLocation>>, TError,{id: string;data: BranchLocationUpdateRequest}, TContext> => {

const mutationKey = ['updateBranchLocation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBranchLocation>>, {id: string;data: BranchLocationUpdateRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBranchLocation(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBranchLocationMutationResult = NonNullable<Awaited<ReturnType<typeof updateBranchLocation>>>
    export type UpdateBranchLocationMutationBody = BranchLocationUpdateRequest
    export type UpdateBranchLocationMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É
 */
export const useUpdateBranchLocation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBranchLocation>>, TError,{id: string;data: BranchLocationUpdateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBranchLocation>>,
        TError,
        {id: string;data: BranchLocationUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateBranchLocationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –í–∏–¥–∞–ª—è—î –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É –∑–∞–º–æ–≤–ª–µ–Ω—å
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É
 */
export const deleteBranchLocation = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeleteBranchLocation204>(
      {url: `/branch-locations/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteBranchLocationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBranchLocation>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBranchLocation>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteBranchLocation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBranchLocation>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteBranchLocation(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBranchLocationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBranchLocation>>>
    
    export type DeleteBranchLocationMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É
 */
export const useDeleteBranchLocation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBranchLocation>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBranchLocation>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteBranchLocationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ó–º—ñ–Ω—é—î —Å—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ –ø—É–Ω–∫—Ç—É –ø—Ä–∏–π–æ–º—É
 * @summary –ó–º—ñ–Ω–∏—Ç–∏ —Å—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
 */
export const setActiveStatus = (
    id: string,
    params: SetActiveStatusParams,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations/${id}/active`, method: 'PUT',
        params
    },
      options);
    }
  


export const getSetActiveStatusMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setActiveStatus>>, TError,{id: string;params: SetActiveStatusParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof setActiveStatus>>, TError,{id: string;params: SetActiveStatusParams}, TContext> => {

const mutationKey = ['setActiveStatus'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setActiveStatus>>, {id: string;params: SetActiveStatusParams}> = (props) => {
          const {id,params} = props ?? {};

          return  setActiveStatus(id,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetActiveStatusMutationResult = NonNullable<Awaited<ReturnType<typeof setActiveStatus>>>
    
    export type SetActiveStatusMutationError = ErrorResponse

    /**
 * @summary –ó–º—ñ–Ω–∏—Ç–∏ —Å—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
 */
export const useSetActiveStatus = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setActiveStatus>>, TError,{id: string;params: SetActiveStatusParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setActiveStatus>>,
        TError,
        {id: string;params: SetActiveStatusParams},
        TContext
      > => {

      const mutationOptions = getSetActiveStatusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∞–±–æ —Ç—ñ–ª—å–∫–∏ –∞–∫—Ç–∏–≤–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –ø–ª—è–º –∑ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—é —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—ó –∑–∞ —Ä—ñ–≤–Ω–µ–º —Ä–∏–∑–∏–∫—É
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º
 */
export const getStainTypes = (
    params?: GetStainTypesParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainTypeDTO[]>(
      {url: `/stain-types`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetStainTypesQueryKey = (params?: GetStainTypesParams,) => {
    return [`/stain-types`, ...(params ? [params]: [])] as const;
    }

    
export const getGetStainTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes>>> = ({ signal }) => getStainTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes>>>
export type GetStainTypesInfiniteQueryError = ErrorResponse


export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params: undefined |  GetStainTypesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º
 */

export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypesInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypesQueryOptions = <TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes>>> = ({ signal }) => getStainTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes>>>
export type GetStainTypesQueryError = ErrorResponse


export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params: undefined |  GetStainTypesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º
 */

export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤–∏–π —Ç–∏–ø –ø–ª—è–º–∏ –∑ –≤–∫–∞–∑–∞–Ω–∏–º–∏ –¥–∞–Ω–∏–º–∏
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const createStainType = (
    stainTypeDTO: StainTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreateStainType200>(
      {url: `/stain-types`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: stainTypeDTO, signal
    },
      options);
    }
  


export const getCreateStainTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStainType>>, TError,{data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createStainType>>, TError,{data: StainTypeDTO}, TContext> => {

const mutationKey = ['createStainType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStainType>>, {data: StainTypeDTO}> = (props) => {
          const {data} = props ?? {};

          return  createStainType(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateStainTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createStainType>>>
    export type CreateStainTypeMutationBody = StainTypeDTO
    export type CreateStainTypeMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const useCreateStainType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStainType>>, TError,{data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createStainType>>,
        TError,
        {data: StainTypeDTO},
        TContext
      > => {

      const mutationOptions = getCreateStainTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ó–±–µ—Ä—ñ–≥–∞—î –Ω–æ–≤–∏–π –∞–±–æ –æ–Ω–æ–≤–ª—é—î —ñ—Å–Ω—É—é—á–∏–π –ø—ñ–¥–ø–∏—Å –∫–ª—ñ—î–Ω—Ç–∞
 * @summary –ó–±–µ—Ä–µ–≥—Ç–∏ –ø—ñ–¥–ø–∏—Å –∫–ª—ñ—î–Ω—Ç–∞
 */
export const saveSignature = (
    customerSignatureRequest: CustomerSignatureRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CustomerSignatureResponse>(
      {url: `/signatures`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: customerSignatureRequest, signal
    },
      options);
    }
  


export const getSaveSignatureMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveSignature>>, TError,{data: CustomerSignatureRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof saveSignature>>, TError,{data: CustomerSignatureRequest}, TContext> => {

const mutationKey = ['saveSignature'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveSignature>>, {data: CustomerSignatureRequest}> = (props) => {
          const {data} = props ?? {};

          return  saveSignature(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SaveSignatureMutationResult = NonNullable<Awaited<ReturnType<typeof saveSignature>>>
    export type SaveSignatureMutationBody = CustomerSignatureRequest
    export type SaveSignatureMutationError = ErrorResponse

    /**
 * @summary –ó–±–µ—Ä–µ–≥—Ç–∏ –ø—ñ–¥–ø–∏—Å –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useSaveSignature = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveSignature>>, TError,{data: CustomerSignatureRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof saveSignature>>,
        TError,
        {data: CustomerSignatureRequest},
        TContext
      > => {

      const mutationOptions = getSaveSignatureMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ì–µ–Ω–µ—Ä—É—î PDF-–∫–≤–∏—Ç–∞–Ω—Ü—ñ—é –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –∑ –≤–∫–∞–∑–∞–Ω–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
 * @summary –ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ PDF-–∫–≤–∏—Ç–∞–Ω—Ü—ñ—é
 */
export const generatePdfReceipt = (
    receiptGenerationRequest: ReceiptGenerationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PdfReceiptResponse>(
      {url: `/receipts/pdf`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: receiptGenerationRequest, signal
    },
      options);
    }
  


export const getGeneratePdfReceiptMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePdfReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof generatePdfReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext> => {

const mutationKey = ['generatePdfReceipt'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generatePdfReceipt>>, {data: ReceiptGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  generatePdfReceipt(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GeneratePdfReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof generatePdfReceipt>>>
    export type GeneratePdfReceiptMutationBody = ReceiptGenerationRequest
    export type GeneratePdfReceiptMutationError = ErrorResponse

    /**
 * @summary –ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ PDF-–∫–≤–∏—Ç–∞–Ω—Ü—ñ—é
 */
export const useGeneratePdfReceipt = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePdfReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generatePdfReceipt>>,
        TError,
        {data: ReceiptGenerationRequest},
        TContext
      > => {

      const mutationOptions = getGeneratePdfReceiptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –í—ñ–¥–ø—Ä–∞–≤–ª—è—î PDF-–∫–≤–∏—Ç–∞–Ω—Ü—ñ—é –Ω–∞ –≤–∫–∞–∑–∞–Ω–∏–π email
 * @summary –í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ –∫–≤–∏—Ç–∞–Ω—Ü—ñ—é –Ω–∞ email
 */
export const sendReceiptByEmail = (
    emailReceiptRequest: EmailReceiptRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<EmailReceiptResponse>(
      {url: `/receipts/email`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: emailReceiptRequest, signal
    },
      options);
    }
  


export const getSendReceiptByEmailMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendReceiptByEmail>>, TError,{data: EmailReceiptRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof sendReceiptByEmail>>, TError,{data: EmailReceiptRequest}, TContext> => {

const mutationKey = ['sendReceiptByEmail'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendReceiptByEmail>>, {data: EmailReceiptRequest}> = (props) => {
          const {data} = props ?? {};

          return  sendReceiptByEmail(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendReceiptByEmailMutationResult = NonNullable<Awaited<ReturnType<typeof sendReceiptByEmail>>>
    export type SendReceiptByEmailMutationBody = EmailReceiptRequest
    export type SendReceiptByEmailMutationError = ErrorResponse

    /**
 * @summary –í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ –∫–≤–∏—Ç–∞–Ω—Ü—ñ—é –Ω–∞ email
 */
export const useSendReceiptByEmail = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendReceiptByEmail>>, TError,{data: EmailReceiptRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendReceiptByEmail>>,
        TError,
        {data: EmailReceiptRequest},
        TContext
      > => {

      const mutationOptions = getSendReceiptByEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∞–∫—Ç–∏–≤–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏
 */
export const getAllModifiers = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAllModifiers200>(
      {url: `/price-modifiers`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllModifiersQueryKey = () => {
    return [`/price-modifiers`] as const;
    }

    
export const getGetAllModifiersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllModifiersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllModifiers>>> = ({ signal }) => getAllModifiers(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllModifiersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllModifiers>>>
export type GetAllModifiersInfiniteQueryError = ErrorResponse


export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∞–∫—Ç–∏–≤–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏
 */

export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllModifiersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllModifiersQueryOptions = <TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllModifiersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllModifiers>>> = ({ signal }) => getAllModifiers(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllModifiers>>>
export type GetAllModifiersQueryError = ErrorResponse


export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∞–∫—Ç–∏–≤–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏
 */

export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllModifiersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const createModifier = (
    priceModifierDTO: PriceModifierDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreateModifier200>(
      {url: `/price-modifiers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: priceModifierDTO, signal
    },
      options);
    }
  


export const getCreateModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModifier>>, TError,{data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createModifier>>, TError,{data: PriceModifierDTO}, TContext> => {

const mutationKey = ['createModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createModifier>>, {data: PriceModifierDTO}> = (props) => {
          const {data} = props ?? {};

          return  createModifier(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateModifierMutationResult = NonNullable<Awaited<ReturnType<typeof createModifier>>>
    export type CreateModifierMutationBody = PriceModifierDTO
    export type CreateModifierMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const useCreateModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModifier>>, TError,{data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createModifier>>,
        TError,
        {data: PriceModifierDTO},
        TContext
      > => {

      const mutationOptions = getCreateModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –≤ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const createPriceListItem = (
    categoryId: string,
    priceListItemDTO: PriceListItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreatePriceListItem200>(
      {url: `/price-list/${categoryId}/item`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: priceListItemDTO, signal
    },
      options);
    }
  


export const getCreatePriceListItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPriceListItem>>, TError,{categoryId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createPriceListItem>>, TError,{categoryId: string;data: PriceListItemDTO}, TContext> => {

const mutationKey = ['createPriceListItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPriceListItem>>, {categoryId: string;data: PriceListItemDTO}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  createPriceListItem(categoryId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePriceListItemMutationResult = NonNullable<Awaited<ReturnType<typeof createPriceListItem>>>
    export type CreatePriceListItemMutationBody = PriceListItemDTO
    export type CreatePriceListItemMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –≤ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const useCreatePriceListItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPriceListItem>>, TError,{categoryId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPriceListItem>>,
        TError,
        {categoryId: string;data: PriceListItemDTO},
        TContext
      > => {

      const mutationOptions = getCreatePriceListItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤—É –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥
 */
export const createCategory = (
    serviceCategoryDTO: ServiceCategoryDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreateCategory200>(
      {url: `/price-list/category`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: serviceCategoryDTO, signal
    },
      options);
    }
  


export const getCreateCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: ServiceCategoryDTO}, TContext> => {

const mutationKey = ['createCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCategory>>, {data: ServiceCategoryDTO}> = (props) => {
          const {data} = props ?? {};

          return  createCategory(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof createCategory>>>
    export type CreateCategoryMutationBody = ServiceCategoryDTO
    export type CreateCategoryMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤—É –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥
 */
export const useCreateCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCategory>>,
        TError,
        {data: ServiceCategoryDTO},
        TContext
      > => {

      const mutationOptions = getCreateCategoryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∑–∞ —Å–ø–∏—Å–∫–æ–º —ó—Ö –∫–æ–¥—ñ–≤
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫—ñ–ª—å–∫–∞ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤
 */
export const getModifiersByCodes = (
    getModifiersByCodesBody: string[],
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersByCodes200>(
      {url: `/price-calculation/modifiers/batch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: getModifiersByCodesBody, signal
    },
      options);
    }
  


export const getGetModifiersByCodesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getModifiersByCodes>>, TError,{data: string[]}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof getModifiersByCodes>>, TError,{data: string[]}, TContext> => {

const mutationKey = ['getModifiersByCodes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getModifiersByCodes>>, {data: string[]}> = (props) => {
          const {data} = props ?? {};

          return  getModifiersByCodes(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetModifiersByCodesMutationResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCodes>>>
    export type GetModifiersByCodesMutationBody = string[]
    export type GetModifiersByCodesMutationError = ErrorResponse

    /**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫—ñ–ª—å–∫–∞ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤
 */
export const useGetModifiersByCodes = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getModifiersByCodes>>, TError,{data: string[]}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getModifiersByCodes>>,
        TError,
        {data: string[]},
        TContext
      > => {

      const mutationOptions = getGetModifiersByCodesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –î–µ—Ç–∞–ª—å–Ω–∏–π —Ä–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ü—ñ–Ω–∏ –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –±–∞–∑–æ–≤–æ—ó —Ü—ñ–Ω–∏, –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤, –∑–Ω–∏–∂–æ–∫ —Ç–∞ —Ç–µ—Ä–º—ñ–Ω–æ–≤–æ—Å—Ç—ñ
 * @summary –†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ —Ü—ñ–Ω—É –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –≤–∏–±—Ä–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤
 */
export const calculatePrice = (
    priceCalculationRequestDTO: PriceCalculationRequestDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceCalculationResponseDTO>(
      {url: `/price-calculation/calculate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: priceCalculationRequestDTO, signal
    },
      options);
    }
  


export const getCalculatePriceMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculatePrice>>, TError,{data: PriceCalculationRequestDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof calculatePrice>>, TError,{data: PriceCalculationRequestDTO}, TContext> => {

const mutationKey = ['calculatePrice'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculatePrice>>, {data: PriceCalculationRequestDTO}> = (props) => {
          const {data} = props ?? {};

          return  calculatePrice(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalculatePriceMutationResult = NonNullable<Awaited<ReturnType<typeof calculatePrice>>>
    export type CalculatePriceMutationBody = PriceCalculationRequestDTO
    export type CalculatePriceMutationError = void | ErrorResponse

    /**
 * @summary –†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ —Ü—ñ–Ω—É –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –≤–∏–±—Ä–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤
 */
export const useCalculatePrice = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculatePrice>>, TError,{data: PriceCalculationRequestDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof calculatePrice>>,
        TError,
        {data: PriceCalculationRequestDTO},
        TContext
      > => {

      const mutationOptions = getCalculatePriceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∑–∞–º–æ–≤–ª–µ–Ω—å
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const getAllOrders = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO[]>(
      {url: `/orders`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllOrdersQueryKey = () => {
    return [`/orders`] as const;
    }

    
export const getGetAllOrdersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllOrders>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllOrders>>> = ({ signal }) => getAllOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllOrders>>>
export type GetAllOrdersInfiniteQueryError = ErrorResponse


export function useGetAllOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllOrders>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllOrders>>,
          TError,
          Awaited<ReturnType<typeof getAllOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllOrders>>,
          TError,
          Awaited<ReturnType<typeof getAllOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetAllOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllOrdersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getAllOrders>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllOrders>>> = ({ signal }) => getAllOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllOrders>>>
export type GetAllOrdersQueryError = ErrorResponse


export function useGetAllOrders<TData = Awaited<ReturnType<typeof getAllOrders>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllOrders>>,
          TError,
          Awaited<ReturnType<typeof getAllOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllOrders<TData = Awaited<ReturnType<typeof getAllOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllOrders>>,
          TError,
          Awaited<ReturnType<typeof getAllOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllOrders<TData = Awaited<ReturnType<typeof getAllOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetAllOrders<TData = Awaited<ReturnType<typeof getAllOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllOrdersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const createOrder = (
    createOrderRequest: CreateOrderRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createOrderRequest, signal
    },
      options);
    }
  


export const getCreateOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: CreateOrderRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: CreateOrderRequest}, TContext> => {

const mutationKey = ['createOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOrder>>, {data: CreateOrderRequest}> = (props) => {
          const {data} = props ?? {};

          return  createOrder(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOrderMutationResult = NonNullable<Awaited<ReturnType<typeof createOrder>>>
    export type CreateOrderMutationBody = CreateOrderRequest
    export type CreateOrderMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useCreateOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: CreateOrderRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOrder>>,
        TError,
        {data: CreateOrderRequest},
        TContext
      > => {

      const mutationOptions = getCreateOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –ø–æ—Ç–æ—á–Ω—ñ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –≤–∏–º–æ–≥–∏ —Ç–∞ –ø—Ä–∏–º—ñ—Ç–∫–∏ –∫–ª—ñ—î–Ω—Ç–∞ –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –≤–∏–º–æ–≥–∏ —Ç–∞ –ø—Ä–∏–º—ñ—Ç–∫–∏ –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const getRequirements = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetRequirements200>(
      {url: `/orders/${orderId}/requirements`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRequirementsQueryKey = (orderId: string,) => {
    return [`/orders/${orderId}/requirements`] as const;
    }

    
export const getGetRequirementsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRequirements>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRequirementsQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRequirements>>> = ({ signal }) => getRequirements(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRequirementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRequirements>>>
export type GetRequirementsInfiniteQueryError = ErrorResponse


export function useGetRequirementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRequirements>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirements>>,
          TError,
          Awaited<ReturnType<typeof getRequirements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRequirements>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirements>>,
          TError,
          Awaited<ReturnType<typeof getRequirements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRequirements>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –≤–∏–º–æ–≥–∏ —Ç–∞ –ø—Ä–∏–º—ñ—Ç–∫–∏ –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetRequirementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRequirements>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRequirementsInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRequirementsQueryOptions = <TData = Awaited<ReturnType<typeof getRequirements>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRequirementsQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRequirements>>> = ({ signal }) => getRequirements(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRequirementsQueryResult = NonNullable<Awaited<ReturnType<typeof getRequirements>>>
export type GetRequirementsQueryError = ErrorResponse


export function useGetRequirements<TData = Awaited<ReturnType<typeof getRequirements>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirements>>,
          TError,
          Awaited<ReturnType<typeof getRequirements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirements<TData = Awaited<ReturnType<typeof getRequirements>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirements>>,
          TError,
          Awaited<ReturnType<typeof getRequirements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirements<TData = Awaited<ReturnType<typeof getRequirements>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –≤–∏–º–æ–≥–∏ —Ç–∞ –ø—Ä–∏–º—ñ—Ç–∫–∏ –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetRequirements<TData = Awaited<ReturnType<typeof getRequirements>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirements>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRequirementsQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ó–±–µ—Ä—ñ–≥–∞—î –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –≤–∏–º–æ–≥–∏ —Ç–∞ –ø—Ä–∏–º—ñ—Ç–∫–∏ –∫–ª—ñ—î–Ω—Ç–∞ –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –≤–∏–º–æ–≥–∏ —Ç–∞ –ø—Ä–∏–º—ñ—Ç–∫–∏ –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const updateRequirements = (
    orderId: string,
    additionalRequirementsRequest: AdditionalRequirementsRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<UpdateRequirements200>(
      {url: `/orders/${orderId}/requirements`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: additionalRequirementsRequest, signal
    },
      options);
    }
  


export const getUpdateRequirementsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRequirements>>, TError,{orderId: string;data: AdditionalRequirementsRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateRequirements>>, TError,{orderId: string;data: AdditionalRequirementsRequest}, TContext> => {

const mutationKey = ['updateRequirements'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRequirements>>, {orderId: string;data: AdditionalRequirementsRequest}> = (props) => {
          const {orderId,data} = props ?? {};

          return  updateRequirements(orderId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRequirementsMutationResult = NonNullable<Awaited<ReturnType<typeof updateRequirements>>>
    export type UpdateRequirementsMutationBody = AdditionalRequirementsRequest
    export type UpdateRequirementsMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –≤–∏–º–æ–≥–∏ —Ç–∞ –ø—Ä–∏–º—ñ—Ç–∫–∏ –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useUpdateRequirements = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRequirements>>, TError,{orderId: string;data: AdditionalRequirementsRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRequirements>>,
        TError,
        {orderId: string;data: AdditionalRequirementsRequest},
        TContext
      > => {

      const mutationOptions = getUpdateRequirementsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –ø–æ—Ç–æ—á–Ω—ñ –¥–∞–Ω—ñ –ø—Ä–æ –æ–ø–ª–∞—Ç—É –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –æ–ø–ª–∞—Ç—É –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const getOrderPayment = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetOrderPayment200>(
      {url: `/orders/${orderId}/payment`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderPaymentQueryKey = (orderId: string,) => {
    return [`/orders/${orderId}/payment`] as const;
    }

    
export const getGetOrderPaymentInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderPayment>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderPaymentQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderPayment>>> = ({ signal }) => getOrderPayment(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderPaymentInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderPayment>>>
export type GetOrderPaymentInfiniteQueryError = ErrorResponse


export function useGetOrderPaymentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderPayment>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderPayment>>,
          TError,
          Awaited<ReturnType<typeof getOrderPayment>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderPaymentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderPayment>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderPayment>>,
          TError,
          Awaited<ReturnType<typeof getOrderPayment>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderPaymentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderPayment>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –æ–ø–ª–∞—Ç—É –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetOrderPaymentInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderPayment>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderPaymentInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderPaymentQueryOptions = <TData = Awaited<ReturnType<typeof getOrderPayment>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderPaymentQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderPayment>>> = ({ signal }) => getOrderPayment(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderPaymentQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderPayment>>>
export type GetOrderPaymentQueryError = ErrorResponse


export function useGetOrderPayment<TData = Awaited<ReturnType<typeof getOrderPayment>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderPayment>>,
          TError,
          Awaited<ReturnType<typeof getOrderPayment>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderPayment<TData = Awaited<ReturnType<typeof getOrderPayment>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderPayment>>,
          TError,
          Awaited<ReturnType<typeof getOrderPayment>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderPayment<TData = Awaited<ReturnType<typeof getOrderPayment>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –æ–ø–ª–∞—Ç—É –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetOrderPayment<TData = Awaited<ReturnType<typeof getOrderPayment>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderPayment>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderPaymentQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ó–±–µ—Ä—ñ–≥–∞—î —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –æ–ø–ª–∞—Ç—É —Ç–∞ —Ä–æ–∑—Ä–∞—Ö–æ–≤—É—î —Ñ—ñ–Ω–∞–ª—å–Ω—ñ —Å—É–º–∏
 * @summary –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –æ–ø–ª–∞—Ç—É –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const applyPayment = (
    orderId: string,
    paymentCalculationRequest: PaymentCalculationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ApplyPayment200>(
      {url: `/orders/${orderId}/payment`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: paymentCalculationRequest, signal
    },
      options);
    }
  


export const getApplyPaymentMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyPayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof applyPayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext> => {

const mutationKey = ['applyPayment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof applyPayment>>, {orderId: string;data: PaymentCalculationRequest}> = (props) => {
          const {orderId,data} = props ?? {};

          return  applyPayment(orderId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApplyPaymentMutationResult = NonNullable<Awaited<ReturnType<typeof applyPayment>>>
    export type ApplyPaymentMutationBody = PaymentCalculationRequest
    export type ApplyPaymentMutationError = ErrorResponse

    /**
 * @summary –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –æ–ø–ª–∞—Ç—É –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useApplyPayment = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyPayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof applyPayment>>,
        TError,
        {orderId: string;data: PaymentCalculationRequest},
        TContext
      > => {

      const mutationOptions = getApplyPaymentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –†–æ–∑—Ä–∞—Ö–æ–≤—É—î —Å—É–º–∏ –æ–ø–ª–∞—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤–∫–∞–∑–∞–Ω–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ –±–µ–∑ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —É –±–∞–∑—ñ –¥–∞–Ω–∏—Ö
 * @summary –†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ –¥–µ—Ç–∞–ª—ñ –æ–ø–ª–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const calculatePayment = (
    orderId: string,
    paymentCalculationRequest: PaymentCalculationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CalculatePayment200>(
      {url: `/orders/${orderId}/payment/calculate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: paymentCalculationRequest, signal
    },
      options);
    }
  


export const getCalculatePaymentMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculatePayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof calculatePayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext> => {

const mutationKey = ['calculatePayment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculatePayment>>, {orderId: string;data: PaymentCalculationRequest}> = (props) => {
          const {orderId,data} = props ?? {};

          return  calculatePayment(orderId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalculatePaymentMutationResult = NonNullable<Awaited<ReturnType<typeof calculatePayment>>>
    export type CalculatePaymentMutationBody = PaymentCalculationRequest
    export type CalculatePaymentMutationError = ErrorResponse

    /**
 * @summary –†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ –¥–µ—Ç–∞–ª—ñ –æ–ø–ª–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useCalculatePayment = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculatePayment>>, TError,{orderId: string;data: PaymentCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof calculatePayment>>,
        TError,
        {orderId: string;data: PaymentCalculationRequest},
        TContext
      > => {

      const mutationOptions = getCalculatePaymentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –ø—Ä–µ–¥–º–µ—Ç—ñ–≤ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –ø—Ä–µ–¥–º–µ—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const getOrderItems = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderItemDTO[]>(
      {url: `/orders/${orderId}/items`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderItemsQueryKey = (orderId: string,) => {
    return [`/orders/${orderId}/items`] as const;
    }

    
export const getGetOrderItemsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderItems>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderItemsQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderItems>>> = ({ signal }) => getOrderItems(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderItemsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderItems>>>
export type GetOrderItemsInfiniteQueryError = ErrorResponse


export function useGetOrderItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItems>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItems>>,
          TError,
          Awaited<ReturnType<typeof getOrderItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItems>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItems>>,
          TError,
          Awaited<ReturnType<typeof getOrderItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItems>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –ø—Ä–µ–¥–º–µ—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetOrderItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderItems>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderItemsInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderItemsQueryOptions = <TData = Awaited<ReturnType<typeof getOrderItems>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderItemsQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderItems>>> = ({ signal }) => getOrderItems(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderItems>>>
export type GetOrderItemsQueryError = ErrorResponse


export function useGetOrderItems<TData = Awaited<ReturnType<typeof getOrderItems>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItems>>,
          TError,
          Awaited<ReturnType<typeof getOrderItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItems<TData = Awaited<ReturnType<typeof getOrderItems>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderItems>>,
          TError,
          Awaited<ReturnType<typeof getOrderItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderItems<TData = Awaited<ReturnType<typeof getOrderItems>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –ø—Ä–µ–¥–º–µ—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetOrderItems<TData = Awaited<ReturnType<typeof getOrderItems>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderItemsQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –î–æ–¥–∞—î –Ω–æ–≤–∏–π –ø—Ä–µ–¥–º–µ—Ç –¥–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –î–æ–¥–∞—Ç–∏ –Ω–æ–≤–∏–π –ø—Ä–µ–¥–º–µ—Ç –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const addOrderItem = (
    orderId: string,
    orderItemDTO: OrderItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderItemDTO>(
      {url: `/orders/${orderId}/items`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderItemDTO, signal
    },
      options);
    }
  


export const getAddOrderItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addOrderItem>>, TError,{orderId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof addOrderItem>>, TError,{orderId: string;data: OrderItemDTO}, TContext> => {

const mutationKey = ['addOrderItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addOrderItem>>, {orderId: string;data: OrderItemDTO}> = (props) => {
          const {orderId,data} = props ?? {};

          return  addOrderItem(orderId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddOrderItemMutationResult = NonNullable<Awaited<ReturnType<typeof addOrderItem>>>
    export type AddOrderItemMutationBody = OrderItemDTO
    export type AddOrderItemMutationError = ErrorResponse

    /**
 * @summary –î–æ–¥–∞—Ç–∏ –Ω–æ–≤–∏–π –ø—Ä–µ–¥–º–µ—Ç –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useAddOrderItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addOrderItem>>, TError,{orderId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addOrderItem>>,
        TError,
        {orderId: string;data: OrderItemDTO},
        TContext
      > => {

      const mutationOptions = getAddOrderItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –í—ñ–¥–ø—Ä–∞–≤–ª—è—î PDF-—á–µ–∫ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –Ω–∞ email –∫–ª—ñ—î–Ω—Ç–∞
 * @summary –í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ —á–µ–∫ –Ω–∞ email
 */
export const emailReceipt = (
    orderId: string,
    emailReceiptRequest: EmailReceiptRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<EmailReceipt200>(
      {url: `/orders/finalization/${orderId}/email-receipt`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: emailReceiptRequest, signal
    },
      options);
    }
  


export const getEmailReceiptMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof emailReceipt>>, TError,{orderId: string;data: EmailReceiptRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof emailReceipt>>, TError,{orderId: string;data: EmailReceiptRequest}, TContext> => {

const mutationKey = ['emailReceipt'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof emailReceipt>>, {orderId: string;data: EmailReceiptRequest}> = (props) => {
          const {orderId,data} = props ?? {};

          return  emailReceipt(orderId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EmailReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof emailReceipt>>>
    export type EmailReceiptMutationBody = EmailReceiptRequest
    export type EmailReceiptMutationError = ErrorResponse

    /**
 * @summary –í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ —á–µ–∫ –Ω–∞ email
 */
export const useEmailReceipt = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof emailReceipt>>, TError,{orderId: string;data: EmailReceiptRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof emailReceipt>>,
        TError,
        {orderId: string;data: EmailReceiptRequest},
        TContext
      > => {

      const mutationOptions = getEmailReceiptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –§—ñ–Ω–∞–ª—ñ–∑—É—î –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è, –∑–±–µ—Ä—ñ–≥–∞—î –ø—ñ–¥–ø–∏—Å –∫–ª—ñ—î–Ω—Ç–∞ —Ç–∞ –∑–º—ñ–Ω—é—î —Å—Ç–∞—Ç—É—Å –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –ó–∞–≤–µ—Ä—à–∏—Ç–∏ –æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const finalizeOrder = (
    orderFinalizationRequest: OrderFinalizationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/finalization/complete`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderFinalizationRequest, signal
    },
      options);
    }
  


export const getFinalizeOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalizeOrder>>, TError,{data: OrderFinalizationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof finalizeOrder>>, TError,{data: OrderFinalizationRequest}, TContext> => {

const mutationKey = ['finalizeOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalizeOrder>>, {data: OrderFinalizationRequest}> = (props) => {
          const {data} = props ?? {};

          return  finalizeOrder(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalizeOrderMutationResult = NonNullable<Awaited<ReturnType<typeof finalizeOrder>>>
    export type FinalizeOrderMutationBody = OrderFinalizationRequest
    export type FinalizeOrderMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–µ—Ä—à–∏—Ç–∏ –æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useFinalizeOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalizeOrder>>, TError,{data: OrderFinalizationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof finalizeOrder>>,
        TError,
        {data: OrderFinalizationRequest},
        TContext
      > => {

      const mutationOptions = getFinalizeOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ó–±–µ—Ä—ñ–≥–∞—î –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è —è–∫ —á–µ—Ä–Ω–µ—Ç–∫—É
 * @summary –ó–±–µ—Ä–µ–≥—Ç–∏ —á–µ—Ä–Ω–µ—Ç–∫—É –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const saveOrderDraft = (
    createOrderRequest: CreateOrderRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/draft`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createOrderRequest, signal
    },
      options);
    }
  


export const getSaveOrderDraftMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveOrderDraft>>, TError,{data: CreateOrderRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof saveOrderDraft>>, TError,{data: CreateOrderRequest}, TContext> => {

const mutationKey = ['saveOrderDraft'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveOrderDraft>>, {data: CreateOrderRequest}> = (props) => {
          const {data} = props ?? {};

          return  saveOrderDraft(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SaveOrderDraftMutationResult = NonNullable<Awaited<ReturnType<typeof saveOrderDraft>>>
    export type SaveOrderDraftMutationBody = CreateOrderRequest
    export type SaveOrderDraftMutationError = ErrorResponse

    /**
 * @summary –ó–±–µ—Ä–µ–≥—Ç–∏ —á–µ—Ä–Ω–µ—Ç–∫—É –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useSaveOrderDraft = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveOrderDraft>>, TError,{data: CreateOrderRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof saveOrderDraft>>,
        TError,
        {data: CreateOrderRequest},
        TContext
      > => {

      const mutationOptions = getSaveOrderDraftMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ó–∞—Å—Ç–æ—Å–æ–≤—É—î –∑–Ω–∏–∂–∫—É –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –æ–±–º–µ–∂–µ–Ω—å –Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 * @summary –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –∑–Ω–∏–∂–∫—É –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const applyDiscount1 = (
    orderDiscountRequest: OrderDiscountRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ApplyDiscount1200>(
      {url: `/orders/discounts/apply`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderDiscountRequest, signal
    },
      options);
    }
  


export const getApplyDiscount1MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyDiscount1>>, TError,{data: OrderDiscountRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof applyDiscount1>>, TError,{data: OrderDiscountRequest}, TContext> => {

const mutationKey = ['applyDiscount1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof applyDiscount1>>, {data: OrderDiscountRequest}> = (props) => {
          const {data} = props ?? {};

          return  applyDiscount1(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApplyDiscount1MutationResult = NonNullable<Awaited<ReturnType<typeof applyDiscount1>>>
    export type ApplyDiscount1MutationBody = OrderDiscountRequest
    export type ApplyDiscount1MutationError = ErrorResponse

    /**
 * @summary –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –∑–Ω–∏–∂–∫—É –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useApplyDiscount1 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyDiscount1>>, TError,{data: OrderDiscountRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof applyDiscount1>>,
        TError,
        {data: OrderDiscountRequest},
        TContext
      > => {

      const mutationOptions = getApplyDiscount1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –†–æ–∑—Ä–∞—Ö–æ–≤—É—î –¥–∞—Ç—É –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –Ω–∞ –æ—Å–Ω–æ–≤—ñ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –ø–æ—Å–ª—É–≥ —Ç–∞ —Ç–∏–ø—É —Ç–µ—Ä–º—ñ–Ω–æ–≤–æ—Å—Ç—ñ
 * @summary –†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ –æ—á—ñ–∫—É–≤–∞–Ω—É –¥–∞—Ç—É –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const calculateCompletionDate = (
    completionDateCalculationRequest: CompletionDateCalculationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CalculateCompletionDate200>(
      {url: `/orders/completion/calculate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: completionDateCalculationRequest, signal
    },
      options);
    }
  


export const getCalculateCompletionDateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateCompletionDate>>, TError,{data: CompletionDateCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof calculateCompletionDate>>, TError,{data: CompletionDateCalculationRequest}, TContext> => {

const mutationKey = ['calculateCompletionDate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof calculateCompletionDate>>, {data: CompletionDateCalculationRequest}> = (props) => {
          const {data} = props ?? {};

          return  calculateCompletionDate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CalculateCompletionDateMutationResult = NonNullable<Awaited<ReturnType<typeof calculateCompletionDate>>>
    export type CalculateCompletionDateMutationBody = CompletionDateCalculationRequest
    export type CalculateCompletionDateMutationError = ErrorResponse

    /**
 * @summary –†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ –æ—á—ñ–∫—É–≤–∞–Ω—É –¥–∞—Ç—É –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useCalculateCompletionDate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof calculateCompletionDate>>, TError,{data: CompletionDateCalculationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof calculateCompletionDate>>,
        TError,
        {data: CompletionDateCalculationRequest},
        TContext
      > => {

      const mutationOptions = getCalculateCompletionDateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ–π –¥–ª—è –≤–∫–∞–∑–∞–Ω–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—ó –ø—Ä–µ–¥–º–µ—Ç–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const getPhotosByItemId = (
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderItemPhotoDTO[]>(
      {url: `/order-items/${itemId}/photos`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPhotosByItemIdQueryKey = (itemId: string,) => {
    return [`/order-items/${itemId}/photos`] as const;
    }

    
export const getGetPhotosByItemIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPhotosByItemId>>>, TError = ErrorResponse>(itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhotosByItemIdQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotosByItemId>>> = ({ signal }) => getPhotosByItemId(itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPhotosByItemIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotosByItemId>>>
export type GetPhotosByItemIdInfiniteQueryError = ErrorResponse


export function useGetPhotosByItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotosByItemId>>>, TError = ErrorResponse>(
 itemId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotosByItemId>>,
          TError,
          Awaited<ReturnType<typeof getPhotosByItemId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotosByItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotosByItemId>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotosByItemId>>,
          TError,
          Awaited<ReturnType<typeof getPhotosByItemId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotosByItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotosByItemId>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—ó –ø—Ä–µ–¥–º–µ—Ç–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetPhotosByItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotosByItemId>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPhotosByItemIdInfiniteQueryOptions(itemId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPhotosByItemIdQueryOptions = <TData = Awaited<ReturnType<typeof getPhotosByItemId>>, TError = ErrorResponse>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhotosByItemIdQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotosByItemId>>> = ({ signal }) => getPhotosByItemId(itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPhotosByItemIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotosByItemId>>>
export type GetPhotosByItemIdQueryError = ErrorResponse


export function useGetPhotosByItemId<TData = Awaited<ReturnType<typeof getPhotosByItemId>>, TError = ErrorResponse>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotosByItemId>>,
          TError,
          Awaited<ReturnType<typeof getPhotosByItemId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotosByItemId<TData = Awaited<ReturnType<typeof getPhotosByItemId>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotosByItemId>>,
          TError,
          Awaited<ReturnType<typeof getPhotosByItemId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotosByItemId<TData = Awaited<ReturnType<typeof getPhotosByItemId>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—ó –ø—Ä–µ–¥–º–µ—Ç–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetPhotosByItemId<TData = Awaited<ReturnType<typeof getPhotosByItemId>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosByItemId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPhotosByItemIdQueryOptions(itemId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î –Ω–æ–≤—É —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é –¥–ª—è –≤–∫–∞–∑–∞–Ω–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é –ø—Ä–µ–¥–º–µ—Ç–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const uploadPhoto = (
    itemId: string,
    uploadPhotoBody: UploadPhotoBody,
    params?: UploadPhotoParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, uploadPhotoBody.file)

      return orvalFetcher<OrderItemPhotoDTO>(
      {url: `/order-items/${itemId}/photos`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData,
        params, signal
    },
      options);
    }
  


export const getUploadPhotoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadPhoto>>, TError,{itemId: string;data: UploadPhotoBody;params?: UploadPhotoParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof uploadPhoto>>, TError,{itemId: string;data: UploadPhotoBody;params?: UploadPhotoParams}, TContext> => {

const mutationKey = ['uploadPhoto'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadPhoto>>, {itemId: string;data: UploadPhotoBody;params?: UploadPhotoParams}> = (props) => {
          const {itemId,data,params} = props ?? {};

          return  uploadPhoto(itemId,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadPhotoMutationResult = NonNullable<Awaited<ReturnType<typeof uploadPhoto>>>
    export type UploadPhotoMutationBody = UploadPhotoBody
    export type UploadPhotoMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é –ø—Ä–µ–¥–º–µ—Ç–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useUploadPhoto = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadPhoto>>, TError,{itemId: string;data: UploadPhotoBody;params?: UploadPhotoParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadPhoto>>,
        TError,
        {itemId: string;data: UploadPhotoBody;params?: UploadPhotoParams},
        TContext
      > => {

      const mutationOptions = getUploadPhotoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∞–±–æ —Ç—ñ–ª—å–∫–∏ –∞–∫—Ç–∏–≤–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –¥–µ—Ñ–µ–∫—Ç—ñ–≤ –∑ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—é —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—ó –∑–∞ —Ä—ñ–≤–Ω–µ–º —Ä–∏–∑–∏–∫—É
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */
export const getDefectTypes = (
    params?: GetDefectTypesParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<DefectTypeDTO[]>(
      {url: `/defect-types`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetDefectTypesQueryKey = (params?: GetDefectTypesParams,) => {
    return [`/defect-types`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDefectTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypes>>> = ({ signal }) => getDefectTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypes>>>
export type GetDefectTypesInfiniteQueryError = ErrorResponse


export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params: undefined |  GetDefectTypesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypesInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectTypesQueryOptions = <TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypes>>> = ({ signal }) => getDefectTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypes>>>
export type GetDefectTypesQueryError = ErrorResponse


export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params: undefined |  GetDefectTypesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤–∏–π —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑ –≤–∫–∞–∑–∞–Ω–∏–º–∏ –¥–∞–Ω–∏–º–∏
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const createDefectType = (
    defectTypeDTO: DefectTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<DefectTypeDTO>(
      {url: `/defect-types`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: defectTypeDTO, signal
    },
      options);
    }
  


export const getCreateDefectTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDefectType>>, TError,{data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createDefectType>>, TError,{data: DefectTypeDTO}, TContext> => {

const mutationKey = ['createDefectType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDefectType>>, {data: DefectTypeDTO}> = (props) => {
          const {data} = props ?? {};

          return  createDefectType(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDefectTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createDefectType>>>
    export type CreateDefectTypeMutationBody = DefectTypeDTO
    export type CreateDefectTypeMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const useCreateDefectType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDefectType>>, TError,{data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDefectType>>,
        TError,
        {data: DefectTypeDTO},
        TContext
      > => {

      const mutationOptions = getCreateDefectTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∫–ª—ñ—î–Ω—Ç—ñ–≤
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ—Ö –∫–ª—ñ—î–Ω—Ç—ñ–≤
 */
export const getAllClients = (
    params?: GetAllClientsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/clients`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAllClientsQueryKey = (params?: GetAllClientsParams,) => {
    return [`/clients`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllClientsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllClients>>>, TError = ErrorResponse>(params?: GetAllClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllClientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllClients>>> = ({ signal }) => getAllClients(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllClientsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllClients>>>
export type GetAllClientsInfiniteQueryError = ErrorResponse


export function useGetAllClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllClients>>>, TError = ErrorResponse>(
 params: undefined |  GetAllClientsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllClients>>,
          TError,
          Awaited<ReturnType<typeof getAllClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllClients>>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllClients>>,
          TError,
          Awaited<ReturnType<typeof getAllClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllClients>>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ—Ö –∫–ª—ñ—î–Ω—Ç—ñ–≤
 */

export function useGetAllClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllClients>>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllClientsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllClientsQueryOptions = <TData = Awaited<ReturnType<typeof getAllClients>>, TError = ErrorResponse>(params?: GetAllClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllClientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllClients>>> = ({ signal }) => getAllClients(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllClientsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllClients>>>
export type GetAllClientsQueryError = ErrorResponse


export function useGetAllClients<TData = Awaited<ReturnType<typeof getAllClients>>, TError = ErrorResponse>(
 params: undefined |  GetAllClientsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllClients>>,
          TError,
          Awaited<ReturnType<typeof getAllClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllClients<TData = Awaited<ReturnType<typeof getAllClients>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllClients>>,
          TError,
          Awaited<ReturnType<typeof getAllClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllClients<TData = Awaited<ReturnType<typeof getAllClients>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ—Ö –∫–ª—ñ—î–Ω—Ç—ñ–≤
 */

export function useGetAllClients<TData = Awaited<ReturnType<typeof getAllClients>>, TError = ErrorResponse>(
 params?: GetAllClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllClientsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞ –∑ –Ω–∞–¥–∞–Ω–∏–º–∏ –¥–∞–Ω–∏–º–∏
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const createClient = (
    createClientRequest: CreateClientRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/clients`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createClientRequest, signal
    },
      options);
    }
  


export const getCreateClientMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClient>>, TError,{data: CreateClientRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createClient>>, TError,{data: CreateClientRequest}, TContext> => {

const mutationKey = ['createClient'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createClient>>, {data: CreateClientRequest}> = (props) => {
          const {data} = props ?? {};

          return  createClient(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateClientMutationResult = NonNullable<Awaited<ReturnType<typeof createClient>>>
    export type CreateClientMutationBody = CreateClientRequest
    export type CreateClientMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useCreateClient = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClient>>, TError,{data: CreateClientRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createClient>>,
        TError,
        {data: CreateClientRequest},
        TContext
      > => {

      const mutationOptions = getCreateClientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤ –∑–∞ –∑–∞–ø–∏—Ç–æ–º –∑ –ø—ñ–¥—Ç—Ä–∏–º–∫–æ—é –ø–∞–≥—ñ–Ω–∞—Ü—ñ—ó
 * @summary –ü–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤ –∑ –ø–∞–≥—ñ–Ω–∞—Ü—ñ—î—é
 */
export const searchClientsWithPagination = (
    clientSearchRequest: ClientSearchRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientPageResponse>(
      {url: `/clients/search/pagination`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: clientSearchRequest, signal
    },
      options);
    }
  


export const getSearchClientsWithPaginationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchClientsWithPagination>>, TError,{data: ClientSearchRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof searchClientsWithPagination>>, TError,{data: ClientSearchRequest}, TContext> => {

const mutationKey = ['searchClientsWithPagination'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchClientsWithPagination>>, {data: ClientSearchRequest}> = (props) => {
          const {data} = props ?? {};

          return  searchClientsWithPagination(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchClientsWithPaginationMutationResult = NonNullable<Awaited<ReturnType<typeof searchClientsWithPagination>>>
    export type SearchClientsWithPaginationMutationBody = ClientSearchRequest
    export type SearchClientsWithPaginationMutationError = ErrorResponse

    /**
 * @summary –ü–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤ –∑ –ø–∞–≥—ñ–Ω–∞—Ü—ñ—î—é
 */
export const useSearchClientsWithPagination = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchClientsWithPagination>>, TError,{data: ClientSearchRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchClientsWithPagination>>,
        TError,
        {data: ClientSearchRequest},
        TContext
      > => {

      const mutationOptions = getSearchClientsWithPaginationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –ø—É–Ω–∫—Ç—ñ–≤ –ø—Ä–∏–π–æ–º—É, —è–∫—â–æ active=true - —Ç—ñ–ª—å–∫–∏ –∞–∫—Ç–∏–≤–Ω—ñ
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –ø—É–Ω–∫—Ç–∏ –ø—Ä–∏–π–æ–º—É –∑–∞–º–æ–≤–ª–µ–Ω—å
 */
export const getAllBranchLocations = (
    params?: GetAllBranchLocationsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAllBranchLocationsQueryKey = (params?: GetAllBranchLocationsParams,) => {
    return [`/branch-locations`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllBranchLocationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllBranchLocations>>>, TError = ErrorResponse>(params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllBranchLocationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllBranchLocations>>> = ({ signal }) => getAllBranchLocations(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllBranchLocationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllBranchLocations>>>
export type GetAllBranchLocationsInfiniteQueryError = ErrorResponse


export function useGetAllBranchLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllBranchLocations>>>, TError = ErrorResponse>(
 params: undefined |  GetAllBranchLocationsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBranchLocations>>,
          TError,
          Awaited<ReturnType<typeof getAllBranchLocations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBranchLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllBranchLocations>>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBranchLocations>>,
          TError,
          Awaited<ReturnType<typeof getAllBranchLocations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBranchLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllBranchLocations>>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –ø—É–Ω–∫—Ç–∏ –ø—Ä–∏–π–æ–º—É –∑–∞–º–æ–≤–ª–µ–Ω—å
 */

export function useGetAllBranchLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllBranchLocations>>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllBranchLocationsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllBranchLocationsQueryOptions = <TData = Awaited<ReturnType<typeof getAllBranchLocations>>, TError = ErrorResponse>(params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllBranchLocationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllBranchLocations>>> = ({ signal }) => getAllBranchLocations(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllBranchLocationsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllBranchLocations>>>
export type GetAllBranchLocationsQueryError = ErrorResponse


export function useGetAllBranchLocations<TData = Awaited<ReturnType<typeof getAllBranchLocations>>, TError = ErrorResponse>(
 params: undefined |  GetAllBranchLocationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBranchLocations>>,
          TError,
          Awaited<ReturnType<typeof getAllBranchLocations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBranchLocations<TData = Awaited<ReturnType<typeof getAllBranchLocations>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllBranchLocations>>,
          TError,
          Awaited<ReturnType<typeof getAllBranchLocations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllBranchLocations<TData = Awaited<ReturnType<typeof getAllBranchLocations>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –ø—É–Ω–∫—Ç–∏ –ø—Ä–∏–π–æ–º—É –∑–∞–º–æ–≤–ª–µ–Ω—å
 */

export function useGetAllBranchLocations<TData = Awaited<ReturnType<typeof getAllBranchLocations>>, TError = ErrorResponse>(
 params?: GetAllBranchLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllBranchLocations>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllBranchLocationsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤–∏–π –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É –∑–∞–º–æ–≤–ª–µ–Ω—å
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É
 */
export const createBranchLocation = (
    branchLocationCreateRequest: BranchLocationCreateRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: branchLocationCreateRequest, signal
    },
      options);
    }
  


export const getCreateBranchLocationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBranchLocation>>, TError,{data: BranchLocationCreateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createBranchLocation>>, TError,{data: BranchLocationCreateRequest}, TContext> => {

const mutationKey = ['createBranchLocation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBranchLocation>>, {data: BranchLocationCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createBranchLocation(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBranchLocationMutationResult = NonNullable<Awaited<ReturnType<typeof createBranchLocation>>>
    export type CreateBranchLocationMutationBody = BranchLocationCreateRequest
    export type CreateBranchLocationMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É
 */
export const useCreateBranchLocation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBranchLocation>>, TError,{data: BranchLocationCreateRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBranchLocation>>,
        TError,
        {data: BranchLocationCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateBranchLocationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —ñ –ø–æ–≤–µ—Ä—Ç–∞—î JWT —Ç–æ–∫–µ–Ω
 * @summary –†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è –Ω–æ–≤–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
 */
export const register = (
    registerRequest: RegisterRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Register200>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerRequest, signal
    },
      options);
    }
  


export const getRegisterMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext> => {

const mutationKey = ['register'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  register(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
    export type RegisterMutationBody = RegisterRequest
    export type RegisterMutationError = ErrorResponse

    /**
 * @summary –†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è –Ω–æ–≤–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
 */
export const useRegister = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof register>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {

      const mutationOptions = getRegisterMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –û–Ω–æ–≤–ª—é—î JWT —Ç–æ–∫–µ–Ω –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é refresh —Ç–æ–∫–µ–Ω–∞
 * @summary –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–æ–∫–µ–Ω–∞
 */
export const refreshToken = (
    refreshTokenBody: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<RefreshToken200>(
      {url: `/auth/refresh-token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshTokenBody, signal
    },
      options);
    }
  


export const getRefreshTokenMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: string}, TContext> => {

const mutationKey = ['refreshToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshToken>>, {data: string}> = (props) => {
          const {data} = props ?? {};

          return  refreshToken(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshToken>>>
    export type RefreshTokenMutationBody = string
    export type RefreshTokenMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–æ–∫–µ–Ω–∞
 */
export const useRefreshToken = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshToken>>,
        TError,
        {data: string},
        TContext
      > => {

      const mutationOptions = getRefreshTokenMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ê–≤—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫—É—î –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —ñ –ø–æ–≤–µ—Ä—Ç–∞—î JWT —Ç–æ–∫–µ–Ω
 * @summary –í—Ö—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
 */
export const login = (
    loginRequest: LoginRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Login200>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      options);
    }
  


export const getLoginMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = ErrorResponse

    /**
 * @summary –í—Ö—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
 */
export const useLogin = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const completeWizard = (
    wizardId: string,
    createOrderRequest: CreateOrderRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CompleteWizard200>(
      {url: `/api/order-wizard/${wizardId}/complete`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createOrderRequest, signal
    },
      options);
    }
  


export const getCompleteWizardMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeWizard>>, TError,{wizardId: string;data: CreateOrderRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof completeWizard>>, TError,{wizardId: string;data: CreateOrderRequest}, TContext> => {

const mutationKey = ['completeWizard'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeWizard>>, {wizardId: string;data: CreateOrderRequest}> = (props) => {
          const {wizardId,data} = props ?? {};

          return  completeWizard(wizardId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteWizardMutationResult = NonNullable<Awaited<ReturnType<typeof completeWizard>>>
    export type CompleteWizardMutationBody = CreateOrderRequest
    export type CompleteWizardMutationError = ErrorResponse

    export const useCompleteWizard = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeWizard>>, TError,{wizardId: string;data: CreateOrderRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeWizard>>,
        TError,
        {wizardId: string;data: CreateOrderRequest},
        TContext
      > => {

      const mutationOptions = getCompleteWizardMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –í–∏–∫–æ–Ω—É—î –ø–µ–≤–Ω—É –¥—ñ—é –≤ wizard –Ω–∞ –æ—Å–Ω–æ–≤—ñ OrderWizardAction enum
 * @summary –í–∏–∫–æ–Ω–∞—Ç–∏ –¥—ñ—é –≤ Order Wizard
 */
export const executeAction = (
    wizardId: string,
    actionName: string,
    executeActionBody: ExecuteActionBody,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ExecuteAction200>(
      {url: `/api/order-wizard/${wizardId}/action/${actionName}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: executeActionBody, signal
    },
      options);
    }
  


export const getExecuteActionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof executeAction>>, TError,{wizardId: string;actionName: string;data: ExecuteActionBody}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof executeAction>>, TError,{wizardId: string;actionName: string;data: ExecuteActionBody}, TContext> => {

const mutationKey = ['executeAction'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof executeAction>>, {wizardId: string;actionName: string;data: ExecuteActionBody}> = (props) => {
          const {wizardId,actionName,data} = props ?? {};

          return  executeAction(wizardId,actionName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExecuteActionMutationResult = NonNullable<Awaited<ReturnType<typeof executeAction>>>
    export type ExecuteActionMutationBody = ExecuteActionBody
    export type ExecuteActionMutationError = ErrorResponse

    /**
 * @summary –í–∏–∫–æ–Ω–∞—Ç–∏ –¥—ñ—é –≤ Order Wizard
 */
export const useExecuteAction = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof executeAction>>, TError,{wizardId: string;actionName: string;data: ExecuteActionBody}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof executeAction>>,
        TError,
        {wizardId: string;actionName: string;data: ExecuteActionBody},
        TContext
      > => {

      const mutationOptions = getExecuteActionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const submitOrderBasicInfo = (
    wizardId: string,
    orderBasicInfoRequest: OrderBasicInfoRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubmitOrderBasicInfo200>(
      {url: `/api/order-wizard/stage1/${wizardId}/order-info`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderBasicInfoRequest, signal
    },
      options);
    }
  


export const getSubmitOrderBasicInfoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitOrderBasicInfo>>, TError,{wizardId: string;data: OrderBasicInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof submitOrderBasicInfo>>, TError,{wizardId: string;data: OrderBasicInfoRequest}, TContext> => {

const mutationKey = ['submitOrderBasicInfo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitOrderBasicInfo>>, {wizardId: string;data: OrderBasicInfoRequest}> = (props) => {
          const {wizardId,data} = props ?? {};

          return  submitOrderBasicInfo(wizardId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubmitOrderBasicInfoMutationResult = NonNullable<Awaited<ReturnType<typeof submitOrderBasicInfo>>>
    export type SubmitOrderBasicInfoMutationBody = OrderBasicInfoRequest
    export type SubmitOrderBasicInfoMutationError = ErrorResponse

    export const useSubmitOrderBasicInfo = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitOrderBasicInfo>>, TError,{wizardId: string;data: OrderBasicInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof submitOrderBasicInfo>>,
        TError,
        {wizardId: string;data: OrderBasicInfoRequest},
        TContext
      > => {

      const mutationOptions = getSubmitOrderBasicInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const submitClientData = (
    wizardId: string,
    clientResponse: ClientResponse,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubmitClientData200>(
      {url: `/api/order-wizard/stage1/${wizardId}/client`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: clientResponse, signal
    },
      options);
    }
  


export const getSubmitClientDataMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitClientData>>, TError,{wizardId: string;data: ClientResponse}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof submitClientData>>, TError,{wizardId: string;data: ClientResponse}, TContext> => {

const mutationKey = ['submitClientData'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitClientData>>, {wizardId: string;data: ClientResponse}> = (props) => {
          const {wizardId,data} = props ?? {};

          return  submitClientData(wizardId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubmitClientDataMutationResult = NonNullable<Awaited<ReturnType<typeof submitClientData>>>
    export type SubmitClientDataMutationBody = ClientResponse
    export type SubmitClientDataMutationError = ErrorResponse

    export const useSubmitClientData = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitClientData>>, TError,{wizardId: string;data: ClientResponse}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof submitClientData>>,
        TError,
        {wizardId: string;data: ClientResponse},
        TContext
      > => {

      const mutationOptions = getSubmitClientDataMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤—É —Å–µ—Å—ñ—é Order Wizard –¥–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π Order Wizard
 */
export const createWizard = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardSessionResponse>(
      {url: `/api/order-wizard/create`, method: 'POST', signal
    },
      options);
    }
  


export const getCreateWizardMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWizard>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createWizard>>, TError,void, TContext> => {

const mutationKey = ['createWizard'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWizard>>, void> = () => {
          

          return  createWizard(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateWizardMutationResult = NonNullable<Awaited<ReturnType<typeof createWizard>>>
    
    export type CreateWizardMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π Order Wizard
 */
export const useCreateWizard = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWizard>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createWizard>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateWizardMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—É –æ–¥–∏–Ω–∏—Ü—é –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const getRecommendedUnitOfMeasure = (
    params: GetRecommendedUnitOfMeasureParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/units-of-measure/recommend`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedUnitOfMeasureQueryKey = (params: GetRecommendedUnitOfMeasureParams,) => {
    return [`/units-of-measure/recommend`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedUnitOfMeasureInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedUnitOfMeasureQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>> = ({ signal }) => getRecommendedUnitOfMeasure(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedUnitOfMeasureInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>
export type GetRecommendedUnitOfMeasureInfiniteQueryError = ErrorResponse


export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—É –æ–¥–∏–Ω–∏—Ü—é –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */

export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedUnitOfMeasureInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedUnitOfMeasureQueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedUnitOfMeasureQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>> = ({ signal }) => getRecommendedUnitOfMeasure(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedUnitOfMeasureQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>
export type GetRecommendedUnitOfMeasureQueryError = ErrorResponse


export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—É –æ–¥–∏–Ω–∏—Ü—é –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */

export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedUnitOfMeasureQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const isUnitSupportedForItem = (
    params: IsUnitSupportedForItemParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/units-of-measure/check-support`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getIsUnitSupportedForItemQueryKey = (params: IsUnitSupportedForItemParams,) => {
    return [`/units-of-measure/check-support`, ...(params ? [params]: [])] as const;
    }

    
export const getIsUnitSupportedForItemInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsUnitSupportedForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isUnitSupportedForItem>>> = ({ signal }) => isUnitSupportedForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsUnitSupportedForItemInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof isUnitSupportedForItem>>>
export type IsUnitSupportedForItemInfiniteQueryError = ErrorResponse


export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */

export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsUnitSupportedForItemInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getIsUnitSupportedForItemQueryOptions = <TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsUnitSupportedForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isUnitSupportedForItem>>> = ({ signal }) => isUnitSupportedForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsUnitSupportedForItemQueryResult = NonNullable<Awaited<ReturnType<typeof isUnitSupportedForItem>>>
export type IsUnitSupportedForItemQueryError = ErrorResponse


export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */

export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsUnitSupportedForItemQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const getAvailableUnitsForCategory = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/units-of-measure/category/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAvailableUnitsForCategoryQueryKey = (categoryId: string,) => {
    return [`/units-of-measure/category/${categoryId}`] as const;
    }

    
export const getGetAvailableUnitsForCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsForCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>> = ({ signal }) => getAvailableUnitsForCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsForCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>
export type GetAvailableUnitsForCategoryInfiniteQueryError = ErrorResponse


export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsForCategoryInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableUnitsForCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsForCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>> = ({ signal }) => getAvailableUnitsForCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsForCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>
export type GetAvailableUnitsForCategoryQueryError = ErrorResponse


export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsForCategoryQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Ç–µ—Å—Ç–æ–≤–µ –ø—Ä–∏–≤—ñ—Ç–∞–Ω–Ω—è
 * @summary –¢–µ—Å—Ç–æ–≤–∏–π –µ–Ω–¥–ø–æ—ñ–Ω—Ç
 */
export const hello = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<TestResponse>(
      {url: `/test/hello`, method: 'GET', signal
    },
      options);
    }
  

export const getHelloQueryKey = () => {
    return [`/test/hello`] as const;
    }

    
export const getHelloInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof hello>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof hello>>> = ({ signal }) => hello(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HelloInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof hello>>>
export type HelloInfiniteQueryError = ErrorResponse


export function useHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof hello>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof hello>>,
          TError,
          Awaited<ReturnType<typeof hello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof hello>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof hello>>,
          TError,
          Awaited<ReturnType<typeof hello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof hello>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –¢–µ—Å—Ç–æ–≤–∏–π –µ–Ω–¥–ø–æ—ñ–Ω—Ç
 */

export function useHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof hello>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHelloInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getHelloQueryOptions = <TData = Awaited<ReturnType<typeof hello>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof hello>>> = ({ signal }) => hello(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HelloQueryResult = NonNullable<Awaited<ReturnType<typeof hello>>>
export type HelloQueryError = ErrorResponse


export function useHello<TData = Awaited<ReturnType<typeof hello>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof hello>>,
          TError,
          Awaited<ReturnType<typeof hello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHello<TData = Awaited<ReturnType<typeof hello>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof hello>>,
          TError,
          Awaited<ReturnType<typeof hello>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHello<TData = Awaited<ReturnType<typeof hello>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –¢–µ—Å—Ç–æ–≤–∏–π –µ–Ω–¥–ø–æ—ñ–Ω—Ç
 */

export function useHello<TData = Awaited<ReturnType<typeof hello>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hello>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHelloQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º –∫–æ–¥–æ–º
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –∫–æ–¥–æ–º
 */
export const getStainTypeByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetStainTypeByCode200>(
      {url: `/stain-types/by-code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStainTypeByCodeQueryKey = (code: string,) => {
    return [`/stain-types/by-code/${code}`] as const;
    }

    
export const getGetStainTypeByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeByCode>>> = ({ signal }) => getStainTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeByCode>>>
export type GetStainTypeByCodeInfiniteQueryError = ErrorResponse


export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypeByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeByCode>>> = ({ signal }) => getStainTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeByCode>>>
export type GetStainTypeByCodeQueryError = ErrorResponse


export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –ø—ñ–¥–ø–∏—Å –∫–ª—ñ—î–Ω—Ç–∞ –∑–∞ –π–æ–≥–æ ID
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—ñ–¥–ø–∏—Å –∑–∞ ID
 */
export const getSignatureById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CustomerSignatureResponse>(
      {url: `/signatures/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSignatureByIdQueryKey = (id: string,) => {
    return [`/signatures/${id}`] as const;
    }

    
export const getGetSignatureByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSignatureById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignatureByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignatureById>>> = ({ signal }) => getSignatureById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignatureByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSignatureById>>>
export type GetSignatureByIdInfiniteQueryError = ErrorResponse


export function useGetSignatureByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureById>>,
          TError,
          Awaited<ReturnType<typeof getSignatureById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureById>>,
          TError,
          Awaited<ReturnType<typeof getSignatureById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—ñ–¥–ø–∏—Å –∑–∞ ID
 */

export function useGetSignatureByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignatureByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSignatureByIdQueryOptions = <TData = Awaited<ReturnType<typeof getSignatureById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignatureByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignatureById>>> = ({ signal }) => getSignatureById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignatureByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSignatureById>>>
export type GetSignatureByIdQueryError = ErrorResponse


export function useGetSignatureById<TData = Awaited<ReturnType<typeof getSignatureById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureById>>,
          TError,
          Awaited<ReturnType<typeof getSignatureById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureById<TData = Awaited<ReturnType<typeof getSignatureById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureById>>,
          TError,
          Awaited<ReturnType<typeof getSignatureById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureById<TData = Awaited<ReturnType<typeof getSignatureById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—ñ–¥–ø–∏—Å –∑–∞ ID
 */

export function useGetSignatureById<TData = Awaited<ReturnType<typeof getSignatureById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignatureByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –≤—Å—ñ –ø—ñ–¥–ø–∏—Å–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –ø—ñ–¥–ø–∏—Å–∏ –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const getSignaturesByOrderId = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CustomerSignatureResponse[]>(
      {url: `/signatures/orders/${orderId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSignaturesByOrderIdQueryKey = (orderId: string,) => {
    return [`/signatures/orders/${orderId}`] as const;
    }

    
export const getGetSignaturesByOrderIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSignaturesByOrderId>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignaturesByOrderIdQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignaturesByOrderId>>> = ({ signal }) => getSignaturesByOrderId(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignaturesByOrderIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSignaturesByOrderId>>>
export type GetSignaturesByOrderIdInfiniteQueryError = ErrorResponse


export function useGetSignaturesByOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignaturesByOrderId>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignaturesByOrderId>>,
          TError,
          Awaited<ReturnType<typeof getSignaturesByOrderId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignaturesByOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignaturesByOrderId>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignaturesByOrderId>>,
          TError,
          Awaited<ReturnType<typeof getSignaturesByOrderId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignaturesByOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignaturesByOrderId>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –ø—ñ–¥–ø–∏—Å–∏ –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetSignaturesByOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignaturesByOrderId>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignaturesByOrderIdInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSignaturesByOrderIdQueryOptions = <TData = Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignaturesByOrderIdQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignaturesByOrderId>>> = ({ signal }) => getSignaturesByOrderId(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignaturesByOrderIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSignaturesByOrderId>>>
export type GetSignaturesByOrderIdQueryError = ErrorResponse


export function useGetSignaturesByOrderId<TData = Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignaturesByOrderId>>,
          TError,
          Awaited<ReturnType<typeof getSignaturesByOrderId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignaturesByOrderId<TData = Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignaturesByOrderId>>,
          TError,
          Awaited<ReturnType<typeof getSignaturesByOrderId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignaturesByOrderId<TData = Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –ø—ñ–¥–ø–∏—Å–∏ –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetSignaturesByOrderId<TData = Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignaturesByOrderId>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignaturesByOrderIdQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –ø—ñ–¥–ø–∏—Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø—É –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—ñ–¥–ø–∏—Å –∑–∞ —Ç–∏–ø–æ–º –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const getSignatureByOrderIdAndType = (
    orderId: string,
    signatureType: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CustomerSignatureResponse>(
      {url: `/signatures/orders/${orderId}/types/${signatureType}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSignatureByOrderIdAndTypeQueryKey = (orderId: string,
    signatureType: string,) => {
    return [`/signatures/orders/${orderId}/types/${signatureType}`] as const;
    }

    
export const getGetSignatureByOrderIdAndTypeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>, TError = ErrorResponse>(orderId: string,
    signatureType: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignatureByOrderIdAndTypeQueryKey(orderId,signatureType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>> = ({ signal }) => getSignatureByOrderIdAndType(orderId,signatureType, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId && signatureType),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignatureByOrderIdAndTypeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>
export type GetSignatureByOrderIdAndTypeInfiniteQueryError = ErrorResponse


export function useGetSignatureByOrderIdAndTypeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>,
          TError,
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByOrderIdAndTypeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>,
          TError,
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByOrderIdAndTypeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—ñ–¥–ø–∏—Å –∑–∞ —Ç–∏–ø–æ–º –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetSignatureByOrderIdAndTypeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignatureByOrderIdAndTypeInfiniteQueryOptions(orderId,signatureType,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSignatureByOrderIdAndTypeQueryOptions = <TData = Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError = ErrorResponse>(orderId: string,
    signatureType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSignatureByOrderIdAndTypeQueryKey(orderId,signatureType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>> = ({ signal }) => getSignatureByOrderIdAndType(orderId,signatureType, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId && signatureType),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSignatureByOrderIdAndTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>>
export type GetSignatureByOrderIdAndTypeQueryError = ErrorResponse


export function useGetSignatureByOrderIdAndType<TData = Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>,
          TError,
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByOrderIdAndType<TData = Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>,
          TError,
          Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSignatureByOrderIdAndType<TData = Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—ñ–¥–ø–∏—Å –∑–∞ —Ç–∏–ø–æ–º –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetSignatureByOrderIdAndType<TData = Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError = ErrorResponse>(
 orderId: string,
    signatureType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSignatureByOrderIdAndType>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSignatureByOrderIdAndTypeQueryOptions(orderId,signatureType,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –ø–æ—Å–ª—É–≥
 */
export const getAllActiveCategories = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAllActiveCategories200>(
      {url: `/service-categories`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllActiveCategoriesQueryKey = () => {
    return [`/service-categories`] as const;
    }

    
export const getGetAllActiveCategoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllActiveCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllActiveCategories>>> = ({ signal }) => getAllActiveCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllActiveCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllActiveCategories>>>
export type GetAllActiveCategoriesInfiniteQueryError = ErrorResponse


export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –ø–æ—Å–ª—É–≥
 */

export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllActiveCategoriesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllActiveCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllActiveCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllActiveCategories>>> = ({ signal }) => getAllActiveCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllActiveCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllActiveCategories>>>
export type GetAllActiveCategoriesQueryError = ErrorResponse


export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –ø–æ—Å–ª—É–≥
 */

export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllActiveCategoriesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ ID
 */
export const getCategoryById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryById200>(
      {url: `/service-categories/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByIdQueryKey = (id: string,) => {
    return [`/service-categories/${id}`] as const;
    }

    
export const getGetCategoryByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdInfiniteQueryError = ErrorResponse


export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ ID
 */

export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdQueryError = ErrorResponse


export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ ID
 */

export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */
export const getCategoryByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryByCode200>(
      {url: `/service-categories/code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByCodeQueryKey = (code: string,) => {
    return [`/service-categories/code/${code}`] as const;
    }

    
export const getGetCategoryByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode>>> = ({ signal }) => getCategoryByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode>>>
export type GetCategoryByCodeInfiniteQueryError = ErrorResponse


export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode>>> = ({ signal }) => getCategoryByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode>>>
export type GetCategoryByCodeQueryError = ErrorResponse


export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–≤–∞–Ω—ñ –¥–∞–Ω—ñ –¥–ª—è —Ñ–æ—Ä–º—É–≤–∞–Ω–Ω—è –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó –∑–∞ ID –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–∞–Ω—ñ –¥–ª—è –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */
export const getReceiptData = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ReceiptDTO>(
      {url: `/receipts/${orderId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetReceiptDataQueryKey = (orderId: string,) => {
    return [`/receipts/${orderId}`] as const;
    }

    
export const getGetReceiptDataInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getReceiptData>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReceiptDataQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReceiptData>>> = ({ signal }) => getReceiptData(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReceiptDataInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getReceiptData>>>
export type GetReceiptDataInfiniteQueryError = ErrorResponse


export function useGetReceiptDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReceiptData>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptData>>,
          TError,
          Awaited<ReturnType<typeof getReceiptData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReceiptData>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptData>>,
          TError,
          Awaited<ReturnType<typeof getReceiptData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReceiptData>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–∞–Ω—ñ –¥–ª—è –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */

export function useGetReceiptDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReceiptData>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReceiptDataInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetReceiptDataQueryOptions = <TData = Awaited<ReturnType<typeof getReceiptData>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReceiptDataQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReceiptData>>> = ({ signal }) => getReceiptData(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReceiptDataQueryResult = NonNullable<Awaited<ReturnType<typeof getReceiptData>>>
export type GetReceiptDataQueryError = ErrorResponse


export function useGetReceiptData<TData = Awaited<ReturnType<typeof getReceiptData>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptData>>,
          TError,
          Awaited<ReturnType<typeof getReceiptData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptData<TData = Awaited<ReturnType<typeof getReceiptData>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptData>>,
          TError,
          Awaited<ReturnType<typeof getReceiptData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptData<TData = Awaited<ReturnType<typeof getReceiptData>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–∞–Ω—ñ –¥–ª—è –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */

export function useGetReceiptData<TData = Awaited<ReturnType<typeof getReceiptData>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReceiptDataQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î PDF-–∫–≤–∏—Ç–∞–Ω—Ü—ñ—é –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è —è–∫ —Ñ–∞–π–ª
 * @summary –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ PDF-–∫–≤–∏—Ç–∞–Ω—Ü—ñ—é
 */
export const downloadPdfReceipt = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<DownloadPdfReceipt200>(
      {url: `/receipts/pdf/download/${orderId}`, method: 'GET', signal
    },
      options);
    }
  

export const getDownloadPdfReceiptQueryKey = (orderId: string,) => {
    return [`/receipts/pdf/download/${orderId}`] as const;
    }

    
export const getDownloadPdfReceiptInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof downloadPdfReceipt>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadPdfReceiptQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadPdfReceipt>>> = ({ signal }) => downloadPdfReceipt(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DownloadPdfReceiptInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof downloadPdfReceipt>>>
export type DownloadPdfReceiptInfiniteQueryError = ErrorResponse


export function useDownloadPdfReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof downloadPdfReceipt>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadPdfReceipt>>,
          TError,
          Awaited<ReturnType<typeof downloadPdfReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadPdfReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof downloadPdfReceipt>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadPdfReceipt>>,
          TError,
          Awaited<ReturnType<typeof downloadPdfReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadPdfReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof downloadPdfReceipt>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ PDF-–∫–≤–∏—Ç–∞–Ω—Ü—ñ—é
 */

export function useDownloadPdfReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof downloadPdfReceipt>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadPdfReceiptInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getDownloadPdfReceiptQueryOptions = <TData = Awaited<ReturnType<typeof downloadPdfReceipt>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadPdfReceiptQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadPdfReceipt>>> = ({ signal }) => downloadPdfReceipt(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DownloadPdfReceiptQueryResult = NonNullable<Awaited<ReturnType<typeof downloadPdfReceipt>>>
export type DownloadPdfReceiptQueryError = ErrorResponse


export function useDownloadPdfReceipt<TData = Awaited<ReturnType<typeof downloadPdfReceipt>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadPdfReceipt>>,
          TError,
          Awaited<ReturnType<typeof downloadPdfReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadPdfReceipt<TData = Awaited<ReturnType<typeof downloadPdfReceipt>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadPdfReceipt>>,
          TError,
          Awaited<ReturnType<typeof downloadPdfReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadPdfReceipt<TData = Awaited<ReturnType<typeof downloadPdfReceipt>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ PDF-–∫–≤–∏—Ç–∞–Ω—Ü—ñ—é
 */

export function useDownloadPdfReceipt<TData = Awaited<ReturnType<typeof downloadPdfReceipt>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPdfReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadPdfReceiptQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */
export const getModifiersForServiceCategory = (
    categoryCode: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersForServiceCategory200>(
      {url: `/price-modifiers/service-category/${categoryCode}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifiersForServiceCategoryQueryKey = (categoryCode: string,) => {
    return [`/price-modifiers/service-category/${categoryCode}`] as const;
    }

    
export const getGetModifiersForServiceCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersForServiceCategoryQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersForServiceCategory>>> = ({ signal }) => getModifiersForServiceCategory(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersForServiceCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>
export type GetModifiersForServiceCategoryInfiniteQueryError = ErrorResponse


export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */

export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersForServiceCategoryInfiniteQueryOptions(categoryCode,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifiersForServiceCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersForServiceCategoryQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersForServiceCategory>>> = ({ signal }) => getModifiersForServiceCategory(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersForServiceCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>
export type GetModifiersForServiceCategoryQueryError = ErrorResponse


export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */

export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersForServiceCategoryQueryOptions(categoryCode,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ –∫–æ–¥–æ–º
 */
export const getModifierByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifierByCode200>(
      {url: `/price-modifiers/code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifierByCodeQueryKey = (code: string,) => {
    return [`/price-modifiers/code/${code}`] as const;
    }

    
export const getGetModifierByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierByCode>>> = ({ signal }) => getModifierByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierByCode>>>
export type GetModifierByCodeInfiniteQueryError = ErrorResponse


export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifierByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierByCode>>> = ({ signal }) => getModifierByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierByCode>>>
export type GetModifierByCodeQueryError = ErrorResponse


export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */
export const getModifiersByCategory = (
    params: GetModifiersByCategoryParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersByCategory200>(
      {url: `/price-modifiers/category`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetModifiersByCategoryQueryKey = (params: GetModifiersByCategoryParams,) => {
    return [`/price-modifiers/category`, ...(params ? [params]: [])] as const;
    }

    
export const getGetModifiersByCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersByCategoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersByCategory>>> = ({ signal }) => getModifiersByCategory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersByCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCategory>>>
export type GetModifiersByCategoryInfiniteQueryError = ErrorResponse


export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersByCategoryInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifiersByCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersByCategoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersByCategory>>> = ({ signal }) => getModifiersByCategory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersByCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCategory>>>
export type GetModifiersByCategoryQueryError = ErrorResponse


export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersByCategoryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */
export const getAllCategories = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAllCategories200>(
      {url: `/price-list`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllCategoriesQueryKey = () => {
    return [`/price-list`] as const;
    }

    
export const getGetAllCategoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCategories>>> = ({ signal }) => getAllCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllCategories>>>
export type GetAllCategoriesInfiniteQueryError = ErrorResponse


export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */

export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllCategoriesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCategories>>> = ({ signal }) => getAllCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllCategories>>>
export type GetAllCategoriesQueryError = ErrorResponse


export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */

export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllCategoriesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 */
export const getCategoryById1 = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryById1200>(
      {url: `/price-list/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryById1QueryKey = (categoryId: string,) => {
    return [`/price-list/${categoryId}`] as const;
    }

    
export const getGetCategoryById1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryById1QueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById1>>> = ({ signal }) => getCategoryById1(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryById1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById1>>>
export type GetCategoryById1InfiniteQueryError = ErrorResponse


export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 */

export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryById1InfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryById1QueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryById1QueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById1>>> = ({ signal }) => getCategoryById1(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryById1QueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById1>>>
export type GetCategoryById1QueryError = ErrorResponse


export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 */

export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryById1QueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */
export const getCategoryByCode1 = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryByCode1200>(
      {url: `/price-list/category/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByCode1QueryKey = (code: string,) => {
    return [`/price-list/category/${code}`] as const;
    }

    
export const getGetCategoryByCode1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCode1QueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode1>>> = ({ signal }) => getCategoryByCode1(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCode1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode1>>>
export type GetCategoryByCode1InfiniteQueryError = ErrorResponse


export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCode1InfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByCode1QueryOptions = <TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCode1QueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode1>>> = ({ signal }) => getCategoryByCode1(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCode1QueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode1>>>
export type GetCategoryByCode1QueryError = ErrorResponse


export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCode1QueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const getAvailableUnitsOfMeasure = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAvailableUnitsOfMeasure200>(
      {url: `/price-list/category/${categoryId}/units-of-measure`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAvailableUnitsOfMeasureQueryKey = (categoryId: string,) => {
    return [`/price-list/category/${categoryId}/units-of-measure`] as const;
    }

    
export const getGetAvailableUnitsOfMeasureInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsOfMeasureQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>> = ({ signal }) => getAvailableUnitsOfMeasure(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsOfMeasureInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>
export type GetAvailableUnitsOfMeasureInfiniteQueryError = ErrorResponse


export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsOfMeasureInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableUnitsOfMeasureQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsOfMeasureQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>> = ({ signal }) => getAvailableUnitsOfMeasure(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsOfMeasureQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>
export type GetAvailableUnitsOfMeasureQueryError = ErrorResponse


export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsOfMeasureQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */
export const getItemsByCategory = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemsByCategory200>(
      {url: `/price-list/category/${categoryId}/items`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemsByCategoryQueryKey = (categoryId: string,) => {
    return [`/price-list/category/${categoryId}/items`] as const;
    }

    
export const getGetItemsByCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategory>>> = ({ signal }) => getItemsByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategory>>>
export type GetItemsByCategoryInfiniteQueryError = ErrorResponse


export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemsByCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategory>>> = ({ signal }) => getItemsByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategory>>>
export type GetItemsByCategoryQueryError = ErrorResponse


export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –Ω–∞–π–º–µ–Ω—É–≤–∞–Ω—å –≤–∏—Ä–æ–±—ñ–≤ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */
export const getItemNamesByCategory = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemNamesByCategory200>(
      {url: `/price-list/category/${categoryId}/item-names`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemNamesByCategoryQueryKey = (categoryId: string,) => {
    return [`/price-list/category/${categoryId}/item-names`] as const;
    }

    
export const getGetItemNamesByCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemNamesByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemNamesByCategory>>> = ({ signal }) => getItemNamesByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemNamesByCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemNamesByCategory>>>
export type GetItemNamesByCategoryInfiniteQueryError = ErrorResponse


export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –Ω–∞–π–º–µ–Ω—É–≤–∞–Ω—å –≤–∏—Ä–æ–±—ñ–≤ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemNamesByCategoryInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemNamesByCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemNamesByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemNamesByCategory>>> = ({ signal }) => getItemNamesByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemNamesByCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getItemNamesByCategory>>>
export type GetItemNamesByCategoryQueryError = ErrorResponse


export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –Ω–∞–π–º–µ–Ω—É–≤–∞–Ω—å –≤–∏—Ä–æ–±—ñ–≤ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemNamesByCategoryQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–æ–¥–æ–º –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const getItemsByCategoryCode = (
    categoryCode: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemsByCategoryCode200>(
      {url: `/price-list/category/code/${categoryCode}/items`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemsByCategoryCodeQueryKey = (categoryCode: string,) => {
    return [`/price-list/category/code/${categoryCode}/items`] as const;
    }

    
export const getGetItemsByCategoryCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryCodeQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategoryCode>>> = ({ signal }) => getItemsByCategoryCode(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategoryCode>>>
export type GetItemsByCategoryCodeInfiniteQueryError = ErrorResponse


export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–æ–¥–æ–º –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryCodeInfiniteQueryOptions(categoryCode,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemsByCategoryCodeQueryOptions = <TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryCodeQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategoryCode>>> = ({ signal }) => getItemsByCategoryCode(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategoryCode>>>
export type GetItemsByCategoryCodeQueryError = ErrorResponse


export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–æ–¥–æ–º –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryCodeQueryOptions(categoryCode,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω—å –ø—Ä–æ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –π–æ–≥–æ –ø–ª—è–º, –¥–µ—Ñ–µ–∫—Ç—ñ–≤, –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó —Ç–∞ –º–∞—Ç–µ—Ä—ñ–∞–ª—É
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ —Ä–∏–∑–∏–∫–∏
 */
export const getRiskWarnings = (
    params?: GetRiskWarningsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetRiskWarnings200>(
      {url: `/price-calculation/risk-warnings`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRiskWarningsQueryKey = (params?: GetRiskWarningsParams,) => {
    return [`/price-calculation/risk-warnings`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRiskWarningsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarnings>>>, TError = ErrorResponse>(params?: GetRiskWarningsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRiskWarningsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRiskWarnings>>> = ({ signal }) => getRiskWarnings(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRiskWarningsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRiskWarnings>>>
export type GetRiskWarningsInfiniteQueryError = ErrorResponse


export function useGetRiskWarningsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarnings>>>, TError = ErrorResponse>(
 params: undefined |  GetRiskWarningsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarnings>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarnings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarnings>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarnings>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarnings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarnings>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ —Ä–∏–∑–∏–∫–∏
 */

export function useGetRiskWarningsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarnings>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRiskWarningsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRiskWarningsQueryOptions = <TData = Awaited<ReturnType<typeof getRiskWarnings>>, TError = ErrorResponse>(params?: GetRiskWarningsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRiskWarningsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRiskWarnings>>> = ({ signal }) => getRiskWarnings(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRiskWarningsQueryResult = NonNullable<Awaited<ReturnType<typeof getRiskWarnings>>>
export type GetRiskWarningsQueryError = ErrorResponse


export function useGetRiskWarnings<TData = Awaited<ReturnType<typeof getRiskWarnings>>, TError = ErrorResponse>(
 params: undefined |  GetRiskWarningsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarnings>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarnings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarnings<TData = Awaited<ReturnType<typeof getRiskWarnings>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarnings>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarnings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarnings<TData = Awaited<ReturnType<typeof getRiskWarnings>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ —Ä–∏–∑–∏–∫–∏
 */

export function useGetRiskWarnings<TData = Awaited<ReturnType<typeof getRiskWarnings>>, TError = ErrorResponse>(
 params?: GetRiskWarningsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarnings>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRiskWarningsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –π–æ–≥–æ –ø–ª—è–º, –¥–µ—Ñ–µ–∫—Ç—ñ–≤, –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó —Ç–∞ –º–∞—Ç–µ—Ä—ñ–∞–ª—É
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–ª—è–º —Ç–∞ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */
export const getRecommendedModifiers = (
    params?: GetRecommendedModifiersParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetRecommendedModifiers200>(
      {url: `/price-calculation/recommended-modifiers`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedModifiersQueryKey = (params?: GetRecommendedModifiersParams,) => {
    return [`/price-calculation/recommended-modifiers`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedModifiersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers>>>, TError = ErrorResponse>(params?: GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiers>>> = ({ signal }) => getRecommendedModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiers>>>
export type GetRecommendedModifiersInfiniteQueryError = ErrorResponse


export function useGetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers>>>, TError = ErrorResponse>(
 params: undefined |  GetRecommendedModifiersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers>>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers>>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–ª—è–º —Ç–∞ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useGetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiers>>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedModifiersQueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedModifiers>>, TError = ErrorResponse>(params?: GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiers>>> = ({ signal }) => getRecommendedModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiers>>>
export type GetRecommendedModifiersQueryError = ErrorResponse


export function useGetRecommendedModifiers<TData = Awaited<ReturnType<typeof getRecommendedModifiers>>, TError = ErrorResponse>(
 params: undefined |  GetRecommendedModifiersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiers<TData = Awaited<ReturnType<typeof getRecommendedModifiers>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiers<TData = Awaited<ReturnType<typeof getRecommendedModifiers>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–ª—è–º —Ç–∞ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useGetRecommendedModifiers<TData = Awaited<ReturnType<typeof getRecommendedModifiers>>, TError = ErrorResponse>(
 params?: GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –ø–æ–≤–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ –π–æ–≥–æ –∫–æ–¥–æ–º
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ç–∞–ª—å–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä
 */
export const getModifierByCode1 = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifierByCode1200>(
      {url: `/price-calculation/modifiers/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifierByCode1QueryKey = (code: string,) => {
    return [`/price-calculation/modifiers/${code}`] as const;
    }

    
export const getGetModifierByCode1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode1>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByCode1QueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierByCode1>>> = ({ signal }) => getModifierByCode1(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByCode1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierByCode1>>>
export type GetModifierByCode1InfiniteQueryError = ErrorResponse


export function useGetModifierByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode1>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode1>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode1>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ç–∞–ª—å–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä
 */

export function useGetModifierByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByCode1InfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifierByCode1QueryOptions = <TData = Awaited<ReturnType<typeof getModifierByCode1>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByCode1QueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierByCode1>>> = ({ signal }) => getModifierByCode1(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByCode1QueryResult = NonNullable<Awaited<ReturnType<typeof getModifierByCode1>>>
export type GetModifierByCode1QueryError = ErrorResponse


export function useGetModifierByCode1<TData = Awaited<ReturnType<typeof getModifierByCode1>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode1>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode1<TData = Awaited<ReturnType<typeof getModifierByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode1>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode1<TData = Awaited<ReturnType<typeof getModifierByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ç–∞–ª—å–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä
 */

export function useGetModifierByCode1<TData = Awaited<ReturnType<typeof getModifierByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByCode1QueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∑–∞ —Ç–∏–ø–æ–º (–∑–∞–≥–∞–ª—å–Ω—ñ, —Ç–µ–∫—Å—Ç–∏–ª—å–Ω—ñ, —à–∫—ñ—Ä—è–Ω—ñ)
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∑–∞ —Ç–∏–ø–æ–º
 */
export const getModifiersByCategory1 = (
    category: 'GENERAL' | 'TEXTILE' | 'LEATHER',
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersByCategory1200>(
      {url: `/price-calculation/modifiers/by-type/${category}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifiersByCategory1QueryKey = (category: 'GENERAL' | 'TEXTILE' | 'LEATHER',) => {
    return [`/price-calculation/modifiers/by-type/${category}`] as const;
    }

    
export const getGetModifiersByCategory1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory1>>>, TError = ErrorResponse>(category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersByCategory1QueryKey(category);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersByCategory1>>> = ({ signal }) => getModifiersByCategory1(category, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(category),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersByCategory1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCategory1>>>
export type GetModifiersByCategory1InfiniteQueryError = ErrorResponse


export function useGetModifiersByCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory1>>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory1>>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory1>>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∑–∞ —Ç–∏–ø–æ–º
 */

export function useGetModifiersByCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory1>>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersByCategory1InfiniteQueryOptions(category,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifiersByCategory1QueryOptions = <TData = Awaited<ReturnType<typeof getModifiersByCategory1>>, TError = ErrorResponse>(category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersByCategory1QueryKey(category);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersByCategory1>>> = ({ signal }) => getModifiersByCategory1(category, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(category),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersByCategory1QueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCategory1>>>
export type GetModifiersByCategory1QueryError = ErrorResponse


export function useGetModifiersByCategory1<TData = Awaited<ReturnType<typeof getModifiersByCategory1>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory1<TData = Awaited<ReturnType<typeof getModifiersByCategory1>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory1<TData = Awaited<ReturnType<typeof getModifiersByCategory1>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∑–∞ —Ç–∏–ø–æ–º
 */

export function useGetModifiersByCategory1<TData = Awaited<ReturnType<typeof getModifiersByCategory1>>, TError = ErrorResponse>(
 category: 'GENERAL' | 'TEXTILE' | 'LEATHER', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersByCategory1QueryOptions(category,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –ø–æ–≤–Ω—ñ –¥–∞–Ω—ñ –ø—Ä–æ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –≤–∫–∞–∑–∞–Ω–æ—ó –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—ó –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */
export const getModifiersForServiceCategory1 = (
    categoryCode: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersForServiceCategory1200>(
      {url: `/price-calculation/modifiers/by-category/${categoryCode}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifiersForServiceCategory1QueryKey = (categoryCode: string,) => {
    return [`/price-calculation/modifiers/by-category/${categoryCode}`] as const;
    }

    
export const getGetModifiersForServiceCategory1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersForServiceCategory1QueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>> = ({ signal }) => getModifiersForServiceCategory1(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersForServiceCategory1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>
export type GetModifiersForServiceCategory1InfiniteQueryError = ErrorResponse


export function useGetModifiersForServiceCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—ó –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */

export function useGetModifiersForServiceCategory1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersForServiceCategory1InfiniteQueryOptions(categoryCode,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifiersForServiceCategory1QueryOptions = <TData = Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersForServiceCategory1QueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>> = ({ signal }) => getModifiersForServiceCategory1(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersForServiceCategory1QueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>>
export type GetModifiersForServiceCategory1QueryError = ErrorResponse


export function useGetModifiersForServiceCategory1<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory1<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory1<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—ó –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */

export function useGetModifiersForServiceCategory1<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersForServiceCategory1QueryOptions(categoryCode,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–∑–æ–≤—É —Ü—ñ–Ω—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—É –∑ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞
 */
export const getBasePrice = (
    params: GetBasePriceParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetBasePrice200>(
      {url: `/price-calculation/base-price`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetBasePriceQueryKey = (params: GetBasePriceParams,) => {
    return [`/price-calculation/base-price`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBasePriceInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getBasePrice>>>, TError = ErrorResponse>(params: GetBasePriceParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBasePriceQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBasePrice>>> = ({ signal }) => getBasePrice(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBasePriceInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getBasePrice>>>
export type GetBasePriceInfiniteQueryError = ErrorResponse


export function useGetBasePriceInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasePrice>>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasePrice>>,
          TError,
          Awaited<ReturnType<typeof getBasePrice>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasePriceInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasePrice>>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasePrice>>,
          TError,
          Awaited<ReturnType<typeof getBasePrice>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasePriceInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasePrice>>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–∑–æ–≤—É —Ü—ñ–Ω—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—É –∑ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞
 */

export function useGetBasePriceInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBasePrice>>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBasePriceInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBasePriceQueryOptions = <TData = Awaited<ReturnType<typeof getBasePrice>>, TError = ErrorResponse>(params: GetBasePriceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBasePriceQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBasePrice>>> = ({ signal }) => getBasePrice(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBasePriceQueryResult = NonNullable<Awaited<ReturnType<typeof getBasePrice>>>
export type GetBasePriceQueryError = ErrorResponse


export function useGetBasePrice<TData = Awaited<ReturnType<typeof getBasePrice>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasePrice>>,
          TError,
          Awaited<ReturnType<typeof getBasePrice>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasePrice<TData = Awaited<ReturnType<typeof getBasePrice>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBasePrice>>,
          TError,
          Awaited<ReturnType<typeof getBasePrice>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBasePrice<TData = Awaited<ReturnType<typeof getBasePrice>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–∑–æ–≤—É —Ü—ñ–Ω—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—É –∑ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞
 */

export function useGetBasePrice<TData = Awaited<ReturnType<typeof getBasePrice>>, TError = ErrorResponse>(
 params: GetBasePriceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasePrice>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBasePriceQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const getAvailableModifiersForCategory = (
    params: GetAvailableModifiersForCategoryParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAvailableModifiersForCategory200>(
      {url: `/price-calculation/available-modifiers`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAvailableModifiersForCategoryQueryKey = (params: GetAvailableModifiersForCategoryParams,) => {
    return [`/price-calculation/available-modifiers`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAvailableModifiersForCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>, TError = ErrorResponse>(params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableModifiersForCategoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>> = ({ signal }) => getAvailableModifiersForCategory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableModifiersForCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>
export type GetAvailableModifiersForCategoryInfiniteQueryError = ErrorResponse


export function useGetAvailableModifiersForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiersForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiersForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetAvailableModifiersForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableModifiersForCategoryInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableModifiersForCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError = ErrorResponse>(params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableModifiersForCategoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>> = ({ signal }) => getAvailableModifiersForCategory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableModifiersForCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>>
export type GetAvailableModifiersForCategoryQueryError = ErrorResponse


export function useGetAvailableModifiersForCategory<TData = Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiersForCategory<TData = Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableModifiersForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableModifiersForCategory<TData = Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetAvailableModifiersForCategory<TData = Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError = ErrorResponse>(
 params: GetAvailableModifiersForCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableModifiersForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableModifiersForCategoryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –¥–µ—Ç–∞–ª—å–Ω–∏–π –ø—ñ–¥—Å—É–º–æ–∫ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –∑ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫–æ–º –≤–∞—Ä—Ç–æ—Å—Ç—ñ –¥–ª—è –ø–µ—Ä–µ–≥–ª—è–¥—É —Ç–∞ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è. –í–∫–ª—é—á–∞—î —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫–ª—ñ—î–Ω—Ç–∞, —Å–ø–∏—Å–æ–∫ –ø—Ä–µ–¥–º–µ—Ç—ñ–≤ –∑ –¥–µ—Ç–∞–ª—ñ–∑–∞—Ü—ñ—î—é –≤–∞—Ä—Ç–æ—Å—Ç—ñ, –∑–∞–≥–∞–ª—å–Ω—ñ —Å—É–º–∏ —Ç–∞ –¥–∞—Ç–∏.
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ç–∞–ª—å–Ω–∏–π –ø—ñ–¥—Å—É–º–æ–∫ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const getOrderDetailedSummary = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDetailedSummaryResponse>(
      {url: `/orders/${orderId}/detailed-summary`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderDetailedSummaryQueryKey = (orderId: string,) => {
    return [`/orders/${orderId}/detailed-summary`] as const;
    }

    
export const getGetOrderDetailedSummaryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderDetailedSummary>>>, TError = ErrorResponse | void>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderDetailedSummaryQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderDetailedSummary>>> = ({ signal }) => getOrderDetailedSummary(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderDetailedSummaryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderDetailedSummary>>>
export type GetOrderDetailedSummaryInfiniteQueryError = ErrorResponse | void


export function useGetOrderDetailedSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDetailedSummary>>>, TError = ErrorResponse | void>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDetailedSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderDetailedSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDetailedSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDetailedSummary>>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDetailedSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderDetailedSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDetailedSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDetailedSummary>>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ç–∞–ª—å–Ω–∏–π –ø—ñ–¥—Å—É–º–æ–∫ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetOrderDetailedSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDetailedSummary>>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderDetailedSummaryInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderDetailedSummaryQueryOptions = <TData = Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError = ErrorResponse | void>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderDetailedSummaryQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderDetailedSummary>>> = ({ signal }) => getOrderDetailedSummary(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderDetailedSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderDetailedSummary>>>
export type GetOrderDetailedSummaryQueryError = ErrorResponse | void


export function useGetOrderDetailedSummary<TData = Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError = ErrorResponse | void>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDetailedSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderDetailedSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDetailedSummary<TData = Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDetailedSummary>>,
          TError,
          Awaited<ReturnType<typeof getOrderDetailedSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDetailedSummary<TData = Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ç–∞–ª—å–Ω–∏–π –ø—ñ–¥—Å—É–º–æ–∫ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetOrderDetailedSummary<TData = Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError = ErrorResponse | void>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDetailedSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderDetailedSummaryQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –∑–∞ –π–æ–≥–æ ID
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –∑–∞ ID
 */
export const getOrderById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO>(
      {url: `/orders/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderByIdQueryKey = (id: string,) => {
    return [`/orders/${id}`] as const;
    }

    
export const getGetOrderByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({ signal }) => getOrderById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderById>>>
export type GetOrderByIdInfiniteQueryError = ErrorResponse


export function useGetOrderByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –∑–∞ ID
 */

export function useGetOrderByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderByIdQueryOptions = <TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({ signal }) => getOrderById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderById>>>
export type GetOrderByIdQueryError = ErrorResponse


export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –∑–∞ ID
 */

export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î PDF-—Ñ–∞–π–ª –∑ —á–µ–∫–æ–º –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ PDF-—á–µ–∫ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const getOrderReceipt = (
    orderId: string,
    params?: GetOrderReceiptParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetOrderReceipt200>(
      {url: `/orders/finalization/${orderId}/receipt`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetOrderReceiptQueryKey = (orderId: string,
    params?: GetOrderReceiptParams,) => {
    return [`/orders/finalization/${orderId}/receipt`, ...(params ? [params]: [])] as const;
    }

    
export const getGetOrderReceiptInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderReceipt>>>, TError = ErrorResponse>(orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderReceiptQueryKey(orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderReceipt>>> = ({ signal }) => getOrderReceipt(orderId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderReceiptInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderReceipt>>>
export type GetOrderReceiptInfiniteQueryError = ErrorResponse


export function useGetOrderReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderReceipt>>>, TError = ErrorResponse>(
 orderId: string,
    params: undefined |  GetOrderReceiptParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderReceipt>>,
          TError,
          Awaited<ReturnType<typeof getOrderReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderReceipt>>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderReceipt>>,
          TError,
          Awaited<ReturnType<typeof getOrderReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderReceipt>>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ PDF-—á–µ–∫ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetOrderReceiptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderReceipt>>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderReceiptInfiniteQueryOptions(orderId,params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderReceiptQueryOptions = <TData = Awaited<ReturnType<typeof getOrderReceipt>>, TError = ErrorResponse>(orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderReceiptQueryKey(orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderReceipt>>> = ({ signal }) => getOrderReceipt(orderId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderReceiptQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderReceipt>>>
export type GetOrderReceiptQueryError = ErrorResponse


export function useGetOrderReceipt<TData = Awaited<ReturnType<typeof getOrderReceipt>>, TError = ErrorResponse>(
 orderId: string,
    params: undefined |  GetOrderReceiptParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderReceipt>>,
          TError,
          Awaited<ReturnType<typeof getOrderReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderReceipt<TData = Awaited<ReturnType<typeof getOrderReceipt>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderReceipt>>,
          TError,
          Awaited<ReturnType<typeof getOrderReceipt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderReceipt<TData = Awaited<ReturnType<typeof getOrderReceipt>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ PDF-—á–µ–∫ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetOrderReceipt<TData = Awaited<ReturnType<typeof getOrderReceipt>>, TError = ErrorResponse>(
 orderId: string,
    params?: GetOrderReceiptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderReceipt>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderReceiptQueryOptions(orderId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ —á–µ—Ä–Ω–µ—Ç–æ–∫ –∑–∞–º–æ–≤–ª–µ–Ω—å
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —á–µ—Ä–Ω–µ—Ç–∫–∏ –∑–∞–º–æ–≤–ª–µ–Ω—å
 */
export const getDraftOrders = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO[]>(
      {url: `/orders/drafts`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDraftOrdersQueryKey = () => {
    return [`/orders/drafts`] as const;
    }

    
export const getGetDraftOrdersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDraftOrders>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDraftOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDraftOrders>>> = ({ signal }) => getDraftOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDraftOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDraftOrders>>>
export type GetDraftOrdersInfiniteQueryError = ErrorResponse


export function useGetDraftOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDraftOrders>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftOrders>>,
          TError,
          Awaited<ReturnType<typeof getDraftOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDraftOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDraftOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftOrders>>,
          TError,
          Awaited<ReturnType<typeof getDraftOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDraftOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDraftOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —á–µ—Ä–Ω–µ—Ç–∫–∏ –∑–∞–º–æ–≤–ª–µ–Ω—å
 */

export function useGetDraftOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDraftOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDraftOrdersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDraftOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getDraftOrders>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDraftOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDraftOrders>>> = ({ signal }) => getDraftOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDraftOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getDraftOrders>>>
export type GetDraftOrdersQueryError = ErrorResponse


export function useGetDraftOrders<TData = Awaited<ReturnType<typeof getDraftOrders>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftOrders>>,
          TError,
          Awaited<ReturnType<typeof getDraftOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDraftOrders<TData = Awaited<ReturnType<typeof getDraftOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftOrders>>,
          TError,
          Awaited<ReturnType<typeof getDraftOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDraftOrders<TData = Awaited<ReturnType<typeof getDraftOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —á–µ—Ä–Ω–µ—Ç–∫–∏ –∑–∞–º–æ–≤–ª–µ–Ω—å
 */

export function useGetDraftOrders<TData = Awaited<ReturnType<typeof getDraftOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDraftOrdersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –¥–µ—Ç–∞–ª—å–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∑–Ω–∏–∂–∫—É –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∑–Ω–∏–∂–∫—É
 */
export const getOrderDiscount = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetOrderDiscount200>(
      {url: `/orders/discounts/${orderId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetOrderDiscountQueryKey = (orderId: string,) => {
    return [`/orders/discounts/${orderId}`] as const;
    }

    
export const getGetOrderDiscountInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOrderDiscount>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderDiscountQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderDiscount>>> = ({ signal }) => getOrderDiscount(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderDiscountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderDiscount>>>
export type GetOrderDiscountInfiniteQueryError = ErrorResponse


export function useGetOrderDiscountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDiscount>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDiscount>>,
          TError,
          Awaited<ReturnType<typeof getOrderDiscount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDiscountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDiscount>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDiscount>>,
          TError,
          Awaited<ReturnType<typeof getOrderDiscount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDiscountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDiscount>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∑–Ω–∏–∂–∫—É
 */

export function useGetOrderDiscountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOrderDiscount>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderDiscountInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOrderDiscountQueryOptions = <TData = Awaited<ReturnType<typeof getOrderDiscount>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderDiscountQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderDiscount>>> = ({ signal }) => getOrderDiscount(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderDiscountQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderDiscount>>>
export type GetOrderDiscountQueryError = ErrorResponse


export function useGetOrderDiscount<TData = Awaited<ReturnType<typeof getOrderDiscount>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDiscount>>,
          TError,
          Awaited<ReturnType<typeof getOrderDiscount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDiscount<TData = Awaited<ReturnType<typeof getOrderDiscount>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderDiscount>>,
          TError,
          Awaited<ReturnType<typeof getOrderDiscount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderDiscount<TData = Awaited<ReturnType<typeof getOrderDiscount>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∑–Ω–∏–∂–∫—É
 */

export function useGetOrderDiscount<TData = Awaited<ReturnType<typeof getOrderDiscount>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderDiscount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderDiscountQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –í–∏–¥–∞–ª—è—î –∑–Ω–∏–∂–∫—É –∑ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–Ω–∏–∂–∫—É
 */
export const removeDiscount = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<RemoveDiscount200>(
      {url: `/orders/discounts/${orderId}`, method: 'DELETE'
    },
      options);
    }
  


export const getRemoveDiscountMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeDiscount>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof removeDiscount>>, TError,{orderId: string}, TContext> => {

const mutationKey = ['removeDiscount'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeDiscount>>, {orderId: string}> = (props) => {
          const {orderId} = props ?? {};

          return  removeDiscount(orderId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveDiscountMutationResult = NonNullable<Awaited<ReturnType<typeof removeDiscount>>>
    
    export type RemoveDiscountMutationError = ErrorResponse

    /**
 * @summary –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–Ω–∏–∂–∫—É
 */
export const useRemoveDiscount = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeDiscount>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeDiscount>>,
        TError,
        {orderId: string},
        TContext
      > => {

      const mutationOptions = getRemoveDiscountMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω–∏—Ö –∑–∞–º–æ–≤–ª–µ–Ω—å
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∞–∫—Ç–∏–≤–Ω—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const getActiveOrders = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderDTO[]>(
      {url: `/orders/active`, method: 'GET', signal
    },
      options);
    }
  

export const getGetActiveOrdersQueryKey = () => {
    return [`/orders/active`] as const;
    }

    
export const getGetActiveOrdersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getActiveOrders>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveOrders>>> = ({ signal }) => getActiveOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveOrders>>>
export type GetActiveOrdersInfiniteQueryError = ErrorResponse


export function useGetActiveOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveOrders>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveOrders>>,
          TError,
          Awaited<ReturnType<typeof getActiveOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveOrders>>,
          TError,
          Awaited<ReturnType<typeof getActiveOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∞–∫—Ç–∏–≤–Ω—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetActiveOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveOrders>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActiveOrdersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActiveOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getActiveOrders>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveOrders>>> = ({ signal }) => getActiveOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveOrders>>>
export type GetActiveOrdersQueryError = ErrorResponse


export function useGetActiveOrders<TData = Awaited<ReturnType<typeof getActiveOrders>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveOrders>>,
          TError,
          Awaited<ReturnType<typeof getActiveOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveOrders<TData = Awaited<ReturnType<typeof getActiveOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveOrders>>,
          TError,
          Awaited<ReturnType<typeof getActiveOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveOrders<TData = Awaited<ReturnType<typeof getActiveOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∞–∫—Ç–∏–≤–Ω—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useGetActiveOrders<TData = Awaited<ReturnType<typeof getActiveOrders>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveOrders>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActiveOrdersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û—Ç—Ä–∏–º—É—î —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é –ø—Ä–µ–¥–º–µ—Ç–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é –∑–∞ ID
 */
export const getPhotoById = (
    itemId: string,
    photoId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderItemPhotoDTO>(
      {url: `/order-items/${itemId}/photos/${photoId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPhotoByIdQueryKey = (itemId: string,
    photoId: string,) => {
    return [`/order-items/${itemId}/photos/${photoId}`] as const;
    }

    
export const getGetPhotoByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPhotoById>>>, TError = ErrorResponse>(itemId: string,
    photoId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhotoByIdQueryKey(itemId,photoId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotoById>>> = ({ signal }) => getPhotoById(itemId,photoId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId && photoId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPhotoByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotoById>>>
export type GetPhotoByIdInfiniteQueryError = ErrorResponse


export function useGetPhotoByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotoById>>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotoById>>,
          TError,
          Awaited<ReturnType<typeof getPhotoById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotoByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotoById>>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotoById>>,
          TError,
          Awaited<ReturnType<typeof getPhotoById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotoByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotoById>>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é –∑–∞ ID
 */

export function useGetPhotoByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPhotoById>>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPhotoByIdInfiniteQueryOptions(itemId,photoId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPhotoByIdQueryOptions = <TData = Awaited<ReturnType<typeof getPhotoById>>, TError = ErrorResponse>(itemId: string,
    photoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhotoByIdQueryKey(itemId,photoId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotoById>>> = ({ signal }) => getPhotoById(itemId,photoId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId && photoId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPhotoByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotoById>>>
export type GetPhotoByIdQueryError = ErrorResponse


export function useGetPhotoById<TData = Awaited<ReturnType<typeof getPhotoById>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotoById>>,
          TError,
          Awaited<ReturnType<typeof getPhotoById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotoById<TData = Awaited<ReturnType<typeof getPhotoById>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotoById>>,
          TError,
          Awaited<ReturnType<typeof getPhotoById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotoById<TData = Awaited<ReturnType<typeof getPhotoById>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é –∑–∞ ID
 */

export function useGetPhotoById<TData = Awaited<ReturnType<typeof getPhotoById>>, TError = ErrorResponse>(
 itemId: string,
    photoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPhotoByIdQueryOptions(itemId,photoId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –í–∏–¥–∞–ª—è—î –≤–∫–∞–∑–∞–Ω—É —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é –ø—Ä–µ–¥–º–µ—Ç–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é
 */
export const deletePhoto = (
    itemId: string,
    photoId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeletePhoto204>(
      {url: `/order-items/${itemId}/photos/${photoId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeletePhotoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePhoto>>, TError,{itemId: string;photoId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePhoto>>, TError,{itemId: string;photoId: string}, TContext> => {

const mutationKey = ['deletePhoto'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePhoto>>, {itemId: string;photoId: string}> = (props) => {
          const {itemId,photoId} = props ?? {};

          return  deletePhoto(itemId,photoId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePhotoMutationResult = NonNullable<Awaited<ReturnType<typeof deletePhoto>>>
    
    export type DeletePhotoMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é
 */
export const useDeletePhoto = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePhoto>>, TError,{itemId: string;photoId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePhoto>>,
        TError,
        {itemId: string;photoId: string},
        TContext
      > => {

      const mutationOptions = getDeletePhotoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤ —Ü—ñ–Ω –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤–∫–∞–∑–∞–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –ø–ª—è–º, –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó —Ç–∞ –º–∞—Ç–µ—Ä—ñ–∞–ª—É
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–ª—è–º
 */
export const getRecommendedModifiersForStains = (
    params: GetRecommendedModifiersForStainsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ModifierRecommendationDTO[]>(
      {url: `/modifier-recommendations/stains`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedModifiersForStainsQueryKey = (params: GetRecommendedModifiersForStainsParams,) => {
    return [`/modifier-recommendations/stains`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedModifiersForStainsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForStainsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>> = ({ signal }) => getRecommendedModifiersForStains(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForStainsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>
export type GetRecommendedModifiersForStainsInfiniteQueryError = ErrorResponse


export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–ª—è–º
 */

export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForStainsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedModifiersForStainsQueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForStainsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>> = ({ signal }) => getRecommendedModifiersForStains(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForStainsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>
export type GetRecommendedModifiersForStainsQueryError = ErrorResponse


export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–ª—è–º
 */

export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForStainsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω—å –ø—Ä–æ —Ä–∏–∑–∏–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤–∫–∞–∑–∞–Ω–∏—Ö –ø–ª—è–º, –¥–µ—Ñ–µ–∫—Ç—ñ–≤, –º–∞—Ç–µ—Ä—ñ–∞–ª—É —Ç–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ —Ä–∏–∑–∏–∫–∏
 */
export const getRiskWarningsForItem = (
    params?: GetRiskWarningsForItemParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/modifier-recommendations/risks`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRiskWarningsForItemQueryKey = (params?: GetRiskWarningsForItemParams,) => {
    return [`/modifier-recommendations/risks`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRiskWarningsForItemInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRiskWarningsForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRiskWarningsForItem>>> = ({ signal }) => getRiskWarningsForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRiskWarningsForItemInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRiskWarningsForItem>>>
export type GetRiskWarningsForItemInfiniteQueryError = ErrorResponse


export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params: undefined |  GetRiskWarningsForItemParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ —Ä–∏–∑–∏–∫–∏
 */

export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRiskWarningsForItemInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRiskWarningsForItemQueryOptions = <TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRiskWarningsForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRiskWarningsForItem>>> = ({ signal }) => getRiskWarningsForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRiskWarningsForItemQueryResult = NonNullable<Awaited<ReturnType<typeof getRiskWarningsForItem>>>
export type GetRiskWarningsForItemQueryError = ErrorResponse


export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params: undefined |  GetRiskWarningsForItemParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ —Ä–∏–∑–∏–∫–∏
 */

export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRiskWarningsForItemQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤ —Ü—ñ–Ω –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤–∫–∞–∑–∞–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –¥–µ—Ñ–µ–∫—Ç—ñ–≤, –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó —Ç–∞ –º–∞—Ç–µ—Ä—ñ–∞–ª—É
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */
export const getRecommendedModifiersForDefects = (
    params: GetRecommendedModifiersForDefectsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ModifierRecommendationDTO[]>(
      {url: `/modifier-recommendations/defects`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedModifiersForDefectsQueryKey = (params: GetRecommendedModifiersForDefectsParams,) => {
    return [`/modifier-recommendations/defects`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedModifiersForDefectsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForDefectsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>> = ({ signal }) => getRecommendedModifiersForDefects(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForDefectsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>
export type GetRecommendedModifiersForDefectsInfiniteQueryError = ErrorResponse


export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForDefectsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedModifiersForDefectsQueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForDefectsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>> = ({ signal }) => getRecommendedModifiersForDefects(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForDefectsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>
export type GetRecommendedModifiersForDefectsQueryError = ErrorResponse


export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForDefectsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç—É–ø–µ–Ω—ñ –∑–Ω–æ—Å—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getWearDegrees = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/wear-degrees`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWearDegreesQueryKey = () => {
    return [`/item-characteristics/wear-degrees`] as const;
    }

    
export const getGetWearDegreesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWearDegreesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWearDegrees>>> = ({ signal }) => getWearDegrees(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWearDegreesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWearDegrees>>>
export type GetWearDegreesInfiniteQueryError = ErrorResponse


export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç—É–ø–µ–Ω—ñ –∑–Ω–æ—Å—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWearDegreesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWearDegreesQueryOptions = <TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWearDegreesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWearDegrees>>> = ({ signal }) => getWearDegrees(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWearDegreesQueryResult = NonNullable<Awaited<ReturnType<typeof getWearDegrees>>>
export type GetWearDegreesQueryError = ErrorResponse


export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç—É–ø–µ–Ω—ñ –∑–Ω–æ—Å—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWearDegreesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getStainTypes1 = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/stain-types`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStainTypes1QueryKey = () => {
    return [`/item-characteristics/stain-types`] as const;
    }

    
export const getGetStainTypes1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypes1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes1>>> = ({ signal }) => getStainTypes1(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypes1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes1>>>
export type GetStainTypes1InfiniteQueryError = ErrorResponse


export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypes1InfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypes1QueryOptions = <TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypes1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes1>>> = ({ signal }) => getStainTypes1(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypes1QueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes1>>>
export type GetStainTypes1QueryError = ErrorResponse


export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypes1QueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getRisks = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/risks`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRisksQueryKey = () => {
    return [`/item-characteristics/risks`] as const;
    }

    
export const getGetRisksInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRisks>>> = ({ signal }) => getRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRisksInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRisks>>>
export type GetRisksInfiniteQueryError = ErrorResponse


export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRisksInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRisksQueryOptions = <TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRisks>>> = ({ signal }) => getRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRisksQueryResult = NonNullable<Awaited<ReturnType<typeof getRisks>>>
export type GetRisksQueryError = ErrorResponse


export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRisksQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –º–∞—Ç–µ—Ä—ñ–∞–ª–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getMaterials = (
    params?: GetMaterialsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/materials`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetMaterialsQueryKey = (params?: GetMaterialsParams,) => {
    return [`/item-characteristics/materials`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMaterialsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterials>>> = ({ signal }) => getMaterials(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMaterialsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterials>>>
export type GetMaterialsInfiniteQueryError = ErrorResponse


export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params: undefined |  GetMaterialsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –º–∞—Ç–µ—Ä—ñ–∞–ª–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMaterialsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialsQueryOptions = <TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterials>>> = ({ signal }) => getMaterials(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMaterialsQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterials>>>
export type GetMaterialsQueryError = ErrorResponse


export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params: undefined |  GetMaterialsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –º–∞—Ç–µ—Ä—ñ–∞–ª–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMaterialsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –Ω–∞–ø–æ–≤–Ω—é–≤–∞—á—ñ–≤ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getFillerTypes = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/filler-types`, method: 'GET', signal
    },
      options);
    }
  

export const getGetFillerTypesQueryKey = () => {
    return [`/item-characteristics/filler-types`] as const;
    }

    
export const getGetFillerTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFillerTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFillerTypes>>> = ({ signal }) => getFillerTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFillerTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFillerTypes>>>
export type GetFillerTypesInfiniteQueryError = ErrorResponse


export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –Ω–∞–ø–æ–≤–Ω—é–≤–∞—á—ñ–≤ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFillerTypesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFillerTypesQueryOptions = <TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFillerTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFillerTypes>>> = ({ signal }) => getFillerTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFillerTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getFillerTypes>>>
export type GetFillerTypesQueryError = ErrorResponse


export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –Ω–∞–ø–æ–≤–Ω—é–≤–∞—á—ñ–≤ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFillerTypesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ –¥–µ—Ñ–µ–∫—Ç–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getDefects = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/defects`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectsQueryKey = () => {
    return [`/item-characteristics/defects`] as const;
    }

    
export const getGetDefectsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefects>>> = ({ signal }) => getDefects(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefects>>>
export type GetDefectsInfiniteQueryError = ErrorResponse


export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ –¥–µ—Ñ–µ–∫—Ç–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectsQueryOptions = <TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefects>>> = ({ signal }) => getDefects(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsQueryResult = NonNullable<Awaited<ReturnType<typeof getDefects>>>
export type GetDefectsQueryError = ErrorResponse


export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ –¥–µ—Ñ–µ–∫—Ç–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ñ–µ–∫—Ç–∏ —Ç–∞ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getDefectsAndRisks = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/defects-and-risks`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectsAndRisksQueryKey = () => {
    return [`/item-characteristics/defects-and-risks`] as const;
    }

    
export const getGetDefectsAndRisksInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsAndRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectsAndRisks>>> = ({ signal }) => getDefectsAndRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsAndRisksInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectsAndRisks>>>
export type GetDefectsAndRisksInfiniteQueryError = ErrorResponse


export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ñ–µ–∫—Ç–∏ —Ç–∞ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsAndRisksInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectsAndRisksQueryOptions = <TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsAndRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectsAndRisks>>> = ({ signal }) => getDefectsAndRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsAndRisksQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectsAndRisks>>>
export type GetDefectsAndRisksQueryError = ErrorResponse


export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ñ–µ–∫—Ç–∏ —Ç–∞ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsAndRisksQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–∑–æ–≤—ñ –∫–æ–ª—å–æ—Ä–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getColors = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/colors`, method: 'GET', signal
    },
      options);
    }
  

export const getGetColorsQueryKey = () => {
    return [`/item-characteristics/colors`] as const;
    }

    
export const getGetColorsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetColorsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getColors>>> = ({ signal }) => getColors(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetColorsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getColors>>>
export type GetColorsInfiniteQueryError = ErrorResponse


export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–∑–æ–≤—ñ –∫–æ–ª—å–æ—Ä–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetColorsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetColorsQueryOptions = <TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetColorsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getColors>>> = ({ signal }) => getColors(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetColorsQueryResult = NonNullable<Awaited<ReturnType<typeof getColors>>>
export type GetColorsQueryError = ErrorResponse


export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–∑–æ–≤—ñ –∫–æ–ª—å–æ—Ä–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetColorsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º –∫–æ–¥–æ–º
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –∫–æ–¥–æ–º
 */
export const getDefectTypeByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetDefectTypeByCode200>(
      {url: `/defect-types/by-code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectTypeByCodeQueryKey = (code: string,) => {
    return [`/defect-types/by-code/${code}`] as const;
    }

    
export const getGetDefectTypeByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeByCode>>> = ({ signal }) => getDefectTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeByCode>>>
export type GetDefectTypeByCodeInfiniteQueryError = ErrorResponse


export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectTypeByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeByCode>>> = ({ signal }) => getDefectTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeByCode>>>
export type GetDefectTypeByCodeQueryError = ErrorResponse


export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤ –∑–∞ –∫–ª—é—á–æ–≤–∏–º —Å–ª–æ–≤–æ–º
 * @deprecated
 * @summary –ü–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤
 */
export const searchClients = (
    params: SearchClientsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/clients/search`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSearchClientsQueryKey = (params: SearchClientsParams,) => {
    return [`/clients/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchClientsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof searchClients>>>, TError = ErrorResponse>(params: SearchClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchClientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchClients>>> = ({ signal }) => searchClients(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchClientsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchClients>>>
export type SearchClientsInfiniteQueryError = ErrorResponse


export function useSearchClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchClients>>>, TError = ErrorResponse>(
 params: SearchClientsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchClients>>,
          TError,
          Awaited<ReturnType<typeof searchClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchClients>>>, TError = ErrorResponse>(
 params: SearchClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchClients>>,
          TError,
          Awaited<ReturnType<typeof searchClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchClients>>>, TError = ErrorResponse>(
 params: SearchClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @deprecated
 * @summary –ü–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤
 */

export function useSearchClientsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchClients>>>, TError = ErrorResponse>(
 params: SearchClientsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchClientsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSearchClientsQueryOptions = <TData = Awaited<ReturnType<typeof searchClients>>, TError = ErrorResponse>(params: SearchClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchClientsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchClients>>> = ({ signal }) => searchClients(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchClientsQueryResult = NonNullable<Awaited<ReturnType<typeof searchClients>>>
export type SearchClientsQueryError = ErrorResponse


export function useSearchClients<TData = Awaited<ReturnType<typeof searchClients>>, TError = ErrorResponse>(
 params: SearchClientsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchClients>>,
          TError,
          Awaited<ReturnType<typeof searchClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchClients<TData = Awaited<ReturnType<typeof searchClients>>, TError = ErrorResponse>(
 params: SearchClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchClients>>,
          TError,
          Awaited<ReturnType<typeof searchClients>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchClients<TData = Awaited<ReturnType<typeof searchClients>>, TError = ErrorResponse>(
 params: SearchClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @deprecated
 * @summary –ü–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤
 */

export function useSearchClients<TData = Awaited<ReturnType<typeof searchClients>>, TError = ErrorResponse>(
 params: SearchClientsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchClients>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchClientsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º –∫–æ–¥–æ–º
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É –∑–∞ –∫–æ–¥–æ–º
 */
export const getBranchLocationByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<BranchLocationDTO>(
      {url: `/branch-locations/code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetBranchLocationByCodeQueryKey = (code: string,) => {
    return [`/branch-locations/code/${code}`] as const;
    }

    
export const getGetBranchLocationByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchLocationByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranchLocationByCode>>> = ({ signal }) => getBranchLocationByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBranchLocationByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getBranchLocationByCode>>>
export type GetBranchLocationByCodeInfiniteQueryError = ErrorResponse


export function useGetBranchLocationByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationByCode>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationByCode>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetBranchLocationByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getBranchLocationByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBranchLocationByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetBranchLocationByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getBranchLocationByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchLocationByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranchLocationByCode>>> = ({ signal }) => getBranchLocationByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBranchLocationByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getBranchLocationByCode>>>
export type GetBranchLocationByCodeQueryError = ErrorResponse


export function useGetBranchLocationByCode<TData = Awaited<ReturnType<typeof getBranchLocationByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationByCode>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByCode<TData = Awaited<ReturnType<typeof getBranchLocationByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranchLocationByCode>>,
          TError,
          Awaited<ReturnType<typeof getBranchLocationByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranchLocationByCode<TData = Awaited<ReturnType<typeof getBranchLocationByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—É–Ω–∫—Ç –ø—Ä–∏–π–æ–º—É –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetBranchLocationByCode<TData = Awaited<ReturnType<typeof getBranchLocationByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranchLocationByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBranchLocationByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –¢–µ—Å—Ç–æ–≤–∏–π –µ–Ω–¥–ø–æ—ñ–Ω—Ç –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ API –∞—É—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—ó
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ
 */
export const testAuthEndpoint = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/auth/test`, method: 'GET', signal
    },
      options);
    }
  

export const getTestAuthEndpointQueryKey = () => {
    return [`/auth/test`] as const;
    }

    
export const getTestAuthEndpointInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof testAuthEndpoint>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTestAuthEndpointQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof testAuthEndpoint>>> = ({ signal }) => testAuthEndpoint(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TestAuthEndpointInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof testAuthEndpoint>>>
export type TestAuthEndpointInfiniteQueryError = ErrorResponse


export function useTestAuthEndpointInfinite<TData = InfiniteData<Awaited<ReturnType<typeof testAuthEndpoint>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof testAuthEndpoint>>,
          TError,
          Awaited<ReturnType<typeof testAuthEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestAuthEndpointInfinite<TData = InfiniteData<Awaited<ReturnType<typeof testAuthEndpoint>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof testAuthEndpoint>>,
          TError,
          Awaited<ReturnType<typeof testAuthEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestAuthEndpointInfinite<TData = InfiniteData<Awaited<ReturnType<typeof testAuthEndpoint>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ
 */

export function useTestAuthEndpointInfinite<TData = InfiniteData<Awaited<ReturnType<typeof testAuthEndpoint>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTestAuthEndpointInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getTestAuthEndpointQueryOptions = <TData = Awaited<ReturnType<typeof testAuthEndpoint>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTestAuthEndpointQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof testAuthEndpoint>>> = ({ signal }) => testAuthEndpoint(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TestAuthEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof testAuthEndpoint>>>
export type TestAuthEndpointQueryError = ErrorResponse


export function useTestAuthEndpoint<TData = Awaited<ReturnType<typeof testAuthEndpoint>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof testAuthEndpoint>>,
          TError,
          Awaited<ReturnType<typeof testAuthEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestAuthEndpoint<TData = Awaited<ReturnType<typeof testAuthEndpoint>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof testAuthEndpoint>>,
          TError,
          Awaited<ReturnType<typeof testAuthEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestAuthEndpoint<TData = Awaited<ReturnType<typeof testAuthEndpoint>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ
 */

export function useTestAuthEndpoint<TData = Awaited<ReturnType<typeof testAuthEndpoint>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testAuthEndpoint>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTestAuthEndpointQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω wizard —Ç–∞ –≤—Å—ñ –∑–±–µ—Ä–µ–∂–µ–Ω—ñ –¥–∞–Ω—ñ
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç–∞–Ω Order Wizard
 */
export const getWizardState = (
    wizardId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardDataResponse>(
      {url: `/api/order-wizard/${wizardId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWizardStateQueryKey = (wizardId: string,) => {
    return [`/api/order-wizard/${wizardId}/state`] as const;
    }

    
export const getGetWizardStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getWizardState>>>, TError = ErrorResponse>(wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWizardStateQueryKey(wizardId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWizardState>>> = ({ signal }) => getWizardState(wizardId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(wizardId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWizardStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWizardState>>>
export type GetWizardStateInfiniteQueryError = ErrorResponse


export function useGetWizardStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWizardState>>>, TError = ErrorResponse>(
 wizardId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWizardState>>,
          TError,
          Awaited<ReturnType<typeof getWizardState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWizardStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWizardState>>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWizardState>>,
          TError,
          Awaited<ReturnType<typeof getWizardState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWizardStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWizardState>>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç–∞–Ω Order Wizard
 */

export function useGetWizardStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWizardState>>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWizardStateInfiniteQueryOptions(wizardId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWizardStateQueryOptions = <TData = Awaited<ReturnType<typeof getWizardState>>, TError = ErrorResponse>(wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWizardStateQueryKey(wizardId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWizardState>>> = ({ signal }) => getWizardState(wizardId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(wizardId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWizardStateQueryResult = NonNullable<Awaited<ReturnType<typeof getWizardState>>>
export type GetWizardStateQueryError = ErrorResponse


export function useGetWizardState<TData = Awaited<ReturnType<typeof getWizardState>>, TError = ErrorResponse>(
 wizardId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWizardState>>,
          TError,
          Awaited<ReturnType<typeof getWizardState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWizardState<TData = Awaited<ReturnType<typeof getWizardState>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWizardState>>,
          TError,
          Awaited<ReturnType<typeof getWizardState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWizardState<TData = Awaited<ReturnType<typeof getWizardState>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç–∞–Ω Order Wizard
 */

export function useGetWizardState<TData = Awaited<ReturnType<typeof getWizardState>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWizardState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWizardStateQueryOptions(wizardId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –¥—ñ–π –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É wizard
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –¥—ñ—ó –¥–ª—è Order Wizard
 */
export const getAvailableActions = (
    wizardId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAvailableActions200>(
      {url: `/api/order-wizard/${wizardId}/actions`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAvailableActionsQueryKey = (wizardId: string,) => {
    return [`/api/order-wizard/${wizardId}/actions`] as const;
    }

    
export const getGetAvailableActionsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableActions>>>, TError = ErrorResponse>(wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableActionsQueryKey(wizardId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableActions>>> = ({ signal }) => getAvailableActions(wizardId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(wizardId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableActionsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableActions>>>
export type GetAvailableActionsInfiniteQueryError = ErrorResponse


export function useGetAvailableActionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableActions>>>, TError = ErrorResponse>(
 wizardId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableActions>>,
          TError,
          Awaited<ReturnType<typeof getAvailableActions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableActionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableActions>>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableActions>>,
          TError,
          Awaited<ReturnType<typeof getAvailableActions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableActionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableActions>>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –¥—ñ—ó –¥–ª—è Order Wizard
 */

export function useGetAvailableActionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableActions>>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableActionsInfiniteQueryOptions(wizardId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableActionsQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableActions>>, TError = ErrorResponse>(wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableActionsQueryKey(wizardId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableActions>>> = ({ signal }) => getAvailableActions(wizardId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(wizardId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableActionsQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableActions>>>
export type GetAvailableActionsQueryError = ErrorResponse


export function useGetAvailableActions<TData = Awaited<ReturnType<typeof getAvailableActions>>, TError = ErrorResponse>(
 wizardId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableActions>>,
          TError,
          Awaited<ReturnType<typeof getAvailableActions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableActions<TData = Awaited<ReturnType<typeof getAvailableActions>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableActions>>,
          TError,
          Awaited<ReturnType<typeof getAvailableActions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableActions<TData = Awaited<ReturnType<typeof getAvailableActions>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –¥—ñ—ó –¥–ª—è Order Wizard
 */

export function useGetAvailableActions<TData = Awaited<ReturnType<typeof getAvailableActions>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableActionsQueryOptions(wizardId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getStage1Data = (
    wizardId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetStage1Data200>(
      {url: `/api/order-wizard/stage1/${wizardId}/data`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStage1DataQueryKey = (wizardId: string,) => {
    return [`/api/order-wizard/stage1/${wizardId}/data`] as const;
    }

    
export const getGetStage1DataInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStage1Data>>>, TError = ErrorResponse>(wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStage1DataQueryKey(wizardId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStage1Data>>> = ({ signal }) => getStage1Data(wizardId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(wizardId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStage1DataInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStage1Data>>>
export type GetStage1DataInfiniteQueryError = ErrorResponse


export function useGetStage1DataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStage1Data>>>, TError = ErrorResponse>(
 wizardId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStage1Data>>,
          TError,
          Awaited<ReturnType<typeof getStage1Data>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStage1DataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStage1Data>>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStage1Data>>,
          TError,
          Awaited<ReturnType<typeof getStage1Data>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStage1DataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStage1Data>>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetStage1DataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStage1Data>>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStage1DataInfiniteQueryOptions(wizardId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStage1DataQueryOptions = <TData = Awaited<ReturnType<typeof getStage1Data>>, TError = ErrorResponse>(wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStage1DataQueryKey(wizardId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStage1Data>>> = ({ signal }) => getStage1Data(wizardId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(wizardId),  staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStage1DataQueryResult = NonNullable<Awaited<ReturnType<typeof getStage1Data>>>
export type GetStage1DataQueryError = ErrorResponse


export function useGetStage1Data<TData = Awaited<ReturnType<typeof getStage1Data>>, TError = ErrorResponse>(
 wizardId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStage1Data>>,
          TError,
          Awaited<ReturnType<typeof getStage1Data>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStage1Data<TData = Awaited<ReturnType<typeof getStage1Data>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStage1Data>>,
          TError,
          Awaited<ReturnType<typeof getStage1Data>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStage1Data<TData = Awaited<ReturnType<typeof getStage1Data>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetStage1Data<TData = Awaited<ReturnType<typeof getStage1Data>>, TError = ErrorResponse>(
 wizardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStage1Data>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStage1DataQueryOptions(wizardId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î –ø–æ–≤–Ω–∏–π —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –¥—ñ–π, —è–∫—ñ –º–æ–∂—É—Ç—å –±—É—Ç–∏ –≤–∏–∫–æ–Ω–∞–Ω—ñ –≤ wizard
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –º–æ–∂–ª–∏–≤—ñ –¥—ñ—ó Order Wizard
 */
export const getAllAvailableActions = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAllAvailableActions200>(
      {url: `/api/order-wizard/available-actions`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllAvailableActionsQueryKey = () => {
    return [`/api/order-wizard/available-actions`] as const;
    }

    
export const getGetAllAvailableActionsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllAvailableActions>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllAvailableActionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllAvailableActions>>> = ({ signal }) => getAllAvailableActions(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllAvailableActionsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllAvailableActions>>>
export type GetAllAvailableActionsInfiniteQueryError = ErrorResponse


export function useGetAllAvailableActionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllAvailableActions>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAvailableActions>>,
          TError,
          Awaited<ReturnType<typeof getAllAvailableActions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAvailableActionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllAvailableActions>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAvailableActions>>,
          TError,
          Awaited<ReturnType<typeof getAllAvailableActions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAvailableActionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllAvailableActions>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –º–æ–∂–ª–∏–≤—ñ –¥—ñ—ó Order Wizard
 */

export function useGetAllAvailableActionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllAvailableActions>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllAvailableActionsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllAvailableActionsQueryOptions = <TData = Awaited<ReturnType<typeof getAllAvailableActions>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllAvailableActionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllAvailableActions>>> = ({ signal }) => getAllAvailableActions(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllAvailableActionsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllAvailableActions>>>
export type GetAllAvailableActionsQueryError = ErrorResponse


export function useGetAllAvailableActions<TData = Awaited<ReturnType<typeof getAllAvailableActions>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAvailableActions>>,
          TError,
          Awaited<ReturnType<typeof getAllAvailableActions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAvailableActions<TData = Awaited<ReturnType<typeof getAllAvailableActions>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAvailableActions>>,
          TError,
          Awaited<ReturnType<typeof getAllAvailableActions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAvailableActions<TData = Awaited<ReturnType<typeof getAllAvailableActions>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –º–æ–∂–ª–∏–≤—ñ –¥—ñ—ó Order Wizard
 */

export function useGetAllAvailableActions<TData = Awaited<ReturnType<typeof getAllAvailableActions>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAvailableActions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllAvailableActionsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getActiveWizards = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetActiveWizards200>(
      {url: `/api/order-wizard/active`, method: 'GET', signal
    },
      options);
    }
  

export const getGetActiveWizardsQueryKey = () => {
    return [`/api/order-wizard/active`] as const;
    }

    
export const getGetActiveWizardsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getActiveWizards>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveWizardsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveWizards>>> = ({ signal }) => getActiveWizards(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveWizardsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveWizards>>>
export type GetActiveWizardsInfiniteQueryError = ErrorResponse


export function useGetActiveWizardsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveWizards>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveWizards>>,
          TError,
          Awaited<ReturnType<typeof getActiveWizards>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveWizardsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveWizards>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveWizards>>,
          TError,
          Awaited<ReturnType<typeof getActiveWizards>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveWizardsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveWizards>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetActiveWizardsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActiveWizards>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActiveWizardsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActiveWizardsQueryOptions = <TData = Awaited<ReturnType<typeof getActiveWizards>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveWizardsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveWizards>>> = ({ signal }) => getActiveWizards(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveWizardsQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveWizards>>>
export type GetActiveWizardsQueryError = ErrorResponse


export function useGetActiveWizards<TData = Awaited<ReturnType<typeof getActiveWizards>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveWizards>>,
          TError,
          Awaited<ReturnType<typeof getActiveWizards>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveWizards<TData = Awaited<ReturnType<typeof getActiveWizards>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveWizards>>,
          TError,
          Awaited<ReturnType<typeof getActiveWizards>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveWizards<TData = Awaited<ReturnType<typeof getActiveWizards>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetActiveWizards<TData = Awaited<ReturnType<typeof getActiveWizards>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveWizards>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActiveWizardsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const healthCheck = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<HealthCheck200>(
      {url: `/api/health`, method: 'GET', signal
    },
      options);
    }
  

export const getHealthCheckQueryKey = () => {
    return [`/api/health`] as const;
    }

    
export const getHealthCheckInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckInfiniteQueryError = ErrorResponse


export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthCheck>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckQueryError = ErrorResponse


export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ping = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/api/health/ping`, method: 'GET', signal
    },
      options);
    }
  

export const getPingQueryKey = () => {
    return [`/api/health/ping`] as const;
    }

    
export const getPingInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof ping>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPingQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ping>>> = ({ signal }) => ping(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PingInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof ping>>>
export type PingInfiniteQueryError = ErrorResponse


export function usePingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof ping>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ping>>,
          TError,
          Awaited<ReturnType<typeof ping>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof ping>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ping>>,
          TError,
          Awaited<ReturnType<typeof ping>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof ping>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof ping>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPingInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getPingQueryOptions = <TData = Awaited<ReturnType<typeof ping>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPingQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ping>>> = ({ signal }) => ping(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, gcTime: 600000, refetchOnWindowFocus: false, refetchOnReconnect: true,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PingQueryResult = NonNullable<Awaited<ReturnType<typeof ping>>>
export type PingQueryError = ErrorResponse


export function usePing<TData = Awaited<ReturnType<typeof ping>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ping>>,
          TError,
          Awaited<ReturnType<typeof ping>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePing<TData = Awaited<ReturnType<typeof ping>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ping>>,
          TError,
          Awaited<ReturnType<typeof ping>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePing<TData = Awaited<ReturnType<typeof ping>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePing<TData = Awaited<ReturnType<typeof ping>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPingQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°–∫–∞—Å–æ–≤—É—î –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 * @summary –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const cancelOrder = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<CancelOrder204>(
      {url: `/orders/${id}/cancel`, method: 'DELETE'
    },
      options);
    }
  


export const getCancelOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelOrder>>, TError,{id: string}, TContext> => {

const mutationKey = ['cancelOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelOrder>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  cancelOrder(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelOrderMutationResult = NonNullable<Awaited<ReturnType<typeof cancelOrder>>>
    
    export type CancelOrderMutationError = ErrorResponse

    /**
 * @summary –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useCancelOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelOrder>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelOrder>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getCancelOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const cancelWizard = (
    wizardId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<CancelWizard200>(
      {url: `/api/order-wizard/${wizardId}`, method: 'DELETE'
    },
      options);
    }
  


export const getCancelWizardMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelWizard>>, TError,{wizardId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelWizard>>, TError,{wizardId: string}, TContext> => {

const mutationKey = ['cancelWizard'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelWizard>>, {wizardId: string}> = (props) => {
          const {wizardId} = props ?? {};

          return  cancelWizard(wizardId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelWizardMutationResult = NonNullable<Awaited<ReturnType<typeof cancelWizard>>>
    
    export type CancelWizardMutationError = ErrorResponse

    export const useCancelWizard = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelWizard>>, TError,{wizardId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelWizard>>,
        TError,
        {wizardId: string},
        TContext
      > => {

      const mutationOptions = getCancelWizardMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
