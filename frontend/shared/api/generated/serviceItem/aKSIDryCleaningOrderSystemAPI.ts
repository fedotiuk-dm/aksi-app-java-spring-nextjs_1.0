/**
 * Generated by orval v7.11.1 üç∫
 * Do not edit manually.
 * AKSI Dry Cleaning Order System API
 * API for dry cleaning order management system with Domain-Driven Design architecture. The system includes 13 domains: Auth, User, Customer, Branch, Employee, Order, OrderItem, Service, Garment, Pricing, Payment, Notification, and Analytics.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateItemInfoRequest,
  CreateServiceInfoRequest,
  CreateServiceItemInfoRequest,
  ErrorResponse,
  GetServiceItemByIdParams,
  ItemInfo,
  ListItemsParams,
  ListItemsResponse,
  ListServiceItemsParams,
  ListServiceItemsResponse,
  ListServicesParams,
  ListServicesResponse,
  ServiceInfo,
  ServiceItemInfo,
  UpdateItemInfoRequest,
  UpdateServiceInfoRequest,
  UpdateServiceItemInfoRequest
} from './aKSIDryCleaningOrderSystemAPI.schemas';

import orvalFetcher from '../../../../lib/api/orval-fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get list of available services
 * @summary List services
 */
export const listServices = (
    params?: ListServicesParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ListServicesResponse>(
      {url: `/api/services`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListServicesQueryKey = (params?: ListServicesParams,) => {
    return [`/api/services`, ...(params ? [params]: [])] as const;
    }

    
export const getListServicesQueryOptions = <TData = Awaited<ReturnType<typeof listServices>>, TError = ErrorResponse>(params?: ListServicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServices>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServicesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServices>>> = ({ signal }) => listServices(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServices>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListServicesQueryResult = NonNullable<Awaited<ReturnType<typeof listServices>>>
export type ListServicesQueryError = ErrorResponse


export function useListServices<TData = Awaited<ReturnType<typeof listServices>>, TError = ErrorResponse>(
 params: undefined |  ListServicesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServices>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listServices>>,
          TError,
          Awaited<ReturnType<typeof listServices>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListServices<TData = Awaited<ReturnType<typeof listServices>>, TError = ErrorResponse>(
 params?: ListServicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServices>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listServices>>,
          TError,
          Awaited<ReturnType<typeof listServices>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListServices<TData = Awaited<ReturnType<typeof listServices>>, TError = ErrorResponse>(
 params?: ListServicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServices>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List services
 */

export function useListServices<TData = Awaited<ReturnType<typeof listServices>>, TError = ErrorResponse>(
 params?: ListServicesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServices>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListServicesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create new service type
 * @summary Create service
 */
export const createService = (
    createServiceInfoRequest: CreateServiceInfoRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ServiceInfo>(
      {url: `/api/services`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createServiceInfoRequest, signal
    },
      options);
    }
  


export const getCreateServiceMutationOptions = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: CreateServiceInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: CreateServiceInfoRequest}, TContext> => {

const mutationKey = ['createService'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createService>>, {data: CreateServiceInfoRequest}> = (props) => {
          const {data} = props ?? {};

          return  createService(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceMutationResult = NonNullable<Awaited<ReturnType<typeof createService>>>
    export type CreateServiceMutationBody = CreateServiceInfoRequest
    export type CreateServiceMutationError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse

    /**
 * @summary Create service
 */
export const useCreateService = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: CreateServiceInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createService>>,
        TError,
        {data: CreateServiceInfoRequest},
        TContext
      > => {

      const mutationOptions = getCreateServiceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get available service-item combinations with pricing
 * @summary List service-item combinations
 */
export const listServiceItems = (
    params?: ListServiceItemsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ListServiceItemsResponse>(
      {url: `/api/service-items`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListServiceItemsQueryKey = (params?: ListServiceItemsParams,) => {
    return [`/api/service-items`, ...(params ? [params]: [])] as const;
    }

    
export const getListServiceItemsQueryOptions = <TData = Awaited<ReturnType<typeof listServiceItems>>, TError = ErrorResponse | ErrorResponse>(params?: ListServiceItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServiceItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceItemsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceItems>>> = ({ signal }) => listServiceItems(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListServiceItemsQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceItems>>>
export type ListServiceItemsQueryError = ErrorResponse | ErrorResponse


export function useListServiceItems<TData = Awaited<ReturnType<typeof listServiceItems>>, TError = ErrorResponse | ErrorResponse>(
 params: undefined |  ListServiceItemsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServiceItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listServiceItems>>,
          TError,
          Awaited<ReturnType<typeof listServiceItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListServiceItems<TData = Awaited<ReturnType<typeof listServiceItems>>, TError = ErrorResponse | ErrorResponse>(
 params?: ListServiceItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServiceItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listServiceItems>>,
          TError,
          Awaited<ReturnType<typeof listServiceItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListServiceItems<TData = Awaited<ReturnType<typeof listServiceItems>>, TError = ErrorResponse | ErrorResponse>(
 params?: ListServiceItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServiceItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List service-item combinations
 */

export function useListServiceItems<TData = Awaited<ReturnType<typeof listServiceItems>>, TError = ErrorResponse | ErrorResponse>(
 params?: ListServiceItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServiceItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListServiceItemsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create new service-item combination with base pricing
 * @summary Create service-item combination
 */
export const createServiceItem = (
    createServiceItemInfoRequest: CreateServiceItemInfoRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ServiceItemInfo>(
      {url: `/api/service-items`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createServiceItemInfoRequest, signal
    },
      options);
    }
  


export const getCreateServiceItemMutationOptions = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceItem>>, TError,{data: CreateServiceItemInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createServiceItem>>, TError,{data: CreateServiceItemInfoRequest}, TContext> => {

const mutationKey = ['createServiceItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createServiceItem>>, {data: CreateServiceItemInfoRequest}> = (props) => {
          const {data} = props ?? {};

          return  createServiceItem(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceItemMutationResult = NonNullable<Awaited<ReturnType<typeof createServiceItem>>>
    export type CreateServiceItemMutationBody = CreateServiceItemInfoRequest
    export type CreateServiceItemMutationError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse

    /**
 * @summary Create service-item combination
 */
export const useCreateServiceItem = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceItem>>, TError,{data: CreateServiceItemInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createServiceItem>>,
        TError,
        {data: CreateServiceItemInfoRequest},
        TContext
      > => {

      const mutationOptions = getCreateServiceItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get list of available item types
 * @summary List items
 */
export const listItems = (
    params?: ListItemsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ListItemsResponse>(
      {url: `/api/items`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListItemsQueryKey = (params?: ListItemsParams,) => {
    return [`/api/items`, ...(params ? [params]: [])] as const;
    }

    
export const getListItemsQueryOptions = <TData = Awaited<ReturnType<typeof listItems>>, TError = ErrorResponse>(params?: ListItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListItemsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listItems>>> = ({ signal }) => listItems(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListItemsQueryResult = NonNullable<Awaited<ReturnType<typeof listItems>>>
export type ListItemsQueryError = ErrorResponse


export function useListItems<TData = Awaited<ReturnType<typeof listItems>>, TError = ErrorResponse>(
 params: undefined |  ListItemsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listItems>>,
          TError,
          Awaited<ReturnType<typeof listItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListItems<TData = Awaited<ReturnType<typeof listItems>>, TError = ErrorResponse>(
 params?: ListItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listItems>>,
          TError,
          Awaited<ReturnType<typeof listItems>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListItems<TData = Awaited<ReturnType<typeof listItems>>, TError = ErrorResponse>(
 params?: ListItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List items
 */

export function useListItems<TData = Awaited<ReturnType<typeof listItems>>, TError = ErrorResponse>(
 params?: ListItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listItems>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListItemsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create new item type
 * @summary Create item
 */
export const createItem = (
    createItemInfoRequest: CreateItemInfoRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemInfo>(
      {url: `/api/items`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createItemInfoRequest, signal
    },
      options);
    }
  


export const getCreateItemMutationOptions = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createItem>>, TError,{data: CreateItemInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createItem>>, TError,{data: CreateItemInfoRequest}, TContext> => {

const mutationKey = ['createItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createItem>>, {data: CreateItemInfoRequest}> = (props) => {
          const {data} = props ?? {};

          return  createItem(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateItemMutationResult = NonNullable<Awaited<ReturnType<typeof createItem>>>
    export type CreateItemMutationBody = CreateItemInfoRequest
    export type CreateItemMutationError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse

    /**
 * @summary Create item
 */
export const useCreateItem = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createItem>>, TError,{data: CreateItemInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createItem>>,
        TError,
        {data: CreateItemInfoRequest},
        TContext
      > => {

      const mutationOptions = getCreateItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get detailed service information
 * @summary Get service details
 */
export const getServiceById = (
    serviceId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ServiceInfo>(
      {url: `/api/services/${serviceId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetServiceByIdQueryKey = (serviceId?: string,) => {
    return [`/api/services/${serviceId}`] as const;
    }

    
export const getGetServiceByIdQueryOptions = <TData = Awaited<ReturnType<typeof getServiceById>>, TError = ErrorResponse | ErrorResponse>(serviceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceByIdQueryKey(serviceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceById>>> = ({ signal }) => getServiceById(serviceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetServiceByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceById>>>
export type GetServiceByIdQueryError = ErrorResponse | ErrorResponse


export function useGetServiceById<TData = Awaited<ReturnType<typeof getServiceById>>, TError = ErrorResponse | ErrorResponse>(
 serviceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceById>>,
          TError,
          Awaited<ReturnType<typeof getServiceById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetServiceById<TData = Awaited<ReturnType<typeof getServiceById>>, TError = ErrorResponse | ErrorResponse>(
 serviceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceById>>,
          TError,
          Awaited<ReturnType<typeof getServiceById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetServiceById<TData = Awaited<ReturnType<typeof getServiceById>>, TError = ErrorResponse | ErrorResponse>(
 serviceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get service details
 */

export function useGetServiceById<TData = Awaited<ReturnType<typeof getServiceById>>, TError = ErrorResponse | ErrorResponse>(
 serviceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetServiceByIdQueryOptions(serviceId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update service information
 * @summary Update service
 */
export const updateService = (
    serviceId: string,
    updateServiceInfoRequest: UpdateServiceInfoRequest,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ServiceInfo>(
      {url: `/api/services/${serviceId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateServiceInfoRequest
    },
      options);
    }
  


export const getUpdateServiceMutationOptions = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateService>>, TError,{serviceId: string;data: UpdateServiceInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateService>>, TError,{serviceId: string;data: UpdateServiceInfoRequest}, TContext> => {

const mutationKey = ['updateService'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateService>>, {serviceId: string;data: UpdateServiceInfoRequest}> = (props) => {
          const {serviceId,data} = props ?? {};

          return  updateService(serviceId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceMutationResult = NonNullable<Awaited<ReturnType<typeof updateService>>>
    export type UpdateServiceMutationBody = UpdateServiceInfoRequest
    export type UpdateServiceMutationError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse

    /**
 * @summary Update service
 */
export const useUpdateService = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateService>>, TError,{serviceId: string;data: UpdateServiceInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateService>>,
        TError,
        {serviceId: string;data: UpdateServiceInfoRequest},
        TContext
      > => {

      const mutationOptions = getUpdateServiceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get detailed service-item combination
 * @summary Get service-item details
 */
export const getServiceItemById = (
    serviceItemId: string,
    params?: GetServiceItemByIdParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ServiceItemInfo>(
      {url: `/api/service-items/${serviceItemId}`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetServiceItemByIdQueryKey = (serviceItemId?: string,
    params?: GetServiceItemByIdParams,) => {
    return [`/api/service-items/${serviceItemId}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetServiceItemByIdQueryOptions = <TData = Awaited<ReturnType<typeof getServiceItemById>>, TError = ErrorResponse | ErrorResponse>(serviceItemId: string,
    params?: GetServiceItemByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceItemByIdQueryKey(serviceItemId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceItemById>>> = ({ signal }) => getServiceItemById(serviceItemId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceItemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceItemById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetServiceItemByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceItemById>>>
export type GetServiceItemByIdQueryError = ErrorResponse | ErrorResponse


export function useGetServiceItemById<TData = Awaited<ReturnType<typeof getServiceItemById>>, TError = ErrorResponse | ErrorResponse>(
 serviceItemId: string,
    params: undefined |  GetServiceItemByIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceItemById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceItemById>>,
          TError,
          Awaited<ReturnType<typeof getServiceItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetServiceItemById<TData = Awaited<ReturnType<typeof getServiceItemById>>, TError = ErrorResponse | ErrorResponse>(
 serviceItemId: string,
    params?: GetServiceItemByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceItemById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceItemById>>,
          TError,
          Awaited<ReturnType<typeof getServiceItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetServiceItemById<TData = Awaited<ReturnType<typeof getServiceItemById>>, TError = ErrorResponse | ErrorResponse>(
 serviceItemId: string,
    params?: GetServiceItemByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get service-item details
 */

export function useGetServiceItemById<TData = Awaited<ReturnType<typeof getServiceItemById>>, TError = ErrorResponse | ErrorResponse>(
 serviceItemId: string,
    params?: GetServiceItemByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetServiceItemByIdQueryOptions(serviceItemId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update service-item combination
 * @summary Update service-item
 */
export const updateServiceItem = (
    serviceItemId: string,
    updateServiceItemInfoRequest: UpdateServiceItemInfoRequest,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ServiceItemInfo>(
      {url: `/api/service-items/${serviceItemId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateServiceItemInfoRequest
    },
      options);
    }
  


export const getUpdateServiceItemMutationOptions = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceItem>>, TError,{serviceItemId: string;data: UpdateServiceItemInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateServiceItem>>, TError,{serviceItemId: string;data: UpdateServiceItemInfoRequest}, TContext> => {

const mutationKey = ['updateServiceItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceItem>>, {serviceItemId: string;data: UpdateServiceItemInfoRequest}> = (props) => {
          const {serviceItemId,data} = props ?? {};

          return  updateServiceItem(serviceItemId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceItemMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceItem>>>
    export type UpdateServiceItemMutationBody = UpdateServiceItemInfoRequest
    export type UpdateServiceItemMutationError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse

    /**
 * @summary Update service-item
 */
export const useUpdateServiceItem = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceItem>>, TError,{serviceItemId: string;data: UpdateServiceItemInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateServiceItem>>,
        TError,
        {serviceItemId: string;data: UpdateServiceItemInfoRequest},
        TContext
      > => {

      const mutationOptions = getUpdateServiceItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get detailed item information
 * @summary Get item details
 */
export const getItemById = (
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemInfo>(
      {url: `/api/items/${itemId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemByIdQueryKey = (itemId?: string,) => {
    return [`/api/items/${itemId}`] as const;
    }

    
export const getGetItemByIdQueryOptions = <TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse | ErrorResponse>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemByIdQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemById>>> = ({ signal }) => getItemById(itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getItemById>>>
export type GetItemByIdQueryError = ErrorResponse | ErrorResponse


export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse | ErrorResponse>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse | ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse | ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get item details
 */

export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse | ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemByIdQueryOptions(itemId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update item information
 * @summary Update item
 */
export const updateItem = (
    itemId: string,
    updateItemInfoRequest: UpdateItemInfoRequest,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ItemInfo>(
      {url: `/api/items/${itemId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateItemInfoRequest
    },
      options);
    }
  


export const getUpdateItemMutationOptions = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateItem>>, TError,{itemId: string;data: UpdateItemInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateItem>>, TError,{itemId: string;data: UpdateItemInfoRequest}, TContext> => {

const mutationKey = ['updateItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateItem>>, {itemId: string;data: UpdateItemInfoRequest}> = (props) => {
          const {itemId,data} = props ?? {};

          return  updateItem(itemId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateItemMutationResult = NonNullable<Awaited<ReturnType<typeof updateItem>>>
    export type UpdateItemMutationBody = UpdateItemInfoRequest
    export type UpdateItemMutationError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse

    /**
 * @summary Update item
 */
export const useUpdateItem = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateItem>>, TError,{itemId: string;data: UpdateItemInfoRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateItem>>,
        TError,
        {itemId: string;data: UpdateItemInfoRequest},
        TContext
      > => {

      const mutationOptions = getUpdateItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
