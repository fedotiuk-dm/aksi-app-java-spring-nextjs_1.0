/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * AKSI API
 * API –¥–ª—è —Å–∏—Å—Ç–µ–º–∏ –∫–µ—Ä—É–≤–∞–Ω–Ω—è –∫–ª—ñ–Ω—ñ–Ω–≥–æ–≤–æ—é –∫–æ–º–ø–∞–Ω—ñ—î—é AKSI
 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateCategory200,
  CreateModifier200,
  CreatePriceListItem200,
  CreateStainType200,
  DeactivateModifier200,
  DefectTypeDTO,
  DeleteStainType200,
  ErrorResponse,
  GetAllActiveCategories200,
  GetAllCategories200,
  GetAllModifiers200,
  GetAvailableUnitsOfMeasure200,
  GetCategoryByCode1200,
  GetCategoryByCode200,
  GetCategoryById1200,
  GetCategoryById200,
  GetDefectTypeByCode200,
  GetDefectTypeById200,
  GetDefectTypesParams,
  GetItemById200,
  GetItemNamesByCategory200,
  GetItemsByCategory200,
  GetItemsByCategoryCode200,
  GetMaterialsParams,
  GetModifierByCode200,
  GetModifierById200,
  GetModifiersByCategory200,
  GetModifiersByCategoryParams,
  GetModifiersForServiceCategory200,
  GetRecommendedModifiersForDefectsParams,
  GetRecommendedModifiersForStainsParams,
  GetRecommendedUnitOfMeasureParams,
  GetRiskWarningsForItemParams,
  GetStainTypeByCode200,
  GetStainTypeById200,
  GetStainTypesParams,
  IsUnitSupportedForItemParams,
  ModifierRecommendationDTO,
  PriceListItemDTO,
  PriceModifierDTO,
  ServiceCategoryDTO,
  StainTypeDTO,
  UpdateCategory200,
  UpdateModifier200,
  UpdatePriceListItem200,
  UpdateStainType200
} from './aksiApi.schemas';

import orvalFetcher from '../../../../lib/api/orval-fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ ID
 */
export const getStainTypeById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetStainTypeById200>(
      {url: `/stain-types/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStainTypeByIdQueryKey = (id: string,) => {
    return [`/stain-types/${id}`] as const;
    }

    
export const getGetStainTypeByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeById>>> = ({ signal }) => getStainTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeById>>>
export type GetStainTypeByIdInfiniteQueryError = ErrorResponse


export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ ID
 */

export function useGetStainTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeById>>> = ({ signal }) => getStainTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeById>>>
export type GetStainTypeByIdQueryError = ErrorResponse


export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeById>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ ID
 */

export function useGetStainTypeById<TData = Awaited<ReturnType<typeof getStainTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–Ω–æ–≤–ª—é—î —ñ—Å–Ω—É—é—á–∏–π —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const updateStainType = (
    id: string,
    stainTypeDTO: StainTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdateStainType200>(
      {url: `/stain-types/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: stainTypeDTO
    },
      options);
    }
  


export const getUpdateStainTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStainType>>, TError,{id: string;data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateStainType>>, TError,{id: string;data: StainTypeDTO}, TContext> => {

const mutationKey = ['updateStainType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateStainType>>, {id: string;data: StainTypeDTO}> = (props) => {
          const {id,data} = props ?? {};

          return  updateStainType(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateStainTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateStainType>>>
    export type UpdateStainTypeMutationBody = StainTypeDTO
    export type UpdateStainTypeMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const useUpdateStainType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStainType>>, TError,{id: string;data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateStainType>>,
        TError,
        {id: string;data: StainTypeDTO},
        TContext
      > => {

      const mutationOptions = getUpdateStainTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –í–∏–¥–∞–ª—è—î —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const deleteStainType = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeleteStainType200>(
      {url: `/stain-types/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteStainTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStainType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteStainType>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteStainType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteStainType>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteStainType(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteStainTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStainType>>>
    
    export type DeleteStainTypeMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const useDeleteStainType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStainType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteStainType>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteStainTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ ID
 */
export const getModifierById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifierById200>(
      {url: `/price-modifiers/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifierByIdQueryKey = (id: string,) => {
    return [`/price-modifiers/${id}`] as const;
    }

    
export const getGetModifierByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierById>>> = ({ signal }) => getModifierById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierById>>>
export type GetModifierByIdInfiniteQueryError = ErrorResponse


export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ ID
 */

export function useGetModifierByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifierByIdQueryOptions = <TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierById>>> = ({ signal }) => getModifierById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierById>>>
export type GetModifierByIdQueryError = ErrorResponse


export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierById>>,
          TError,
          Awaited<ReturnType<typeof getModifierById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ ID
 */

export function useGetModifierById<TData = Awaited<ReturnType<typeof getModifierById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —ñ—Å–Ω—É—é—á–∏–π –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const updateModifier = (
    id: string,
    priceModifierDTO: PriceModifierDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdateModifier200>(
      {url: `/price-modifiers/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: priceModifierDTO
    },
      options);
    }
  


export const getUpdateModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModifier>>, TError,{id: string;data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateModifier>>, TError,{id: string;data: PriceModifierDTO}, TContext> => {

const mutationKey = ['updateModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateModifier>>, {id: string;data: PriceModifierDTO}> = (props) => {
          const {id,data} = props ?? {};

          return  updateModifier(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateModifierMutationResult = NonNullable<Awaited<ReturnType<typeof updateModifier>>>
    export type UpdateModifierMutationBody = PriceModifierDTO
    export type UpdateModifierMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —ñ—Å–Ω—É—é—á–∏–π –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const useUpdateModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModifier>>, TError,{id: string;data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateModifier>>,
        TError,
        {id: string;data: PriceModifierDTO},
        TContext
      > => {

      const mutationOptions = getUpdateModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –î–µ–∞–∫—Ç–∏–≤—É–≤–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const deactivateModifier = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DeactivateModifier200>(
      {url: `/price-modifiers/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeactivateModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateModifier>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deactivateModifier>>, TError,{id: string}, TContext> => {

const mutationKey = ['deactivateModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deactivateModifier>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deactivateModifier(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeactivateModifierMutationResult = NonNullable<Awaited<ReturnType<typeof deactivateModifier>>>
    
    export type DeactivateModifierMutationError = ErrorResponse

    /**
 * @summary –î–µ–∞–∫—Ç–∏–≤—É–≤–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const useDeactivateModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateModifier>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deactivateModifier>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeactivateModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ ID
 */
export const getItemById = (
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemById200>(
      {url: `/price-list/item/${itemId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemByIdQueryKey = (itemId: string,) => {
    return [`/price-list/item/${itemId}`] as const;
    }

    
export const getGetItemByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemByIdQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemById>>> = ({ signal }) => getItemById(itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemById>>>
export type GetItemByIdInfiniteQueryError = ErrorResponse


export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ ID
 */

export function useGetItemByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemById>>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemByIdInfiniteQueryOptions(itemId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemByIdQueryOptions = <TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemByIdQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemById>>> = ({ signal }) => getItemById(itemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(itemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getItemById>>>
export type GetItemByIdQueryError = ErrorResponse


export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemById>>,
          TError,
          Awaited<ReturnType<typeof getItemById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ ID
 */

export function useGetItemById<TData = Awaited<ReturnType<typeof getItemById>>, TError = ErrorResponse>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemByIdQueryOptions(itemId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞
 */
export const updatePriceListItem = (
    itemId: string,
    priceListItemDTO: PriceListItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdatePriceListItem200>(
      {url: `/price-list/item/${itemId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: priceListItemDTO
    },
      options);
    }
  


export const getUpdatePriceListItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePriceListItem>>, TError,{itemId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePriceListItem>>, TError,{itemId: string;data: PriceListItemDTO}, TContext> => {

const mutationKey = ['updatePriceListItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePriceListItem>>, {itemId: string;data: PriceListItemDTO}> = (props) => {
          const {itemId,data} = props ?? {};

          return  updatePriceListItem(itemId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePriceListItemMutationResult = NonNullable<Awaited<ReturnType<typeof updatePriceListItem>>>
    export type UpdatePriceListItemMutationBody = PriceListItemDTO
    export type UpdatePriceListItemMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞
 */
export const useUpdatePriceListItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePriceListItem>>, TError,{itemId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePriceListItem>>,
        TError,
        {itemId: string;data: PriceListItemDTO},
        TContext
      > => {

      const mutationOptions = getUpdatePriceListItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥
 */
export const updateCategory = (
    categoryId: string,
    serviceCategoryDTO: ServiceCategoryDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<UpdateCategory200>(
      {url: `/price-list/category/${categoryId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: serviceCategoryDTO
    },
      options);
    }
  


export const getUpdateCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: ServiceCategoryDTO}, TContext> => {

const mutationKey = ['updateCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCategory>>, {categoryId: string;data: ServiceCategoryDTO}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  updateCategory(categoryId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategory>>>
    export type UpdateCategoryMutationBody = ServiceCategoryDTO
    export type UpdateCategoryMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥
 */
export const useUpdateCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCategory>>,
        TError,
        {categoryId: string;data: ServiceCategoryDTO},
        TContext
      > => {

      const mutationOptions = getUpdateCategoryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ ID
 */
export const getDefectTypeById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetDefectTypeById200>(
      {url: `/defect-types/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectTypeByIdQueryKey = (id: string,) => {
    return [`/defect-types/${id}`] as const;
    }

    
export const getGetDefectTypeByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeById>>> = ({ signal }) => getDefectTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeById>>>
export type GetDefectTypeByIdInfiniteQueryError = ErrorResponse


export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ ID
 */

export function useGetDefectTypeByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectTypeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeById>>> = ({ signal }) => getDefectTypeById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeById>>>
export type GetDefectTypeByIdQueryError = ErrorResponse


export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ ID
 */

export function useGetDefectTypeById<TData = Awaited<ReturnType<typeof getDefectTypeById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–Ω–æ–≤–ª—é—î —ñ—Å–Ω—É—é—á–∏–π —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const updateDefectType = (
    id: string,
    defectTypeDTO: DefectTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<DefectTypeDTO>(
      {url: `/defect-types/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: defectTypeDTO
    },
      options);
    }
  


export const getUpdateDefectTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDefectType>>, TError,{id: string;data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateDefectType>>, TError,{id: string;data: DefectTypeDTO}, TContext> => {

const mutationKey = ['updateDefectType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDefectType>>, {id: string;data: DefectTypeDTO}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDefectType(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDefectTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateDefectType>>>
    export type UpdateDefectTypeMutationBody = DefectTypeDTO
    export type UpdateDefectTypeMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const useUpdateDefectType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDefectType>>, TError,{id: string;data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDefectType>>,
        TError,
        {id: string;data: DefectTypeDTO},
        TContext
      > => {

      const mutationOptions = getUpdateDefectTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –í–∏–¥–∞–ª—è—î —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const deleteDefectType = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/defect-types/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteDefectTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDefectType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDefectType>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteDefectType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDefectType>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteDefectType(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDefectTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDefectType>>>
    
    export type DeleteDefectTypeMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const useDeleteDefectType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDefectType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDefectType>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteDefectTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∞–±–æ —Ç—ñ–ª—å–∫–∏ –∞–∫—Ç–∏–≤–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –ø–ª—è–º –∑ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—é —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—ó –∑–∞ —Ä—ñ–≤–Ω–µ–º —Ä–∏–∑–∏–∫—É
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º
 */
export const getStainTypes = (
    params?: GetStainTypesParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainTypeDTO[]>(
      {url: `/stain-types`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetStainTypesQueryKey = (params?: GetStainTypesParams,) => {
    return [`/stain-types`, ...(params ? [params]: [])] as const;
    }

    
export const getGetStainTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes>>> = ({ signal }) => getStainTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes>>>
export type GetStainTypesInfiniteQueryError = ErrorResponse


export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params: undefined |  GetStainTypesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º
 */

export function useGetStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes>>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypesInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypesQueryOptions = <TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes>>> = ({ signal }) => getStainTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes>>>
export type GetStainTypesQueryError = ErrorResponse


export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params: undefined |  GetStainTypesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º
 */

export function useGetStainTypes<TData = Awaited<ReturnType<typeof getStainTypes>>, TError = ErrorResponse>(
 params?: GetStainTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤–∏–π —Ç–∏–ø –ø–ª—è–º–∏ –∑ –≤–∫–∞–∑–∞–Ω–∏–º–∏ –¥–∞–Ω–∏–º–∏
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const createStainType = (
    stainTypeDTO: StainTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreateStainType200>(
      {url: `/stain-types`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: stainTypeDTO, signal
    },
      options);
    }
  


export const getCreateStainTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStainType>>, TError,{data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createStainType>>, TError,{data: StainTypeDTO}, TContext> => {

const mutationKey = ['createStainType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStainType>>, {data: StainTypeDTO}> = (props) => {
          const {data} = props ?? {};

          return  createStainType(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateStainTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createStainType>>>
    export type CreateStainTypeMutationBody = StainTypeDTO
    export type CreateStainTypeMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏
 */
export const useCreateStainType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStainType>>, TError,{data: StainTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createStainType>>,
        TError,
        {data: StainTypeDTO},
        TContext
      > => {

      const mutationOptions = getCreateStainTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∞–∫—Ç–∏–≤–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏
 */
export const getAllModifiers = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAllModifiers200>(
      {url: `/price-modifiers`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllModifiersQueryKey = () => {
    return [`/price-modifiers`] as const;
    }

    
export const getGetAllModifiersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllModifiersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllModifiers>>> = ({ signal }) => getAllModifiers(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllModifiersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllModifiers>>>
export type GetAllModifiersInfiniteQueryError = ErrorResponse


export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∞–∫—Ç–∏–≤–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏
 */

export function useGetAllModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllModifiers>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllModifiersInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllModifiersQueryOptions = <TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllModifiersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllModifiers>>> = ({ signal }) => getAllModifiers(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllModifiers>>>
export type GetAllModifiersQueryError = ErrorResponse


export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllModifiers>>,
          TError,
          Awaited<ReturnType<typeof getAllModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∞–∫—Ç–∏–≤–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏
 */

export function useGetAllModifiers<TData = Awaited<ReturnType<typeof getAllModifiers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllModifiersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const createModifier = (
    priceModifierDTO: PriceModifierDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreateModifier200>(
      {url: `/price-modifiers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: priceModifierDTO, signal
    },
      options);
    }
  


export const getCreateModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModifier>>, TError,{data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createModifier>>, TError,{data: PriceModifierDTO}, TContext> => {

const mutationKey = ['createModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createModifier>>, {data: PriceModifierDTO}> = (props) => {
          const {data} = props ?? {};

          return  createModifier(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateModifierMutationResult = NonNullable<Awaited<ReturnType<typeof createModifier>>>
    export type CreateModifierMutationBody = PriceModifierDTO
    export type CreateModifierMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —Ü—ñ–Ω–∏
 */
export const useCreateModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModifier>>, TError,{data: PriceModifierDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createModifier>>,
        TError,
        {data: PriceModifierDTO},
        TContext
      > => {

      const mutationOptions = getCreateModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –≤ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const createPriceListItem = (
    categoryId: string,
    priceListItemDTO: PriceListItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreatePriceListItem200>(
      {url: `/price-list/${categoryId}/item`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: priceListItemDTO, signal
    },
      options);
    }
  


export const getCreatePriceListItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPriceListItem>>, TError,{categoryId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createPriceListItem>>, TError,{categoryId: string;data: PriceListItemDTO}, TContext> => {

const mutationKey = ['createPriceListItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPriceListItem>>, {categoryId: string;data: PriceListItemDTO}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  createPriceListItem(categoryId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePriceListItemMutationResult = NonNullable<Awaited<ReturnType<typeof createPriceListItem>>>
    export type CreatePriceListItemMutationBody = PriceListItemDTO
    export type CreatePriceListItemMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –≤ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const useCreatePriceListItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPriceListItem>>, TError,{categoryId: string;data: PriceListItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPriceListItem>>,
        TError,
        {categoryId: string;data: PriceListItemDTO},
        TContext
      > => {

      const mutationOptions = getCreatePriceListItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤—É –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥
 */
export const createCategory = (
    serviceCategoryDTO: ServiceCategoryDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CreateCategory200>(
      {url: `/price-list/category`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: serviceCategoryDTO, signal
    },
      options);
    }
  


export const getCreateCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: ServiceCategoryDTO}, TContext> => {

const mutationKey = ['createCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCategory>>, {data: ServiceCategoryDTO}> = (props) => {
          const {data} = props ?? {};

          return  createCategory(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof createCategory>>>
    export type CreateCategoryMutationBody = ServiceCategoryDTO
    export type CreateCategoryMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤—É –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥
 */
export const useCreateCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: ServiceCategoryDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCategory>>,
        TError,
        {data: ServiceCategoryDTO},
        TContext
      > => {

      const mutationOptions = getCreateCategoryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∞–±–æ —Ç—ñ–ª—å–∫–∏ –∞–∫—Ç–∏–≤–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –¥–µ—Ñ–µ–∫—Ç—ñ–≤ –∑ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—é —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—ó –∑–∞ —Ä—ñ–≤–Ω–µ–º —Ä–∏–∑–∏–∫—É
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */
export const getDefectTypes = (
    params?: GetDefectTypesParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<DefectTypeDTO[]>(
      {url: `/defect-types`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetDefectTypesQueryKey = (params?: GetDefectTypesParams,) => {
    return [`/defect-types`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDefectTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypes>>> = ({ signal }) => getDefectTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypes>>>
export type GetDefectTypesInfiniteQueryError = ErrorResponse


export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params: undefined |  GetDefectTypesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useGetDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypes>>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypesInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectTypesQueryOptions = <TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypes>>> = ({ signal }) => getDefectTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypes>>>
export type GetDefectTypesQueryError = ErrorResponse


export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params: undefined |  GetDefectTypesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useGetDefectTypes<TData = Awaited<ReturnType<typeof getDefectTypes>>, TError = ErrorResponse>(
 params?: GetDefectTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤–∏–π —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑ –≤–∫–∞–∑–∞–Ω–∏–º–∏ –¥–∞–Ω–∏–º–∏
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const createDefectType = (
    defectTypeDTO: DefectTypeDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<DefectTypeDTO>(
      {url: `/defect-types`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: defectTypeDTO, signal
    },
      options);
    }
  


export const getCreateDefectTypeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDefectType>>, TError,{data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createDefectType>>, TError,{data: DefectTypeDTO}, TContext> => {

const mutationKey = ['createDefectType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDefectType>>, {data: DefectTypeDTO}> = (props) => {
          const {data} = props ?? {};

          return  createDefectType(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDefectTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createDefectType>>>
    export type CreateDefectTypeMutationBody = DefectTypeDTO
    export type CreateDefectTypeMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É
 */
export const useCreateDefectType = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDefectType>>, TError,{data: DefectTypeDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDefectType>>,
        TError,
        {data: DefectTypeDTO},
        TContext
      > => {

      const mutationOptions = getCreateDefectTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—É –æ–¥–∏–Ω–∏—Ü—é –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const getRecommendedUnitOfMeasure = (
    params: GetRecommendedUnitOfMeasureParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/units-of-measure/recommend`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedUnitOfMeasureQueryKey = (params: GetRecommendedUnitOfMeasureParams,) => {
    return [`/units-of-measure/recommend`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedUnitOfMeasureInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedUnitOfMeasureQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>> = ({ signal }) => getRecommendedUnitOfMeasure(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedUnitOfMeasureInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>
export type GetRecommendedUnitOfMeasureInfiniteQueryError = ErrorResponse


export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—É –æ–¥–∏–Ω–∏—Ü—é –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */

export function useGetRecommendedUnitOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedUnitOfMeasureInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedUnitOfMeasureQueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedUnitOfMeasureQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>> = ({ signal }) => getRecommendedUnitOfMeasure(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedUnitOfMeasureQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>>
export type GetRecommendedUnitOfMeasureQueryError = ErrorResponse


export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—É –æ–¥–∏–Ω–∏—Ü—é –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */

export function useGetRecommendedUnitOfMeasure<TData = Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError = ErrorResponse>(
 params: GetRecommendedUnitOfMeasureParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedUnitOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedUnitOfMeasureQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const isUnitSupportedForItem = (
    params: IsUnitSupportedForItemParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/units-of-measure/check-support`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getIsUnitSupportedForItemQueryKey = (params: IsUnitSupportedForItemParams,) => {
    return [`/units-of-measure/check-support`, ...(params ? [params]: [])] as const;
    }

    
export const getIsUnitSupportedForItemInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsUnitSupportedForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isUnitSupportedForItem>>> = ({ signal }) => isUnitSupportedForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsUnitSupportedForItemInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof isUnitSupportedForItem>>>
export type IsUnitSupportedForItemInfiniteQueryError = ErrorResponse


export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */

export function useIsUnitSupportedForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof isUnitSupportedForItem>>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsUnitSupportedForItemInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getIsUnitSupportedForItemQueryOptions = <TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsUnitSupportedForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isUnitSupportedForItem>>> = ({ signal }) => isUnitSupportedForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsUnitSupportedForItemQueryResult = NonNullable<Awaited<ReturnType<typeof isUnitSupportedForItem>>>
export type IsUnitSupportedForItemQueryError = ErrorResponse


export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isUnitSupportedForItem>>,
          TError,
          Awaited<ReturnType<typeof isUnitSupportedForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */

export function useIsUnitSupportedForItem<TData = Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError = ErrorResponse>(
 params: IsUnitSupportedForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isUnitSupportedForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsUnitSupportedForItemQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const getAvailableUnitsForCategory = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/units-of-measure/category/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAvailableUnitsForCategoryQueryKey = (categoryId: string,) => {
    return [`/units-of-measure/category/${categoryId}`] as const;
    }

    
export const getGetAvailableUnitsForCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsForCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>> = ({ signal }) => getAvailableUnitsForCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsForCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>
export type GetAvailableUnitsForCategoryInfiniteQueryError = ErrorResponse


export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetAvailableUnitsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsForCategoryInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableUnitsForCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsForCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>> = ({ signal }) => getAvailableUnitsForCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsForCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>>
export type GetAvailableUnitsForCategoryQueryError = ErrorResponse


export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetAvailableUnitsForCategory<TData = Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsForCategoryQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º –∫–æ–¥–æ–º
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –∫–æ–¥–æ–º
 */
export const getStainTypeByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetStainTypeByCode200>(
      {url: `/stain-types/by-code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStainTypeByCodeQueryKey = (code: string,) => {
    return [`/stain-types/by-code/${code}`] as const;
    }

    
export const getGetStainTypeByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeByCode>>> = ({ signal }) => getStainTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeByCode>>>
export type GetStainTypeByCodeInfiniteQueryError = ErrorResponse


export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetStainTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypeByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypeByCode>>> = ({ signal }) => getStainTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypeByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypeByCode>>>
export type GetStainTypeByCodeQueryError = ErrorResponse


export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getStainTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –ø–ª—è–º–∏ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetStainTypeByCode<TData = Awaited<ReturnType<typeof getStainTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypeByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –ø–æ—Å–ª—É–≥
 */
export const getAllActiveCategories = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAllActiveCategories200>(
      {url: `/service-categories`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllActiveCategoriesQueryKey = () => {
    return [`/service-categories`] as const;
    }

    
export const getGetAllActiveCategoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllActiveCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllActiveCategories>>> = ({ signal }) => getAllActiveCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllActiveCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllActiveCategories>>>
export type GetAllActiveCategoriesInfiniteQueryError = ErrorResponse


export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –ø–æ—Å–ª—É–≥
 */

export function useGetAllActiveCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllActiveCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllActiveCategoriesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllActiveCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllActiveCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllActiveCategories>>> = ({ signal }) => getAllActiveCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllActiveCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllActiveCategories>>>
export type GetAllActiveCategoriesQueryError = ErrorResponse


export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllActiveCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllActiveCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –≤—Å—ñ—Ö –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –ø–æ—Å–ª—É–≥
 */

export function useGetAllActiveCategories<TData = Awaited<ReturnType<typeof getAllActiveCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllActiveCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllActiveCategoriesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ ID
 */
export const getCategoryById = (
    id: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryById200>(
      {url: `/service-categories/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByIdQueryKey = (id: string,) => {
    return [`/service-categories/${id}`] as const;
    }

    
export const getGetCategoryByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdInfiniteQueryError = ErrorResponse


export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ ID
 */

export function useGetCategoryByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdQueryError = ErrorResponse


export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ ID
 */

export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */
export const getCategoryByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryByCode200>(
      {url: `/service-categories/code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByCodeQueryKey = (code: string,) => {
    return [`/service-categories/code/${code}`] as const;
    }

    
export const getGetCategoryByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode>>> = ({ signal }) => getCategoryByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode>>>
export type GetCategoryByCodeInfiniteQueryError = ErrorResponse


export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetCategoryByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode>>> = ({ signal }) => getCategoryByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode>>>
export type GetCategoryByCodeQueryError = ErrorResponse


export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */
export const getModifiersForServiceCategory = (
    categoryCode: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersForServiceCategory200>(
      {url: `/price-modifiers/service-category/${categoryCode}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifiersForServiceCategoryQueryKey = (categoryCode: string,) => {
    return [`/price-modifiers/service-category/${categoryCode}`] as const;
    }

    
export const getGetModifiersForServiceCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersForServiceCategoryQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersForServiceCategory>>> = ({ signal }) => getModifiersForServiceCategory(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersForServiceCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>
export type GetModifiersForServiceCategoryInfiniteQueryError = ErrorResponse


export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */

export function useGetModifiersForServiceCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersForServiceCategoryInfiniteQueryOptions(categoryCode,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifiersForServiceCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersForServiceCategoryQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersForServiceCategory>>> = ({ signal }) => getModifiersForServiceCategory(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersForServiceCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersForServiceCategory>>>
export type GetModifiersForServiceCategoryQueryError = ErrorResponse


export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersForServiceCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */

export function useGetModifiersForServiceCategory<TData = Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersForServiceCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersForServiceCategoryQueryOptions(categoryCode,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ –∫–æ–¥–æ–º
 */
export const getModifierByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifierByCode200>(
      {url: `/price-modifiers/code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetModifierByCodeQueryKey = (code: string,) => {
    return [`/price-modifiers/code/${code}`] as const;
    }

    
export const getGetModifierByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierByCode>>> = ({ signal }) => getModifierByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierByCode>>>
export type GetModifierByCodeInfiniteQueryError = ErrorResponse


export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetModifierByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifierByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifierByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifierByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifierByCode>>> = ({ signal }) => getModifierByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifierByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getModifierByCode>>>
export type GetModifierByCodeQueryError = ErrorResponse


export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifierByCode>>,
          TError,
          Awaited<ReturnType<typeof getModifierByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetModifierByCode<TData = Awaited<ReturnType<typeof getModifierByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifierByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifierByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */
export const getModifiersByCategory = (
    params: GetModifiersByCategoryParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetModifiersByCategory200>(
      {url: `/price-modifiers/category`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetModifiersByCategoryQueryKey = (params: GetModifiersByCategoryParams,) => {
    return [`/price-modifiers/category`, ...(params ? [params]: [])] as const;
    }

    
export const getGetModifiersByCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersByCategoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersByCategory>>> = ({ signal }) => getModifiersByCategory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersByCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCategory>>>
export type GetModifiersByCategoryInfiniteQueryError = ErrorResponse


export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetModifiersByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getModifiersByCategory>>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersByCategoryInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetModifiersByCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModifiersByCategoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModifiersByCategory>>> = ({ signal }) => getModifiersByCategory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModifiersByCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getModifiersByCategory>>>
export type GetModifiersByCategoryQueryError = ErrorResponse


export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModifiersByCategory>>,
          TError,
          Awaited<ReturnType<typeof getModifiersByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetModifiersByCategory<TData = Awaited<ReturnType<typeof getModifiersByCategory>>, TError = ErrorResponse>(
 params: GetModifiersByCategoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModifiersByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModifiersByCategoryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */
export const getAllCategories = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAllCategories200>(
      {url: `/price-list`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllCategoriesQueryKey = () => {
    return [`/price-list`] as const;
    }

    
export const getGetAllCategoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCategories>>> = ({ signal }) => getAllCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllCategories>>>
export type GetAllCategoriesInfiniteQueryError = ErrorResponse


export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */

export function useGetAllCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAllCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllCategoriesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCategories>>> = ({ signal }) => getAllCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllCategories>>>
export type GetAllCategoriesQueryError = ErrorResponse


export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategories>>,
          TError,
          Awaited<ReturnType<typeof getAllCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø–æ—Å–ª—É–≥
 */

export function useGetAllCategories<TData = Awaited<ReturnType<typeof getAllCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllCategoriesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 */
export const getCategoryById1 = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryById1200>(
      {url: `/price-list/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryById1QueryKey = (categoryId: string,) => {
    return [`/price-list/${categoryId}`] as const;
    }

    
export const getGetCategoryById1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryById1QueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById1>>> = ({ signal }) => getCategoryById1(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryById1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById1>>>
export type GetCategoryById1InfiniteQueryError = ErrorResponse


export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 */

export function useGetCategoryById1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById1>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryById1InfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryById1QueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryById1QueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById1>>> = ({ signal }) => getCategoryById1(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryById1QueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById1>>>
export type GetCategoryById1QueryError = ErrorResponse


export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º
 */

export function useGetCategoryById1<TData = Awaited<ReturnType<typeof getCategoryById1>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryById1QueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */
export const getCategoryByCode1 = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetCategoryByCode1200>(
      {url: `/price-list/category/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByCode1QueryKey = (code: string,) => {
    return [`/price-list/category/${code}`] as const;
    }

    
export const getGetCategoryByCode1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCode1QueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode1>>> = ({ signal }) => getCategoryByCode1(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCode1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode1>>>
export type GetCategoryByCode1InfiniteQueryError = ErrorResponse


export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetCategoryByCode1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryByCode1>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCode1InfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByCode1QueryOptions = <TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCode1QueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode1>>> = ({ signal }) => getCategoryByCode1(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCode1QueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode1>>>
export type GetCategoryByCode1QueryError = ErrorResponse


export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryByCode1>>,
          TError,
          Awaited<ReturnType<typeof getCategoryByCode1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥ –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetCategoryByCode1<TData = Awaited<ReturnType<typeof getCategoryByCode1>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCode1QueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const getAvailableUnitsOfMeasure = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetAvailableUnitsOfMeasure200>(
      {url: `/price-list/category/${categoryId}/units-of-measure`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAvailableUnitsOfMeasureQueryKey = (categoryId: string,) => {
    return [`/price-list/category/${categoryId}/units-of-measure`] as const;
    }

    
export const getGetAvailableUnitsOfMeasureInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsOfMeasureQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>> = ({ signal }) => getAvailableUnitsOfMeasure(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsOfMeasureInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>
export type GetAvailableUnitsOfMeasureInfiniteQueryError = ErrorResponse


export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetAvailableUnitsOfMeasureInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsOfMeasureInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAvailableUnitsOfMeasureQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableUnitsOfMeasureQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>> = ({ signal }) => getAvailableUnitsOfMeasure(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableUnitsOfMeasureQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>>
export type GetAvailableUnitsOfMeasureQueryError = ErrorResponse


export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>,
          TError,
          Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetAvailableUnitsOfMeasure<TData = Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableUnitsOfMeasure>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableUnitsOfMeasureQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */
export const getItemsByCategory = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemsByCategory200>(
      {url: `/price-list/category/${categoryId}/items`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemsByCategoryQueryKey = (categoryId: string,) => {
    return [`/price-list/category/${categoryId}/items`] as const;
    }

    
export const getGetItemsByCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategory>>> = ({ signal }) => getItemsByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategory>>>
export type GetItemsByCategoryInfiniteQueryError = ErrorResponse


export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetItemsByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemsByCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategory>>> = ({ signal }) => getItemsByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategory>>>
export type GetItemsByCategoryQueryError = ErrorResponse


export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetItemsByCategory<TData = Awaited<ReturnType<typeof getItemsByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –Ω–∞–π–º–µ–Ω—É–≤–∞–Ω—å –≤–∏—Ä–æ–±—ñ–≤ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */
export const getItemNamesByCategory = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemNamesByCategory200>(
      {url: `/price-list/category/${categoryId}/item-names`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemNamesByCategoryQueryKey = (categoryId: string,) => {
    return [`/price-list/category/${categoryId}/item-names`] as const;
    }

    
export const getGetItemNamesByCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemNamesByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemNamesByCategory>>> = ({ signal }) => getItemNamesByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemNamesByCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemNamesByCategory>>>
export type GetItemNamesByCategoryInfiniteQueryError = ErrorResponse


export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –Ω–∞–π–º–µ–Ω—É–≤–∞–Ω—å –≤–∏—Ä–æ–±—ñ–≤ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetItemNamesByCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemNamesByCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemNamesByCategoryInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemNamesByCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemNamesByCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemNamesByCategory>>> = ({ signal }) => getItemNamesByCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemNamesByCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getItemNamesByCategory>>>
export type GetItemNamesByCategoryQueryError = ErrorResponse


export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemNamesByCategory>>,
          TError,
          Awaited<ReturnType<typeof getItemNamesByCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –Ω–∞–π–º–µ–Ω—É–≤–∞–Ω—å –≤–∏—Ä–æ–±—ñ–≤ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
 */

export function useGetItemNamesByCategory<TData = Awaited<ReturnType<typeof getItemNamesByCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemNamesByCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemNamesByCategoryQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–æ–¥–æ–º –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const getItemsByCategoryCode = (
    categoryCode: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetItemsByCategoryCode200>(
      {url: `/price-list/category/code/${categoryCode}/items`, method: 'GET', signal
    },
      options);
    }
  

export const getGetItemsByCategoryCodeQueryKey = (categoryCode: string,) => {
    return [`/price-list/category/code/${categoryCode}/items`] as const;
    }

    
export const getGetItemsByCategoryCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryCodeQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategoryCode>>> = ({ signal }) => getItemsByCategoryCode(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategoryCode>>>
export type GetItemsByCategoryCodeInfiniteQueryError = ErrorResponse


export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–æ–¥–æ–º –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetItemsByCategoryCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getItemsByCategoryCode>>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryCodeInfiniteQueryOptions(categoryCode,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetItemsByCategoryCodeQueryOptions = <TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemsByCategoryCodeQueryKey(categoryCode);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByCategoryCode>>> = ({ signal }) => getItemsByCategoryCode(categoryCode, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryCode), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsByCategoryCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByCategoryCode>>>
export type GetItemsByCategoryCodeQueryError = ErrorResponse


export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByCategoryCode>>,
          TError,
          Awaited<ReturnType<typeof getItemsByCategoryCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞ –∑–∞ –∫–æ–¥–æ–º –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useGetItemsByCategoryCode<TData = Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError = ErrorResponse>(
 categoryCode: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsByCategoryCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemsByCategoryCodeQueryOptions(categoryCode,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤ —Ü—ñ–Ω –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤–∫–∞–∑–∞–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –ø–ª—è–º, –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó —Ç–∞ –º–∞—Ç–µ—Ä—ñ–∞–ª—É
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–ª—è–º
 */
export const getRecommendedModifiersForStains = (
    params: GetRecommendedModifiersForStainsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ModifierRecommendationDTO[]>(
      {url: `/modifier-recommendations/stains`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedModifiersForStainsQueryKey = (params: GetRecommendedModifiersForStainsParams,) => {
    return [`/modifier-recommendations/stains`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedModifiersForStainsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForStainsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>> = ({ signal }) => getRecommendedModifiersForStains(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForStainsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>
export type GetRecommendedModifiersForStainsInfiniteQueryError = ErrorResponse


export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–ª—è–º
 */

export function useGetRecommendedModifiersForStainsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForStainsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedModifiersForStainsQueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForStainsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>> = ({ signal }) => getRecommendedModifiersForStains(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForStainsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>>
export type GetRecommendedModifiersForStainsQueryError = ErrorResponse


export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForStains>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–ª—è–º
 */

export function useGetRecommendedModifiersForStains<TData = Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForStainsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForStains>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForStainsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω—å –ø—Ä–æ —Ä–∏–∑–∏–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤–∫–∞–∑–∞–Ω–∏—Ö –ø–ª—è–º, –¥–µ—Ñ–µ–∫—Ç—ñ–≤, –º–∞—Ç–µ—Ä—ñ–∞–ª—É —Ç–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ —Ä–∏–∑–∏–∫–∏
 */
export const getRiskWarningsForItem = (
    params?: GetRiskWarningsForItemParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/modifier-recommendations/risks`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRiskWarningsForItemQueryKey = (params?: GetRiskWarningsForItemParams,) => {
    return [`/modifier-recommendations/risks`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRiskWarningsForItemInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRiskWarningsForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRiskWarningsForItem>>> = ({ signal }) => getRiskWarningsForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRiskWarningsForItemInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRiskWarningsForItem>>>
export type GetRiskWarningsForItemInfiniteQueryError = ErrorResponse


export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params: undefined |  GetRiskWarningsForItemParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ —Ä–∏–∑–∏–∫–∏
 */

export function useGetRiskWarningsForItemInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRiskWarningsForItem>>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRiskWarningsForItemInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRiskWarningsForItemQueryOptions = <TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRiskWarningsForItemQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRiskWarningsForItem>>> = ({ signal }) => getRiskWarningsForItem(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRiskWarningsForItemQueryResult = NonNullable<Awaited<ReturnType<typeof getRiskWarningsForItem>>>
export type GetRiskWarningsForItemQueryError = ErrorResponse


export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params: undefined |  GetRiskWarningsForItemParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRiskWarningsForItem>>,
          TError,
          Awaited<ReturnType<typeof getRiskWarningsForItem>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ —Ä–∏–∑–∏–∫–∏
 */

export function useGetRiskWarningsForItem<TData = Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError = ErrorResponse>(
 params?: GetRiskWarningsForItemParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRiskWarningsForItem>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRiskWarningsForItemQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Å–ø–∏—Å–æ–∫ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤ —Ü—ñ–Ω –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤–∫–∞–∑–∞–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –¥–µ—Ñ–µ–∫—Ç—ñ–≤, –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó —Ç–∞ –º–∞—Ç–µ—Ä—ñ–∞–ª—É
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */
export const getRecommendedModifiersForDefects = (
    params: GetRecommendedModifiersForDefectsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ModifierRecommendationDTO[]>(
      {url: `/modifier-recommendations/defects`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRecommendedModifiersForDefectsQueryKey = (params: GetRecommendedModifiersForDefectsParams,) => {
    return [`/modifier-recommendations/defects`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecommendedModifiersForDefectsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForDefectsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>> = ({ signal }) => getRecommendedModifiersForDefects(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForDefectsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>
export type GetRecommendedModifiersForDefectsInfiniteQueryError = ErrorResponse


export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useGetRecommendedModifiersForDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForDefectsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRecommendedModifiersForDefectsQueryOptions = <TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecommendedModifiersForDefectsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>> = ({ signal }) => getRecommendedModifiersForDefects(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecommendedModifiersForDefectsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>>
export type GetRecommendedModifiersForDefectsQueryError = ErrorResponse


export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>,
          TError,
          Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useGetRecommendedModifiersForDefects<TData = Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError = ErrorResponse>(
 params: GetRecommendedModifiersForDefectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendedModifiersForDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecommendedModifiersForDefectsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç—É–ø–µ–Ω—ñ –∑–Ω–æ—Å—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getWearDegrees = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/wear-degrees`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWearDegreesQueryKey = () => {
    return [`/item-characteristics/wear-degrees`] as const;
    }

    
export const getGetWearDegreesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWearDegreesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWearDegrees>>> = ({ signal }) => getWearDegrees(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWearDegreesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWearDegrees>>>
export type GetWearDegreesInfiniteQueryError = ErrorResponse


export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç—É–ø–µ–Ω—ñ –∑–Ω–æ—Å—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetWearDegreesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getWearDegrees>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWearDegreesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetWearDegreesQueryOptions = <TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWearDegreesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWearDegrees>>> = ({ signal }) => getWearDegrees(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWearDegreesQueryResult = NonNullable<Awaited<ReturnType<typeof getWearDegrees>>>
export type GetWearDegreesQueryError = ErrorResponse


export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWearDegrees>>,
          TError,
          Awaited<ReturnType<typeof getWearDegrees>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç—É–ø–µ–Ω—ñ –∑–Ω–æ—Å—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetWearDegrees<TData = Awaited<ReturnType<typeof getWearDegrees>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWearDegrees>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWearDegreesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getStainTypes1 = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/stain-types`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStainTypes1QueryKey = () => {
    return [`/item-characteristics/stain-types`] as const;
    }

    
export const getGetStainTypes1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypes1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes1>>> = ({ signal }) => getStainTypes1(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypes1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes1>>>
export type GetStainTypes1InfiniteQueryError = ErrorResponse


export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetStainTypes1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof getStainTypes1>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypes1InfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetStainTypes1QueryOptions = <TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStainTypes1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStainTypes1>>> = ({ signal }) => getStainTypes1(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStainTypes1QueryResult = NonNullable<Awaited<ReturnType<typeof getStainTypes1>>>
export type GetStainTypes1QueryError = ErrorResponse


export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStainTypes1>>,
          TError,
          Awaited<ReturnType<typeof getStainTypes1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –ø–ª—è–º –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetStainTypes1<TData = Awaited<ReturnType<typeof getStainTypes1>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStainTypes1>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStainTypes1QueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getRisks = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/risks`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRisksQueryKey = () => {
    return [`/item-characteristics/risks`] as const;
    }

    
export const getGetRisksInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRisks>>> = ({ signal }) => getRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRisksInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRisks>>>
export type GetRisksInfiniteQueryError = ErrorResponse


export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRisksInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRisksQueryOptions = <TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRisks>>> = ({ signal }) => getRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRisksQueryResult = NonNullable<Awaited<ReturnType<typeof getRisks>>>
export type GetRisksQueryError = ErrorResponse


export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRisks>>,
          TError,
          Awaited<ReturnType<typeof getRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetRisks<TData = Awaited<ReturnType<typeof getRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRisksQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –º–∞—Ç–µ—Ä—ñ–∞–ª–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getMaterials = (
    params?: GetMaterialsParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/materials`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetMaterialsQueryKey = (params?: GetMaterialsParams,) => {
    return [`/item-characteristics/materials`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMaterialsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterials>>> = ({ signal }) => getMaterials(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMaterialsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterials>>>
export type GetMaterialsInfiniteQueryError = ErrorResponse


export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params: undefined |  GetMaterialsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –º–∞—Ç–µ—Ä—ñ–∞–ª–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMaterials>>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMaterialsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMaterialsQueryOptions = <TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMaterialsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterials>>> = ({ signal }) => getMaterials(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMaterialsQueryResult = NonNullable<Awaited<ReturnType<typeof getMaterials>>>
export type GetMaterialsQueryError = ErrorResponse


export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params: undefined |  GetMaterialsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaterials>>,
          TError,
          Awaited<ReturnType<typeof getMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –º–∞—Ç–µ—Ä—ñ–∞–ª–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetMaterials<TData = Awaited<ReturnType<typeof getMaterials>>, TError = ErrorResponse>(
 params?: GetMaterialsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMaterialsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –Ω–∞–ø–æ–≤–Ω—é–≤–∞—á—ñ–≤ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getFillerTypes = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/filler-types`, method: 'GET', signal
    },
      options);
    }
  

export const getGetFillerTypesQueryKey = () => {
    return [`/item-characteristics/filler-types`] as const;
    }

    
export const getGetFillerTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFillerTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFillerTypes>>> = ({ signal }) => getFillerTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFillerTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFillerTypes>>>
export type GetFillerTypesInfiniteQueryError = ErrorResponse


export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –Ω–∞–ø–æ–≤–Ω—é–≤–∞—á—ñ–≤ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetFillerTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFillerTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFillerTypesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFillerTypesQueryOptions = <TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFillerTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFillerTypes>>> = ({ signal }) => getFillerTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFillerTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getFillerTypes>>>
export type GetFillerTypesQueryError = ErrorResponse


export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFillerTypes>>,
          TError,
          Awaited<ReturnType<typeof getFillerTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø–∏ –Ω–∞–ø–æ–≤–Ω—é–≤–∞—á—ñ–≤ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetFillerTypes<TData = Awaited<ReturnType<typeof getFillerTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFillerTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFillerTypesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ –¥–µ—Ñ–µ–∫—Ç–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getDefects = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/defects`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectsQueryKey = () => {
    return [`/item-characteristics/defects`] as const;
    }

    
export const getGetDefectsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefects>>> = ({ signal }) => getDefects(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefects>>>
export type GetDefectsInfiniteQueryError = ErrorResponse


export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ –¥–µ—Ñ–µ–∫—Ç–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetDefectsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefects>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectsQueryOptions = <TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefects>>> = ({ signal }) => getDefects(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsQueryResult = NonNullable<Awaited<ReturnType<typeof getDefects>>>
export type GetDefectsQueryError = ErrorResponse


export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefects>>,
          TError,
          Awaited<ReturnType<typeof getDefects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ –¥–µ—Ñ–µ–∫—Ç–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetDefects<TData = Awaited<ReturnType<typeof getDefects>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefects>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ñ–µ–∫—Ç–∏ —Ç–∞ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getDefectsAndRisks = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/defects-and-risks`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectsAndRisksQueryKey = () => {
    return [`/item-characteristics/defects-and-risks`] as const;
    }

    
export const getGetDefectsAndRisksInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsAndRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectsAndRisks>>> = ({ signal }) => getDefectsAndRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsAndRisksInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectsAndRisks>>>
export type GetDefectsAndRisksInfiniteQueryError = ErrorResponse


export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ñ–µ–∫—Ç–∏ —Ç–∞ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetDefectsAndRisksInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectsAndRisks>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsAndRisksInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectsAndRisksQueryOptions = <TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectsAndRisksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectsAndRisks>>> = ({ signal }) => getDefectsAndRisks(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectsAndRisksQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectsAndRisks>>>
export type GetDefectsAndRisksQueryError = ErrorResponse


export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectsAndRisks>>,
          TError,
          Awaited<ReturnType<typeof getDefectsAndRisks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–µ—Ñ–µ–∫—Ç–∏ —Ç–∞ —Ä–∏–∑–∏–∫–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetDefectsAndRisks<TData = Awaited<ReturnType<typeof getDefectsAndRisks>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectsAndRisks>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectsAndRisksQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–∑–æ–≤—ñ –∫–æ–ª—å–æ—Ä–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const getColors = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/item-characteristics/colors`, method: 'GET', signal
    },
      options);
    }
  

export const getGetColorsQueryKey = () => {
    return [`/item-characteristics/colors`] as const;
    }

    
export const getGetColorsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetColorsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getColors>>> = ({ signal }) => getColors(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetColorsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getColors>>>
export type GetColorsInfiniteQueryError = ErrorResponse


export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–∑–æ–≤—ñ –∫–æ–ª—å–æ—Ä–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetColorsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getColors>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetColorsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetColorsQueryOptions = <TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetColorsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getColors>>> = ({ signal }) => getColors(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetColorsQueryResult = NonNullable<Awaited<ReturnType<typeof getColors>>>
export type GetColorsQueryError = ErrorResponse


export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getColors>>,
          TError,
          Awaited<ReturnType<typeof getColors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–∑–æ–≤—ñ –∫–æ–ª—å–æ—Ä–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useGetColors<TData = Awaited<ReturnType<typeof getColors>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getColors>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetColorsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–≤–µ—Ä—Ç–∞—î —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º –∫–æ–¥–æ–º
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –∫–æ–¥–æ–º
 */
export const getDefectTypeByCode = (
    code: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<GetDefectTypeByCode200>(
      {url: `/defect-types/by-code/${code}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDefectTypeByCodeQueryKey = (code: string,) => {
    return [`/defect-types/by-code/${code}`] as const;
    }

    
export const getGetDefectTypeByCodeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeByCode>>> = ({ signal }) => getDefectTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByCodeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeByCode>>>
export type GetDefectTypeByCodeInfiniteQueryError = ErrorResponse


export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetDefectTypeByCodeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDefectTypeByCode>>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByCodeInfiniteQueryOptions(code,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDefectTypeByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDefectTypeByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefectTypeByCode>>> = ({ signal }) => getDefectTypeByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDefectTypeByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getDefectTypeByCode>>>
export type GetDefectTypeByCodeQueryError = ErrorResponse


export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefectTypeByCode>>,
          TError,
          Awaited<ReturnType<typeof getDefectTypeByCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Ç–∏–ø –¥–µ—Ñ–µ–∫—Ç—É –∑–∞ –∫–æ–¥–æ–º
 */

export function useGetDefectTypeByCode<TData = Awaited<ReturnType<typeof getDefectTypeByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefectTypeByCode>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDefectTypeByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




