/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * AKSI API
 * API –¥–ª—è —Å–∏—Å—Ç–µ–º–∏ –∫–µ—Ä—É–≤–∞–Ω–Ω—è –∫–ª—ñ–Ω—ñ–Ω–≥–æ–≤–æ—é –∫–æ–º–ø–∞–Ω—ñ—î—é AKSI
 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AdaptersInfo,
  AddModifierRequest,
  AdditionalInfoDTO,
  BasicOrderInfoDTO,
  BranchLocationDTO,
  ClientResponse,
  ClientSearchCriteriaDTO,
  ClientSearchResultDTO,
  CompleteApiMap,
  CustomerSignatureRequest,
  DiscountConfigurationDTO,
  ErrorResponse,
  ExecutionParamsDTO,
  HealthStatus,
  InitializeSubstepRequest,
  ItemBasicInfoDTO,
  ItemCharacteristicsDTO,
  ItemManagerDTO,
  LegalAcceptanceDTO,
  NewClientFormDTO,
  OrderCompletionDTO,
  OrderConfirmationDTO,
  OrderFinalizationRequest,
  OrderItemAddRequest,
  OrderItemDTO,
  OrderWizardGetAvailableTransitions200,
  OrderWizardGetSessionInfo200,
  OrderWizardResponseDTO,
  PaymentConfigurationDTO,
  PhotoDocumentationDTO,
  PriceCalculationResponseDTO,
  PriceDiscountDTO,
  PriceListItemDTO,
  PriceModifierDTO,
  ReceiptConfigurationDTO,
  ReceiptGenerationRequest,
  ServiceCategoryDTO,
  Stage1GenerateReceiptNumberParams,
  Stage1GetBasicOrderState200,
  Stage1GetClientFormState200,
  Stage1GetClientSearchState200,
  Stage1SearchClientsByPhoneParams,
  Stage1SelectBranchParams,
  Stage1SelectClientParams,
  Stage1SetUniqueTagParams,
  Stage1ValidateBasicOrder200,
  Stage1ValidateClientForm200,
  Stage2GetCurrentState200,
  Stage3Context,
  Stage3GetNextSubstep200,
  Stage3GetSessionState200,
  Stage4CloseSession200,
  Stage4FinalizeOrder200,
  Stage4GeneratePdfReceipt200,
  Stage4GenerateReceipt200,
  Stage4GetCurrentState200,
  Stage4GetOrderSummary200,
  Stage4GetSessionContext200,
  Stage4InitializeStage200,
  Stage4SaveSignature200,
  Stage4UpdateLegalAcceptance200,
  Stage4UpdateOrderCompletion200,
  Stage4UpdateOrderConfirmation200,
  Stage4UpdateReceiptConfiguration200,
  Stage4ValidateComplete200,
  Stage4ValidateLegalAcceptance200,
  Stage4ValidateOrderCompletion200,
  Stage4ValidateOrderConfirmation200,
  Stage4ValidateReceiptConfiguration200,
  StageInfo,
  StageMethods,
  StageStatus,
  StagesStatus,
  StainsDefectsContext,
  Substep1EnterQuantityParams,
  Substep1SelectPriceListItemParams,
  Substep1SelectServiceCategoryParams,
  Substep2CompleteSubstep200,
  Substep2InitializeSubstepParams,
  Substep2SelectColorParams,
  Substep2SelectFillerParams,
  Substep2SelectMaterialParams,
  Substep2SelectWearLevelParams,
  Substep3GoBackParams,
  Substep3ProcessDefectNotesParams,
  Substep3ProcessDefectSelectionParams,
  Substep3ProcessStainSelectionParams,
  Substep4GetAvailableEvents200Item,
  Substep4GetAvailableModifiersParams,
  Substep4GetRecommendedModifiersParams,
  Substep5AddPhotoBody,
  SubstepResultDTO,
  SystemStats,
  ValidationResult,
  WorkflowMap
} from './aksiApi.schemas';

import orvalFetcher from '../../../../lib/api/orval-fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é –æ–ø–ª–∞—Ç–∏
 */
export const stage3UpdatePaymentConfig = (
    sessionId: string,
    paymentConfigurationDTO: PaymentConfigurationDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/payment-config`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: paymentConfigurationDTO
    },
      options);
    }
  


export const getStage3UpdatePaymentConfigMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3UpdatePaymentConfig>>, TError,{sessionId: string;data: PaymentConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage3UpdatePaymentConfig>>, TError,{sessionId: string;data: PaymentConfigurationDTO}, TContext> => {

const mutationKey = ['stage3UpdatePaymentConfig'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage3UpdatePaymentConfig>>, {sessionId: string;data: PaymentConfigurationDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage3UpdatePaymentConfig(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage3UpdatePaymentConfigMutationResult = NonNullable<Awaited<ReturnType<typeof stage3UpdatePaymentConfig>>>
    export type Stage3UpdatePaymentConfigMutationBody = PaymentConfigurationDTO
    export type Stage3UpdatePaymentConfigMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é –æ–ø–ª–∞—Ç–∏
 */
export const useStage3UpdatePaymentConfig = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3UpdatePaymentConfig>>, TError,{sessionId: string;data: PaymentConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage3UpdatePaymentConfig>>,
        TError,
        {sessionId: string;data: PaymentConfigurationDTO},
        TContext
      > => {

      const mutationOptions = getStage3UpdatePaymentConfigMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è
 */
export const stage3UpdateExecutionParams = (
    sessionId: string,
    executionParamsDTO: ExecutionParamsDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/execution-params`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: executionParamsDTO
    },
      options);
    }
  


export const getStage3UpdateExecutionParamsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3UpdateExecutionParams>>, TError,{sessionId: string;data: ExecutionParamsDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage3UpdateExecutionParams>>, TError,{sessionId: string;data: ExecutionParamsDTO}, TContext> => {

const mutationKey = ['stage3UpdateExecutionParams'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage3UpdateExecutionParams>>, {sessionId: string;data: ExecutionParamsDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage3UpdateExecutionParams(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage3UpdateExecutionParamsMutationResult = NonNullable<Awaited<ReturnType<typeof stage3UpdateExecutionParams>>>
    export type Stage3UpdateExecutionParamsMutationBody = ExecutionParamsDTO
    export type Stage3UpdateExecutionParamsMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è
 */
export const useStage3UpdateExecutionParams = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3UpdateExecutionParams>>, TError,{sessionId: string;data: ExecutionParamsDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage3UpdateExecutionParams>>,
        TError,
        {sessionId: string;data: ExecutionParamsDTO},
        TContext
      > => {

      const mutationOptions = getStage3UpdateExecutionParamsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é –∑–Ω–∏–∂–æ–∫
 */
export const stage3UpdateDiscountConfig = (
    sessionId: string,
    discountConfigurationDTO: DiscountConfigurationDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/discount-config`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: discountConfigurationDTO
    },
      options);
    }
  


export const getStage3UpdateDiscountConfigMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3UpdateDiscountConfig>>, TError,{sessionId: string;data: DiscountConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage3UpdateDiscountConfig>>, TError,{sessionId: string;data: DiscountConfigurationDTO}, TContext> => {

const mutationKey = ['stage3UpdateDiscountConfig'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage3UpdateDiscountConfig>>, {sessionId: string;data: DiscountConfigurationDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage3UpdateDiscountConfig(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage3UpdateDiscountConfigMutationResult = NonNullable<Awaited<ReturnType<typeof stage3UpdateDiscountConfig>>>
    export type Stage3UpdateDiscountConfigMutationBody = DiscountConfigurationDTO
    export type Stage3UpdateDiscountConfigMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é –∑–Ω–∏–∂–æ–∫
 */
export const useStage3UpdateDiscountConfig = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3UpdateDiscountConfig>>, TError,{sessionId: string;data: DiscountConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage3UpdateDiscountConfig>>,
        TError,
        {sessionId: string;data: DiscountConfigurationDTO},
        TContext
      > => {

      const mutationOptions = getStage3UpdateDiscountConfigMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –¥–æ–¥–∞—Ç–∫–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
 */
export const stage3UpdateAdditionalInfo = (
    sessionId: string,
    additionalInfoDTO: AdditionalInfoDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/additional-info`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: additionalInfoDTO
    },
      options);
    }
  


export const getStage3UpdateAdditionalInfoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3UpdateAdditionalInfo>>, TError,{sessionId: string;data: AdditionalInfoDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage3UpdateAdditionalInfo>>, TError,{sessionId: string;data: AdditionalInfoDTO}, TContext> => {

const mutationKey = ['stage3UpdateAdditionalInfo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage3UpdateAdditionalInfo>>, {sessionId: string;data: AdditionalInfoDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage3UpdateAdditionalInfo(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage3UpdateAdditionalInfoMutationResult = NonNullable<Awaited<ReturnType<typeof stage3UpdateAdditionalInfo>>>
    export type Stage3UpdateAdditionalInfoMutationBody = AdditionalInfoDTO
    export type Stage3UpdateAdditionalInfoMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–∏—Ç–∏ –¥–æ–¥–∞—Ç–∫–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
 */
export const useStage3UpdateAdditionalInfo = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3UpdateAdditionalInfo>>, TError,{sessionId: string;data: AdditionalInfoDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage3UpdateAdditionalInfo>>,
        TError,
        {sessionId: string;data: AdditionalInfoDTO},
        TContext
      > => {

      const mutationOptions = getStage3UpdateAdditionalInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–Ω–æ–≤–ª—é—î —ñ—Å–Ω—É—é—á–∏–π –ø—Ä–µ–¥–º–µ—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è (–∑ –ø—ñ–¥–≤—ñ–∑–∞—Ä–¥–∞)
 */
export const stage2UpdateItemInOrder = (
    sessionId: string,
    itemId: string,
    orderItemDTO: OrderItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/items/${sessionId}/${itemId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: orderItemDTO
    },
      options);
    }
  


export const getStage2UpdateItemInOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2UpdateItemInOrder>>, TError,{sessionId: string;itemId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage2UpdateItemInOrder>>, TError,{sessionId: string;itemId: string;data: OrderItemDTO}, TContext> => {

const mutationKey = ['stage2UpdateItemInOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage2UpdateItemInOrder>>, {sessionId: string;itemId: string;data: OrderItemDTO}> = (props) => {
          const {sessionId,itemId,data} = props ?? {};

          return  stage2UpdateItemInOrder(sessionId,itemId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage2UpdateItemInOrderMutationResult = NonNullable<Awaited<ReturnType<typeof stage2UpdateItemInOrder>>>
    export type Stage2UpdateItemInOrderMutationBody = OrderItemDTO
    export type Stage2UpdateItemInOrderMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–ª—é—î —ñ—Å–Ω—É—é—á–∏–π –ø—Ä–µ–¥–º–µ—Ç –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è (–∑ –ø—ñ–¥–≤—ñ–∑–∞—Ä–¥–∞)
 */
export const useStage2UpdateItemInOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2UpdateItemInOrder>>, TError,{sessionId: string;itemId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage2UpdateItemInOrder>>,
        TError,
        {sessionId: string;itemId: string;data: OrderItemDTO},
        TContext
      > => {

      const mutationOptions = getStage2UpdateItemInOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–¥–∞–ª—è—î –ø—Ä–µ–¥–º–µ—Ç –∑ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const stage2DeleteItemFromOrder = (
    sessionId: string,
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/items/${sessionId}/${itemId}`, method: 'DELETE'
    },
      options);
    }
  


export const getStage2DeleteItemFromOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2DeleteItemFromOrder>>, TError,{sessionId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage2DeleteItemFromOrder>>, TError,{sessionId: string;itemId: string}, TContext> => {

const mutationKey = ['stage2DeleteItemFromOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage2DeleteItemFromOrder>>, {sessionId: string;itemId: string}> = (props) => {
          const {sessionId,itemId} = props ?? {};

          return  stage2DeleteItemFromOrder(sessionId,itemId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage2DeleteItemFromOrderMutationResult = NonNullable<Awaited<ReturnType<typeof stage2DeleteItemFromOrder>>>
    
    export type Stage2DeleteItemFromOrderMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª—è—î –ø—Ä–µ–¥–º–µ—Ç –∑ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useStage2DeleteItemFromOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2DeleteItemFromOrder>>, TError,{sessionId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage2DeleteItemFromOrder>>,
        TError,
        {sessionId: string;itemId: string},
        TContext
      > => {

      const mutationOptions = getStage2DeleteItemFromOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω—ñ –¥–∞–Ω—ñ —Ñ–æ—Ä–º–∏
 */
export const stage1GetClientFormData = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<NewClientFormDTO>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/data`, method: 'GET', signal
    },
      options);
    }
  

export const getStage1GetClientFormDataQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/new-client/session/${sessionId}/data`] as const;
    }

    
export const getStage1GetClientFormDataInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientFormData>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetClientFormDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetClientFormData>>> = ({ signal }) => stage1GetClientFormData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetClientFormDataInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetClientFormData>>>
export type Stage1GetClientFormDataInfiniteQueryError = ErrorResponse


export function useStage1GetClientFormDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientFormData>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientFormData>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientFormData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientFormDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientFormData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientFormData>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientFormData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientFormDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientFormData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω—ñ –¥–∞–Ω—ñ —Ñ–æ—Ä–º–∏
 */

export function useStage1GetClientFormDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientFormData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetClientFormDataInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage1GetClientFormDataQueryOptions = <TData = Awaited<ReturnType<typeof stage1GetClientFormData>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetClientFormDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetClientFormData>>> = ({ signal }) => stage1GetClientFormData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetClientFormDataQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetClientFormData>>>
export type Stage1GetClientFormDataQueryError = ErrorResponse


export function useStage1GetClientFormData<TData = Awaited<ReturnType<typeof stage1GetClientFormData>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientFormData>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientFormData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientFormData<TData = Awaited<ReturnType<typeof stage1GetClientFormData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientFormData>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientFormData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientFormData<TData = Awaited<ReturnType<typeof stage1GetClientFormData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω—ñ –¥–∞–Ω—ñ —Ñ–æ—Ä–º–∏
 */

export function useStage1GetClientFormData<TData = Awaited<ReturnType<typeof stage1GetClientFormData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetClientFormDataQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û–Ω–æ–≤–ª—é—î –¥–∞–Ω—ñ —Ñ–æ—Ä–º–∏ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const stage1UpdateClientData = (
    sessionId: string,
    newClientFormDTO: NewClientFormDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/data`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: newClientFormDTO
    },
      options);
    }
  


export const getStage1UpdateClientDataMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1UpdateClientData>>, TError,{sessionId: string;data: NewClientFormDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1UpdateClientData>>, TError,{sessionId: string;data: NewClientFormDTO}, TContext> => {

const mutationKey = ['stage1UpdateClientData'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1UpdateClientData>>, {sessionId: string;data: NewClientFormDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage1UpdateClientData(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1UpdateClientDataMutationResult = NonNullable<Awaited<ReturnType<typeof stage1UpdateClientData>>>
    export type Stage1UpdateClientDataMutationBody = NewClientFormDTO
    export type Stage1UpdateClientDataMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–ª—é—î –¥–∞–Ω—ñ —Ñ–æ—Ä–º–∏ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useStage1UpdateClientData = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1UpdateClientData>>, TError,{sessionId: string;data: NewClientFormDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1UpdateClientData>>,
        TError,
        {sessionId: string;data: NewClientFormDTO},
        TContext
      > => {

      const mutationOptions = getStage1UpdateClientDataMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω—É –±–∞–∑–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
 */
export const stage1GetBasicOrderData = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<BasicOrderInfoDTO>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/data`, method: 'GET', signal
    },
      options);
    }
  

export const getStage1GetBasicOrderDataQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/basic-order/session/${sessionId}/data`] as const;
    }

    
export const getStage1GetBasicOrderDataInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBasicOrderData>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetBasicOrderDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetBasicOrderData>>> = ({ signal }) => stage1GetBasicOrderData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetBasicOrderDataInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetBasicOrderData>>>
export type Stage1GetBasicOrderDataInfiniteQueryError = ErrorResponse


export function useStage1GetBasicOrderDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBasicOrderData>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBasicOrderData>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBasicOrderData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBasicOrderDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBasicOrderData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBasicOrderData>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBasicOrderData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBasicOrderDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBasicOrderData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω—É –±–∞–∑–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
 */

export function useStage1GetBasicOrderDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBasicOrderData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetBasicOrderDataInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage1GetBasicOrderDataQueryOptions = <TData = Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetBasicOrderDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetBasicOrderData>>> = ({ signal }) => stage1GetBasicOrderData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetBasicOrderDataQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetBasicOrderData>>>
export type Stage1GetBasicOrderDataQueryError = ErrorResponse


export function useStage1GetBasicOrderData<TData = Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBasicOrderData>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBasicOrderData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBasicOrderData<TData = Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBasicOrderData>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBasicOrderData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBasicOrderData<TData = Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω—É –±–∞–∑–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
 */

export function useStage1GetBasicOrderData<TData = Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetBasicOrderDataQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û–Ω–æ–≤–ª—é—î –±–∞–∑–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
 */
export const stage1UpdateBasicOrder = (
    sessionId: string,
    basicOrderInfoDTO: BasicOrderInfoDTO,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/data`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: basicOrderInfoDTO
    },
      options);
    }
  


export const getStage1UpdateBasicOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1UpdateBasicOrder>>, TError,{sessionId: string;data: BasicOrderInfoDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1UpdateBasicOrder>>, TError,{sessionId: string;data: BasicOrderInfoDTO}, TContext> => {

const mutationKey = ['stage1UpdateBasicOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1UpdateBasicOrder>>, {sessionId: string;data: BasicOrderInfoDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage1UpdateBasicOrder(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1UpdateBasicOrderMutationResult = NonNullable<Awaited<ReturnType<typeof stage1UpdateBasicOrder>>>
    export type Stage1UpdateBasicOrderMutationBody = BasicOrderInfoDTO
    export type Stage1UpdateBasicOrderMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–ª—é—î –±–∞–∑–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
 */
export const useStage1UpdateBasicOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1UpdateBasicOrder>>, TError,{sessionId: string;data: BasicOrderInfoDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1UpdateBasicOrder>>,
        TError,
        {sessionId: string;data: BasicOrderInfoDTO},
        TContext
      > => {

      const mutationOptions = getStage1UpdateBasicOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */
export const stage4ValidateReceiptConfiguration = (
    receiptConfigurationDTO: ReceiptConfigurationDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4ValidateReceiptConfiguration200>(
      {url: `/v1/order-wizard/stage4/validate/receipt-configuration`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: receiptConfigurationDTO, signal
    },
      options);
    }
  


export const getStage4ValidateReceiptConfigurationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateReceiptConfiguration>>, TError,{data: ReceiptConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateReceiptConfiguration>>, TError,{data: ReceiptConfigurationDTO}, TContext> => {

const mutationKey = ['stage4ValidateReceiptConfiguration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4ValidateReceiptConfiguration>>, {data: ReceiptConfigurationDTO}> = (props) => {
          const {data} = props ?? {};

          return  stage4ValidateReceiptConfiguration(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4ValidateReceiptConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof stage4ValidateReceiptConfiguration>>>
    export type Stage4ValidateReceiptConfigurationMutationBody = ReceiptConfigurationDTO
    export type Stage4ValidateReceiptConfigurationMutationError = ErrorResponse

    /**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */
export const useStage4ValidateReceiptConfiguration = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateReceiptConfiguration>>, TError,{data: ReceiptConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4ValidateReceiptConfiguration>>,
        TError,
        {data: ReceiptConfigurationDTO},
        TContext
      > => {

      const mutationOptions = getStage4ValidateReceiptConfigurationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const stage4ValidateOrderConfirmation = (
    orderConfirmationDTO: OrderConfirmationDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4ValidateOrderConfirmation200>(
      {url: `/v1/order-wizard/stage4/validate/order-confirmation`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderConfirmationDTO, signal
    },
      options);
    }
  


export const getStage4ValidateOrderConfirmationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateOrderConfirmation>>, TError,{data: OrderConfirmationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateOrderConfirmation>>, TError,{data: OrderConfirmationDTO}, TContext> => {

const mutationKey = ['stage4ValidateOrderConfirmation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4ValidateOrderConfirmation>>, {data: OrderConfirmationDTO}> = (props) => {
          const {data} = props ?? {};

          return  stage4ValidateOrderConfirmation(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4ValidateOrderConfirmationMutationResult = NonNullable<Awaited<ReturnType<typeof stage4ValidateOrderConfirmation>>>
    export type Stage4ValidateOrderConfirmationMutationBody = OrderConfirmationDTO
    export type Stage4ValidateOrderConfirmationMutationError = ErrorResponse

    /**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useStage4ValidateOrderConfirmation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateOrderConfirmation>>, TError,{data: OrderConfirmationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4ValidateOrderConfirmation>>,
        TError,
        {data: OrderConfirmationDTO},
        TContext
      > => {

      const mutationOptions = getStage4ValidateOrderConfirmationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const stage4ValidateOrderCompletion = (
    orderCompletionDTO: OrderCompletionDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4ValidateOrderCompletion200>(
      {url: `/v1/order-wizard/stage4/validate/order-completion`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderCompletionDTO, signal
    },
      options);
    }
  


export const getStage4ValidateOrderCompletionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateOrderCompletion>>, TError,{data: OrderCompletionDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateOrderCompletion>>, TError,{data: OrderCompletionDTO}, TContext> => {

const mutationKey = ['stage4ValidateOrderCompletion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4ValidateOrderCompletion>>, {data: OrderCompletionDTO}> = (props) => {
          const {data} = props ?? {};

          return  stage4ValidateOrderCompletion(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4ValidateOrderCompletionMutationResult = NonNullable<Awaited<ReturnType<typeof stage4ValidateOrderCompletion>>>
    export type Stage4ValidateOrderCompletionMutationBody = OrderCompletionDTO
    export type Stage4ValidateOrderCompletionMutationError = ErrorResponse

    /**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useStage4ValidateOrderCompletion = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateOrderCompletion>>, TError,{data: OrderCompletionDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4ValidateOrderCompletion>>,
        TError,
        {data: OrderCompletionDTO},
        TContext
      > => {

      const mutationOptions = getStage4ValidateOrderCompletionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è —é—Ä–∏–¥–∏—á–Ω–æ–≥–æ –ø—Ä–∏–π–Ω—è—Ç—Ç—è
 */
export const stage4ValidateLegalAcceptance = (
    legalAcceptanceDTO: LegalAcceptanceDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4ValidateLegalAcceptance200>(
      {url: `/v1/order-wizard/stage4/validate/legal-acceptance`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: legalAcceptanceDTO, signal
    },
      options);
    }
  


export const getStage4ValidateLegalAcceptanceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateLegalAcceptance>>, TError,{data: LegalAcceptanceDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateLegalAcceptance>>, TError,{data: LegalAcceptanceDTO}, TContext> => {

const mutationKey = ['stage4ValidateLegalAcceptance'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4ValidateLegalAcceptance>>, {data: LegalAcceptanceDTO}> = (props) => {
          const {data} = props ?? {};

          return  stage4ValidateLegalAcceptance(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4ValidateLegalAcceptanceMutationResult = NonNullable<Awaited<ReturnType<typeof stage4ValidateLegalAcceptance>>>
    export type Stage4ValidateLegalAcceptanceMutationBody = LegalAcceptanceDTO
    export type Stage4ValidateLegalAcceptanceMutationError = ErrorResponse

    /**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è —é—Ä–∏–¥–∏—á–Ω–æ–≥–æ –ø—Ä–∏–π–Ω—è—Ç—Ç—è
 */
export const useStage4ValidateLegalAcceptance = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4ValidateLegalAcceptance>>, TError,{data: LegalAcceptanceDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4ValidateLegalAcceptance>>,
        TError,
        {data: LegalAcceptanceDTO},
        TContext
      > => {

      const mutationOptions = getStage4ValidateLegalAcceptanceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –ø—ñ–¥–ø–∏—Å—É –∫–ª—ñ—î–Ω—Ç–∞
 */
export const stage4SaveSignature = (
    customerSignatureRequest: CustomerSignatureRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4SaveSignature200>(
      {url: `/v1/order-wizard/stage4/signature/save`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: customerSignatureRequest, signal
    },
      options);
    }
  


export const getStage4SaveSignatureMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4SaveSignature>>, TError,{data: CustomerSignatureRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4SaveSignature>>, TError,{data: CustomerSignatureRequest}, TContext> => {

const mutationKey = ['stage4SaveSignature'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4SaveSignature>>, {data: CustomerSignatureRequest}> = (props) => {
          const {data} = props ?? {};

          return  stage4SaveSignature(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4SaveSignatureMutationResult = NonNullable<Awaited<ReturnType<typeof stage4SaveSignature>>>
    export type Stage4SaveSignatureMutationBody = CustomerSignatureRequest
    export type Stage4SaveSignatureMutationError = ErrorResponse

    /**
 * @summary –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –ø—ñ–¥–ø–∏—Å—É –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useStage4SaveSignature = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4SaveSignature>>, TError,{data: CustomerSignatureRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4SaveSignature>>,
        TError,
        {data: CustomerSignatureRequest},
        TContext
      > => {

      const mutationOptions = getStage4SaveSignatureMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–Ω–æ–≤–ª–µ–Ω–Ω—è –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */
export const stage4UpdateReceiptConfiguration = (
    sessionId: string,
    receiptConfigurationDTO: ReceiptConfigurationDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4UpdateReceiptConfiguration200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/receipt-configuration`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: receiptConfigurationDTO, signal
    },
      options);
    }
  


export const getStage4UpdateReceiptConfigurationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateReceiptConfiguration>>, TError,{sessionId: string;data: ReceiptConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateReceiptConfiguration>>, TError,{sessionId: string;data: ReceiptConfigurationDTO}, TContext> => {

const mutationKey = ['stage4UpdateReceiptConfiguration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4UpdateReceiptConfiguration>>, {sessionId: string;data: ReceiptConfigurationDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage4UpdateReceiptConfiguration(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4UpdateReceiptConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof stage4UpdateReceiptConfiguration>>>
    export type Stage4UpdateReceiptConfigurationMutationBody = ReceiptConfigurationDTO
    export type Stage4UpdateReceiptConfigurationMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–ª–µ–Ω–Ω—è –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */
export const useStage4UpdateReceiptConfiguration = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateReceiptConfiguration>>, TError,{sessionId: string;data: ReceiptConfigurationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4UpdateReceiptConfiguration>>,
        TError,
        {sessionId: string;data: ReceiptConfigurationDTO},
        TContext
      > => {

      const mutationOptions = getStage4UpdateReceiptConfigurationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const stage4UpdateOrderConfirmation = (
    sessionId: string,
    orderConfirmationDTO: OrderConfirmationDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4UpdateOrderConfirmation200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/order-confirmation`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderConfirmationDTO, signal
    },
      options);
    }
  


export const getStage4UpdateOrderConfirmationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateOrderConfirmation>>, TError,{sessionId: string;data: OrderConfirmationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateOrderConfirmation>>, TError,{sessionId: string;data: OrderConfirmationDTO}, TContext> => {

const mutationKey = ['stage4UpdateOrderConfirmation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4UpdateOrderConfirmation>>, {sessionId: string;data: OrderConfirmationDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage4UpdateOrderConfirmation(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4UpdateOrderConfirmationMutationResult = NonNullable<Awaited<ReturnType<typeof stage4UpdateOrderConfirmation>>>
    export type Stage4UpdateOrderConfirmationMutationBody = OrderConfirmationDTO
    export type Stage4UpdateOrderConfirmationMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useStage4UpdateOrderConfirmation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateOrderConfirmation>>, TError,{sessionId: string;data: OrderConfirmationDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4UpdateOrderConfirmation>>,
        TError,
        {sessionId: string;data: OrderConfirmationDTO},
        TContext
      > => {

      const mutationOptions = getStage4UpdateOrderConfirmationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–Ω–æ–≤–ª–µ–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const stage4UpdateOrderCompletion = (
    sessionId: string,
    orderCompletionDTO: OrderCompletionDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4UpdateOrderCompletion200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/order-completion`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderCompletionDTO, signal
    },
      options);
    }
  


export const getStage4UpdateOrderCompletionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateOrderCompletion>>, TError,{sessionId: string;data: OrderCompletionDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateOrderCompletion>>, TError,{sessionId: string;data: OrderCompletionDTO}, TContext> => {

const mutationKey = ['stage4UpdateOrderCompletion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4UpdateOrderCompletion>>, {sessionId: string;data: OrderCompletionDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage4UpdateOrderCompletion(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4UpdateOrderCompletionMutationResult = NonNullable<Awaited<ReturnType<typeof stage4UpdateOrderCompletion>>>
    export type Stage4UpdateOrderCompletionMutationBody = OrderCompletionDTO
    export type Stage4UpdateOrderCompletionMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–ª–µ–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useStage4UpdateOrderCompletion = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateOrderCompletion>>, TError,{sessionId: string;data: OrderCompletionDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4UpdateOrderCompletion>>,
        TError,
        {sessionId: string;data: OrderCompletionDTO},
        TContext
      > => {

      const mutationOptions = getStage4UpdateOrderCompletionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–Ω–æ–≤–ª–µ–Ω–Ω—è —é—Ä–∏–¥–∏—á–Ω–æ–≥–æ –ø—Ä–∏–π–Ω—è—Ç—Ç—è
 */
export const stage4UpdateLegalAcceptance = (
    sessionId: string,
    legalAcceptanceDTO: LegalAcceptanceDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4UpdateLegalAcceptance200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/legal-acceptance`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: legalAcceptanceDTO, signal
    },
      options);
    }
  


export const getStage4UpdateLegalAcceptanceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateLegalAcceptance>>, TError,{sessionId: string;data: LegalAcceptanceDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateLegalAcceptance>>, TError,{sessionId: string;data: LegalAcceptanceDTO}, TContext> => {

const mutationKey = ['stage4UpdateLegalAcceptance'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4UpdateLegalAcceptance>>, {sessionId: string;data: LegalAcceptanceDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage4UpdateLegalAcceptance(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4UpdateLegalAcceptanceMutationResult = NonNullable<Awaited<ReturnType<typeof stage4UpdateLegalAcceptance>>>
    export type Stage4UpdateLegalAcceptanceMutationBody = LegalAcceptanceDTO
    export type Stage4UpdateLegalAcceptanceMutationError = ErrorResponse

    /**
 * @summary –û–Ω–æ–≤–ª–µ–Ω–Ω—è —é—Ä–∏–¥–∏—á–Ω–æ–≥–æ –ø—Ä–∏–π–Ω—è—Ç—Ç—è
 */
export const useStage4UpdateLegalAcceptance = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4UpdateLegalAcceptance>>, TError,{sessionId: string;data: LegalAcceptanceDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4UpdateLegalAcceptance>>,
        TError,
        {sessionId: string;data: LegalAcceptanceDTO},
        TContext
      > => {

      const mutationOptions = getStage4UpdateLegalAcceptanceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–∫—Ä–∏—Ç—Ç—è —Å–µ—Å—ñ—ó
 */
export const stage4CloseSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4CloseSession200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/close`, method: 'POST', signal
    },
      options);
    }
  


export const getStage4CloseSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4CloseSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4CloseSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage4CloseSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4CloseSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage4CloseSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4CloseSessionMutationResult = NonNullable<Awaited<ReturnType<typeof stage4CloseSession>>>
    
    export type Stage4CloseSessionMutationError = ErrorResponse

    /**
 * @summary –ó–∞–∫—Ä–∏—Ç—Ç—è —Å–µ—Å—ñ—ó
 */
export const useStage4CloseSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4CloseSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4CloseSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage4CloseSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */
export const stage4GenerateReceipt = (
    receiptGenerationRequest: ReceiptGenerationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4GenerateReceipt200>(
      {url: `/v1/order-wizard/stage4/receipt/generate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: receiptGenerationRequest, signal
    },
      options);
    }
  


export const getStage4GenerateReceiptMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4GenerateReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4GenerateReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext> => {

const mutationKey = ['stage4GenerateReceipt'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4GenerateReceipt>>, {data: ReceiptGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  stage4GenerateReceipt(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4GenerateReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof stage4GenerateReceipt>>>
    export type Stage4GenerateReceiptMutationBody = ReceiptGenerationRequest
    export type Stage4GenerateReceiptMutationError = ErrorResponse

    /**
 * @summary –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */
export const useStage4GenerateReceipt = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4GenerateReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4GenerateReceipt>>,
        TError,
        {data: ReceiptGenerationRequest},
        TContext
      > => {

      const mutationOptions = getStage4GenerateReceiptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è PDF –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */
export const stage4GeneratePdfReceipt = (
    receiptGenerationRequest: ReceiptGenerationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4GeneratePdfReceipt200>(
      {url: `/v1/order-wizard/stage4/receipt/generate-pdf`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: receiptGenerationRequest, signal
    },
      options);
    }
  


export const getStage4GeneratePdfReceiptMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4GeneratePdfReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4GeneratePdfReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext> => {

const mutationKey = ['stage4GeneratePdfReceipt'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4GeneratePdfReceipt>>, {data: ReceiptGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  stage4GeneratePdfReceipt(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4GeneratePdfReceiptMutationResult = NonNullable<Awaited<ReturnType<typeof stage4GeneratePdfReceipt>>>
    export type Stage4GeneratePdfReceiptMutationBody = ReceiptGenerationRequest
    export type Stage4GeneratePdfReceiptMutationError = ErrorResponse

    /**
 * @summary –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è PDF –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */
export const useStage4GeneratePdfReceipt = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4GeneratePdfReceipt>>, TError,{data: ReceiptGenerationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4GeneratePdfReceipt>>,
        TError,
        {data: ReceiptGenerationRequest},
        TContext
      > => {

      const mutationOptions = getStage4GeneratePdfReceiptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è Stage4 –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const stage4InitializeStage = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4InitializeStage200>(
      {url: `/v1/order-wizard/stage4/initialize/${orderId}`, method: 'POST', signal
    },
      options);
    }
  


export const getStage4InitializeStageMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4InitializeStage>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4InitializeStage>>, TError,{orderId: string}, TContext> => {

const mutationKey = ['stage4InitializeStage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4InitializeStage>>, {orderId: string}> = (props) => {
          const {orderId} = props ?? {};

          return  stage4InitializeStage(orderId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4InitializeStageMutationResult = NonNullable<Awaited<ReturnType<typeof stage4InitializeStage>>>
    
    export type Stage4InitializeStageMutationError = ErrorResponse

    /**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è Stage4 –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useStage4InitializeStage = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4InitializeStage>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4InitializeStage>>,
        TError,
        {orderId: string},
        TContext
      > => {

      const mutationOptions = getStage4InitializeStageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –§—ñ–Ω–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const stage4FinalizeOrder = (
    orderFinalizationRequest: OrderFinalizationRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4FinalizeOrder200>(
      {url: `/v1/order-wizard/stage4/finalize`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderFinalizationRequest, signal
    },
      options);
    }
  


export const getStage4FinalizeOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4FinalizeOrder>>, TError,{data: OrderFinalizationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage4FinalizeOrder>>, TError,{data: OrderFinalizationRequest}, TContext> => {

const mutationKey = ['stage4FinalizeOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage4FinalizeOrder>>, {data: OrderFinalizationRequest}> = (props) => {
          const {data} = props ?? {};

          return  stage4FinalizeOrder(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage4FinalizeOrderMutationResult = NonNullable<Awaited<ReturnType<typeof stage4FinalizeOrder>>>
    export type Stage4FinalizeOrderMutationBody = OrderFinalizationRequest
    export type Stage4FinalizeOrderMutationError = ErrorResponse

    /**
 * @summary –§—ñ–Ω–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useStage4FinalizeOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage4FinalizeOrder>>, TError,{data: OrderFinalizationRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage4FinalizeOrder>>,
        TError,
        {data: OrderFinalizationRequest},
        TContext
      > => {

      const mutationOptions = getStage4FinalizeOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤—É —Å–µ—Å—ñ—é Stage3
 */
export const stage3CreateSession = (
    stage3CreateSessionBody: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage3/sessions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: stage3CreateSessionBody, signal
    },
      options);
    }
  


export const getStage3CreateSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3CreateSession>>, TError,{data: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage3CreateSession>>, TError,{data: string}, TContext> => {

const mutationKey = ['stage3CreateSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage3CreateSession>>, {data: string}> = (props) => {
          const {data} = props ?? {};

          return  stage3CreateSession(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage3CreateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof stage3CreateSession>>>
    export type Stage3CreateSessionMutationBody = string
    export type Stage3CreateSessionMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤—É —Å–µ—Å—ñ—é Stage3
 */
export const useStage3CreateSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3CreateSession>>, TError,{data: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage3CreateSession>>,
        TError,
        {data: string},
        TContext
      > => {

      const mutationOptions = getStage3CreateSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ Stage3 –¥–ª—è —Å–µ—Å—ñ—ó
 */
export const stage3InitializeStage = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/initialize`, method: 'POST', signal
    },
      options);
    }
  


export const getStage3InitializeStageMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3InitializeStage>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage3InitializeStage>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage3InitializeStage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage3InitializeStage>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage3InitializeStage(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage3InitializeStageMutationResult = NonNullable<Awaited<ReturnType<typeof stage3InitializeStage>>>
    
    export type Stage3InitializeStageMutationError = ErrorResponse

    /**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ Stage3 –¥–ª—è —Å–µ—Å—ñ—ó
 */
export const useStage3InitializeStage = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3InitializeStage>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage3InitializeStage>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage3InitializeStageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–∫—Ä–∏—Ç–∏ —Å–µ—Å—ñ—é
 */
export const stage3CloseSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/close`, method: 'POST', signal
    },
      options);
    }
  


export const getStage3CloseSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3CloseSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage3CloseSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage3CloseSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage3CloseSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage3CloseSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage3CloseSessionMutationResult = NonNullable<Awaited<ReturnType<typeof stage3CloseSession>>>
    
    export type Stage3CloseSessionMutationError = ErrorResponse

    /**
 * @summary –ó–∞–∫—Ä–∏—Ç–∏ —Å–µ—Å—ñ—é
 */
export const useStage3CloseSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage3CloseSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage3CloseSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage3CloseSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–ø—É—Å–∫–∞—î –Ω–æ–≤–∏–π –ø—ñ–¥–≤—ñ–∑–∞—Ä–¥ –¥–æ–¥–∞–≤–∞–Ω–Ω—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const stage2StartNewItemWizard = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/wizard/new/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getStage2StartNewItemWizardMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2StartNewItemWizard>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage2StartNewItemWizard>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage2StartNewItemWizard'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage2StartNewItemWizard>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage2StartNewItemWizard(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage2StartNewItemWizardMutationResult = NonNullable<Awaited<ReturnType<typeof stage2StartNewItemWizard>>>
    
    export type Stage2StartNewItemWizardMutationError = ErrorResponse

    /**
 * @summary –ó–∞–ø—É—Å–∫–∞—î –Ω–æ–≤–∏–π –ø—ñ–¥–≤—ñ–∑–∞—Ä–¥ –¥–æ–¥–∞–≤–∞–Ω–Ω—è –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const useStage2StartNewItemWizard = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2StartNewItemWizard>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage2StartNewItemWizard>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage2StartNewItemWizardMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–ø—É—Å–∫–∞—î –ø—ñ–¥–≤—ñ–∑–∞—Ä–¥ —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è —ñ—Å–Ω—É—é—á–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const stage2StartEditItemWizard = (
    sessionId: string,
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/wizard/edit/${sessionId}/${itemId}`, method: 'POST', signal
    },
      options);
    }
  


export const getStage2StartEditItemWizardMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2StartEditItemWizard>>, TError,{sessionId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage2StartEditItemWizard>>, TError,{sessionId: string;itemId: string}, TContext> => {

const mutationKey = ['stage2StartEditItemWizard'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage2StartEditItemWizard>>, {sessionId: string;itemId: string}> = (props) => {
          const {sessionId,itemId} = props ?? {};

          return  stage2StartEditItemWizard(sessionId,itemId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage2StartEditItemWizardMutationResult = NonNullable<Awaited<ReturnType<typeof stage2StartEditItemWizard>>>
    
    export type Stage2StartEditItemWizardMutationError = ErrorResponse

    /**
 * @summary –ó–∞–ø—É—Å–∫–∞—î –ø—ñ–¥–≤—ñ–∑–∞—Ä–¥ —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è —ñ—Å–Ω—É—é—á–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const useStage2StartEditItemWizard = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2StartEditItemWizard>>, TError,{sessionId: string;itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage2StartEditItemWizard>>,
        TError,
        {sessionId: string;itemId: string},
        TContext
      > => {

      const mutationOptions = getStage2StartEditItemWizardMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–∫—Ä–∏–≤–∞—î –∞–∫—Ç–∏–≤–Ω–∏–π –ø—ñ–¥–≤—ñ–∑–∞—Ä–¥ –±–µ–∑ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
 */
export const stage2CloseWizard = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/wizard/close/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getStage2CloseWizardMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2CloseWizard>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage2CloseWizard>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage2CloseWizard'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage2CloseWizard>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage2CloseWizard(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage2CloseWizardMutationResult = NonNullable<Awaited<ReturnType<typeof stage2CloseWizard>>>
    
    export type Stage2CloseWizardMutationError = ErrorResponse

    /**
 * @summary –ó–∞–∫—Ä–∏–≤–∞—î –∞–∫—Ç–∏–≤–Ω–∏–π –ø—ñ–¥–≤—ñ–∑–∞—Ä–¥ –±–µ–∑ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
 */
export const useStage2CloseWizard = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2CloseWizard>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage2CloseWizard>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage2CloseWizardMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑—É—î —Å—Ç–∞–Ω –º–µ–Ω–µ–¥–∂–µ—Ä–∞
 */
export const stage2SynchronizeManager = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/synchronize/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getStage2SynchronizeManagerMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2SynchronizeManager>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage2SynchronizeManager>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage2SynchronizeManager'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage2SynchronizeManager>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage2SynchronizeManager(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage2SynchronizeManagerMutationResult = NonNullable<Awaited<ReturnType<typeof stage2SynchronizeManager>>>
    
    export type Stage2SynchronizeManagerMutationError = ErrorResponse

    /**
 * @summary –°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑—É—î —Å—Ç–∞–Ω –º–µ–Ω–µ–¥–∂–µ—Ä–∞
 */
export const useStage2SynchronizeManager = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2SynchronizeManager>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage2SynchronizeManager>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage2SynchronizeManagerMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –î–æ–¥–∞–≤–∞–Ω–Ω—è —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—ó
 */
export const substep5AddPhoto = (
    sessionId: string,
    substep5AddPhotoBody: Substep5AddPhotoBody,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}/photos`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: substep5AddPhotoBody, signal
    },
      options);
    }
  


export const getSubstep5AddPhotoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep5AddPhoto>>, TError,{sessionId: string;data: Substep5AddPhotoBody}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep5AddPhoto>>, TError,{sessionId: string;data: Substep5AddPhotoBody}, TContext> => {

const mutationKey = ['substep5AddPhoto'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep5AddPhoto>>, {sessionId: string;data: Substep5AddPhotoBody}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  substep5AddPhoto(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep5AddPhotoMutationResult = NonNullable<Awaited<ReturnType<typeof substep5AddPhoto>>>
    export type Substep5AddPhotoMutationBody = Substep5AddPhotoBody
    export type Substep5AddPhotoMutationError = ErrorResponse

    /**
 * @summary –î–æ–¥–∞–≤–∞–Ω–Ω—è —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—ó
 */
export const useSubstep5AddPhoto = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep5AddPhoto>>, TError,{sessionId: string;data: Substep5AddPhotoBody}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep5AddPhoto>>,
        TError,
        {sessionId: string;data: Substep5AddPhotoBody},
        TContext
      > => {

      const mutationOptions = getSubstep5AddPhotoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Ñ–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
 */
export const substep5CompletePhotoDocumentation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep5CompletePhotoDocumentationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep5CompletePhotoDocumentation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep5CompletePhotoDocumentation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep5CompletePhotoDocumentation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep5CompletePhotoDocumentation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep5CompletePhotoDocumentation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep5CompletePhotoDocumentationMutationResult = NonNullable<Awaited<ReturnType<typeof substep5CompletePhotoDocumentation>>>
    
    export type Substep5CompletePhotoDocumentationMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Ñ–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
 */
export const useSubstep5CompletePhotoDocumentation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep5CompletePhotoDocumentation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep5CompletePhotoDocumentation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep5CompletePhotoDocumentationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—ñ–¥–µ—Ç–∞–ø—É 5 - –§–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è
 */
export const substep5InitializePhotoDocumentation = (
    itemId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep5/initialize/${itemId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep5InitializePhotoDocumentationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep5InitializePhotoDocumentation>>, TError,{itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep5InitializePhotoDocumentation>>, TError,{itemId: string}, TContext> => {

const mutationKey = ['substep5InitializePhotoDocumentation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep5InitializePhotoDocumentation>>, {itemId: string}> = (props) => {
          const {itemId} = props ?? {};

          return  substep5InitializePhotoDocumentation(itemId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep5InitializePhotoDocumentationMutationResult = NonNullable<Awaited<ReturnType<typeof substep5InitializePhotoDocumentation>>>
    
    export type Substep5InitializePhotoDocumentationMutationError = ErrorResponse

    /**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—ñ–¥–µ—Ç–∞–ø—É 5 - –§–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è
 */
export const useSubstep5InitializePhotoDocumentation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep5InitializePhotoDocumentation>>, TError,{itemId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep5InitializePhotoDocumentation>>,
        TError,
        {itemId: string},
        TContext
      > => {

      const mutationOptions = getSubstep5InitializePhotoDocumentationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°–∫–∏–¥–∞–Ω–Ω—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const substep4ResetCalculation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/reset/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep4ResetCalculationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4ResetCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4ResetCalculation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep4ResetCalculation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4ResetCalculation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep4ResetCalculation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4ResetCalculationMutationResult = NonNullable<Awaited<ReturnType<typeof substep4ResetCalculation>>>
    
    export type Substep4ResetCalculationMutationError = ErrorResponse

    /**
 * @summary –°–∫–∏–¥–∞–Ω–Ω—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const useSubstep4ResetCalculation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4ResetCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4ResetCalculation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4ResetCalculationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –î–æ–¥–∞–≤–∞–Ω–Ω—è –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –¥–æ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const substep4AddModifier = (
    sessionId: string,
    addModifierRequest: AddModifierRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers/${sessionId}/add`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addModifierRequest, signal
    },
      options);
    }
  


export const getSubstep4AddModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4AddModifier>>, TError,{sessionId: string;data: AddModifierRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4AddModifier>>, TError,{sessionId: string;data: AddModifierRequest}, TContext> => {

const mutationKey = ['substep4AddModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4AddModifier>>, {sessionId: string;data: AddModifierRequest}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  substep4AddModifier(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4AddModifierMutationResult = NonNullable<Awaited<ReturnType<typeof substep4AddModifier>>>
    export type Substep4AddModifierMutationBody = AddModifierRequest
    export type Substep4AddModifierMutationError = ErrorResponse

    /**
 * @summary –î–æ–¥–∞–≤–∞–Ω–Ω—è –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –¥–æ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const useSubstep4AddModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4AddModifier>>, TError,{sessionId: string;data: AddModifierRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4AddModifier>>,
        TError,
        {sessionId: string;data: AddModifierRequest},
        TContext
      > => {

      const mutationOptions = getSubstep4AddModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—ñ–¥–µ—Ç–∞–ø—É 4
 */
export const substep4InitializeSubstep = (
    sessionId: string,
    initializeSubstepRequest: InitializeSubstepRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/initialize/${sessionId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: initializeSubstepRequest, signal
    },
      options);
    }
  


export const getSubstep4InitializeSubstepMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4InitializeSubstep>>, TError,{sessionId: string;data: InitializeSubstepRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4InitializeSubstep>>, TError,{sessionId: string;data: InitializeSubstepRequest}, TContext> => {

const mutationKey = ['substep4InitializeSubstep'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4InitializeSubstep>>, {sessionId: string;data: InitializeSubstepRequest}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  substep4InitializeSubstep(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4InitializeSubstepMutationResult = NonNullable<Awaited<ReturnType<typeof substep4InitializeSubstep>>>
    export type Substep4InitializeSubstepMutationBody = InitializeSubstepRequest
    export type Substep4InitializeSubstepMutationError = ErrorResponse

    /**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—ñ–¥–µ—Ç–∞–ø—É 4
 */
export const useSubstep4InitializeSubstep = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4InitializeSubstep>>, TError,{sessionId: string;data: InitializeSubstepRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4InitializeSubstep>>,
        TError,
        {sessionId: string;data: InitializeSubstepRequest},
        TContext
      > => {

      const mutationOptions = getSubstep4InitializeSubstepMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É —Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –ø—ñ–¥–µ—Ç–∞–ø—É
 */
export const substep4ConfirmCalculation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/confirm/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep4ConfirmCalculationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4ConfirmCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4ConfirmCalculation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep4ConfirmCalculation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4ConfirmCalculation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep4ConfirmCalculation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4ConfirmCalculationMutationResult = NonNullable<Awaited<ReturnType<typeof substep4ConfirmCalculation>>>
    
    export type Substep4ConfirmCalculationMutationError = ErrorResponse

    /**
 * @summary –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É —Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –ø—ñ–¥–µ—Ç–∞–ø—É
 */
export const useSubstep4ConfirmCalculation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4ConfirmCalculation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4ConfirmCalculation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4ConfirmCalculationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ü—ñ–Ω–∏
 */
export const substep4CalculatePrice = (
    priceDiscountDTO: PriceDiscountDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceCalculationResponseDTO>(
      {url: `/v1/order-wizard/stage2/substep4/calculate-price`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: priceDiscountDTO, signal
    },
      options);
    }
  


export const getSubstep4CalculatePriceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculatePrice>>, TError,{data: PriceDiscountDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4CalculatePrice>>, TError,{data: PriceDiscountDTO}, TContext> => {

const mutationKey = ['substep4CalculatePrice'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4CalculatePrice>>, {data: PriceDiscountDTO}> = (props) => {
          const {data} = props ?? {};

          return  substep4CalculatePrice(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4CalculatePriceMutationResult = NonNullable<Awaited<ReturnType<typeof substep4CalculatePrice>>>
    export type Substep4CalculatePriceMutationBody = PriceDiscountDTO
    export type Substep4CalculatePriceMutationError = ErrorResponse

    /**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ü—ñ–Ω–∏
 */
export const useSubstep4CalculatePrice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculatePrice>>, TError,{data: PriceDiscountDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4CalculatePrice>>,
        TError,
        {data: PriceDiscountDTO},
        TContext
      > => {

      const mutationOptions = getSubstep4CalculatePriceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ñ—ñ–Ω–∞–ª—å–Ω–æ—ó —Ü—ñ–Ω–∏ –∑ —É—Å—ñ–º–∞ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞–º–∏
 */
export const substep4CalculateFinalPrice = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/calculate-final-price/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep4CalculateFinalPriceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateFinalPrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateFinalPrice>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep4CalculateFinalPrice'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4CalculateFinalPrice>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep4CalculateFinalPrice(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4CalculateFinalPriceMutationResult = NonNullable<Awaited<ReturnType<typeof substep4CalculateFinalPrice>>>
    
    export type Substep4CalculateFinalPriceMutationError = ErrorResponse

    /**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ñ—ñ–Ω–∞–ª—å–Ω–æ—ó —Ü—ñ–Ω–∏ –∑ —É—Å—ñ–º–∞ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞–º–∏
 */
export const useSubstep4CalculateFinalPrice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateFinalPrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4CalculateFinalPrice>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4CalculateFinalPriceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –±–∞–∑–æ–≤–æ—ó —Ü—ñ–Ω–∏ –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const substep4CalculateBasePrice = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/calculate-base-price/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep4CalculateBasePriceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateBasePrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateBasePrice>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep4CalculateBasePrice'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4CalculateBasePrice>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep4CalculateBasePrice(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4CalculateBasePriceMutationResult = NonNullable<Awaited<ReturnType<typeof substep4CalculateBasePrice>>>
    
    export type Substep4CalculateBasePriceMutationError = ErrorResponse

    /**
 * @summary –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –±–∞–∑–æ–≤–æ—ó —Ü—ñ–Ω–∏ –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const useSubstep4CalculateBasePrice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4CalculateBasePrice>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4CalculateBasePrice>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4CalculateBasePriceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–±—Ä–æ–±–∫–∞ –≤–∏–±–æ—Ä—É –ø–ª—è–º
 */
export const substep3ProcessStainSelection = (
    sessionId: string,
    params?: Substep3ProcessStainSelectionParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/stains/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep3ProcessStainSelectionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3ProcessStainSelection>>, TError,{sessionId: string;params?: Substep3ProcessStainSelectionParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep3ProcessStainSelection>>, TError,{sessionId: string;params?: Substep3ProcessStainSelectionParams}, TContext> => {

const mutationKey = ['substep3ProcessStainSelection'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep3ProcessStainSelection>>, {sessionId: string;params?: Substep3ProcessStainSelectionParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep3ProcessStainSelection(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep3ProcessStainSelectionMutationResult = NonNullable<Awaited<ReturnType<typeof substep3ProcessStainSelection>>>
    
    export type Substep3ProcessStainSelectionMutationError = ErrorResponse

    /**
 * @summary –û–±—Ä–æ–±–∫–∞ –≤–∏–±–æ—Ä—É –ø–ª—è–º
 */
export const useSubstep3ProcessStainSelection = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3ProcessStainSelection>>, TError,{sessionId: string;params?: Substep3ProcessStainSelectionParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep3ProcessStainSelection>>,
        TError,
        {sessionId: string;params?: Substep3ProcessStainSelectionParams},
        TContext
      > => {

      const mutationOptions = getSubstep3ProcessStainSelectionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–±—Ä–æ–±–∫–∞ –¥–æ–¥–∞–≤–∞–Ω–Ω—è –ø—Ä–∏–º—ñ—Ç–æ–∫ –ø—Ä–æ –¥–µ—Ñ–µ–∫—Ç–∏
 */
export const substep3ProcessDefectNotes = (
    sessionId: string,
    params?: Substep3ProcessDefectNotesParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/notes/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep3ProcessDefectNotesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3ProcessDefectNotes>>, TError,{sessionId: string;params?: Substep3ProcessDefectNotesParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep3ProcessDefectNotes>>, TError,{sessionId: string;params?: Substep3ProcessDefectNotesParams}, TContext> => {

const mutationKey = ['substep3ProcessDefectNotes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep3ProcessDefectNotes>>, {sessionId: string;params?: Substep3ProcessDefectNotesParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep3ProcessDefectNotes(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep3ProcessDefectNotesMutationResult = NonNullable<Awaited<ReturnType<typeof substep3ProcessDefectNotes>>>
    
    export type Substep3ProcessDefectNotesMutationError = ErrorResponse

    /**
 * @summary –û–±—Ä–æ–±–∫–∞ –¥–æ–¥–∞–≤–∞–Ω–Ω—è –ø—Ä–∏–º—ñ—Ç–æ–∫ –ø—Ä–æ –¥–µ—Ñ–µ–∫—Ç–∏
 */
export const useSubstep3ProcessDefectNotes = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3ProcessDefectNotes>>, TError,{sessionId: string;params?: Substep3ProcessDefectNotesParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep3ProcessDefectNotes>>,
        TError,
        {sessionId: string;params?: Substep3ProcessDefectNotesParams},
        TContext
      > => {

      const mutationOptions = getSubstep3ProcessDefectNotesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—ñ–¥–µ—Ç–∞–ø—É 3
 */
export const substep3InitializeSubstep = (
    sessionId: string,
    orderItemAddRequest: OrderItemAddRequest,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/initialize/${sessionId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderItemAddRequest, signal
    },
      options);
    }
  


export const getSubstep3InitializeSubstepMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3InitializeSubstep>>, TError,{sessionId: string;data: OrderItemAddRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep3InitializeSubstep>>, TError,{sessionId: string;data: OrderItemAddRequest}, TContext> => {

const mutationKey = ['substep3InitializeSubstep'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep3InitializeSubstep>>, {sessionId: string;data: OrderItemAddRequest}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  substep3InitializeSubstep(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep3InitializeSubstepMutationResult = NonNullable<Awaited<ReturnType<typeof substep3InitializeSubstep>>>
    export type Substep3InitializeSubstepMutationBody = OrderItemAddRequest
    export type Substep3InitializeSubstepMutationError = ErrorResponse

    /**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—ñ–¥–µ—Ç–∞–ø—É 3
 */
export const useSubstep3InitializeSubstep = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3InitializeSubstep>>, TError,{sessionId: string;data: OrderItemAddRequest}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep3InitializeSubstep>>,
        TError,
        {sessionId: string;data: OrderItemAddRequest},
        TContext
      > => {

      const mutationOptions = getSubstep3InitializeSubstepMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –¥–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const substep3GoBack = (
    sessionId: string,
    params: Substep3GoBackParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/go-back/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep3GoBackMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3GoBack>>, TError,{sessionId: string;params: Substep3GoBackParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep3GoBack>>, TError,{sessionId: string;params: Substep3GoBackParams}, TContext> => {

const mutationKey = ['substep3GoBack'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep3GoBack>>, {sessionId: string;params: Substep3GoBackParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep3GoBack(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep3GoBackMutationResult = NonNullable<Awaited<ReturnType<typeof substep3GoBack>>>
    
    export type Substep3GoBackMutationError = ErrorResponse

    /**
 * @summary –ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –¥–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const useSubstep3GoBack = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3GoBack>>, TError,{sessionId: string;params: Substep3GoBackParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep3GoBack>>,
        TError,
        {sessionId: string;params: Substep3GoBackParams},
        TContext
      > => {

      const mutationOptions = getSubstep3GoBackMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û–±—Ä–æ–±–∫–∞ –≤–∏–±–æ—Ä—É –¥–µ—Ñ–µ–∫—Ç—ñ–≤ —Ç–∞ —Ä–∏–∑–∏–∫—ñ–≤
 */
export const substep3ProcessDefectSelection = (
    sessionId: string,
    params?: Substep3ProcessDefectSelectionParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/defects/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep3ProcessDefectSelectionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3ProcessDefectSelection>>, TError,{sessionId: string;params?: Substep3ProcessDefectSelectionParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep3ProcessDefectSelection>>, TError,{sessionId: string;params?: Substep3ProcessDefectSelectionParams}, TContext> => {

const mutationKey = ['substep3ProcessDefectSelection'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep3ProcessDefectSelection>>, {sessionId: string;params?: Substep3ProcessDefectSelectionParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep3ProcessDefectSelection(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep3ProcessDefectSelectionMutationResult = NonNullable<Awaited<ReturnType<typeof substep3ProcessDefectSelection>>>
    
    export type Substep3ProcessDefectSelectionMutationError = ErrorResponse

    /**
 * @summary –û–±—Ä–æ–±–∫–∞ –≤–∏–±–æ—Ä—É –¥–µ—Ñ–µ–∫—Ç—ñ–≤ —Ç–∞ —Ä–∏–∑–∏–∫—ñ–≤
 */
export const useSubstep3ProcessDefectSelection = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3ProcessDefectSelection>>, TError,{sessionId: string;params?: Substep3ProcessDefectSelectionParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep3ProcessDefectSelection>>,
        TError,
        {sessionId: string;params?: Substep3ProcessDefectSelectionParams},
        TContext
      > => {

      const mutationOptions = getSubstep3ProcessDefectSelectionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è –ø—ñ–¥–µ—Ç–∞–ø—É 3
 */
export const substep3CompleteSubstep = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/complete/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep3CompleteSubstepMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3CompleteSubstep>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep3CompleteSubstep>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep3CompleteSubstep'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep3CompleteSubstep>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep3CompleteSubstep(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep3CompleteSubstepMutationResult = NonNullable<Awaited<ReturnType<typeof substep3CompleteSubstep>>>
    
    export type Substep3CompleteSubstepMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è –ø—ñ–¥–µ—Ç–∞–ø—É 3
 */
export const useSubstep3CompleteSubstep = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep3CompleteSubstep>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep3CompleteSubstep>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep3CompleteSubstepMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∞–ª—ñ–¥—É—î –≤—Å—ñ –≤–∏–±—Ä–∞–Ω—ñ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
 */
export const substep2ValidateCharacteristics = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/substep2/validate/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep2ValidateCharacteristicsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2ValidateCharacteristics>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep2ValidateCharacteristics>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep2ValidateCharacteristics'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep2ValidateCharacteristics>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep2ValidateCharacteristics(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep2ValidateCharacteristicsMutationResult = NonNullable<Awaited<ReturnType<typeof substep2ValidateCharacteristics>>>
    
    export type Substep2ValidateCharacteristicsMutationError = ErrorResponse

    /**
 * @summary –í–∞–ª—ñ–¥—É—î –≤—Å—ñ –≤–∏–±—Ä–∞–Ω—ñ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
 */
export const useSubstep2ValidateCharacteristics = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2ValidateCharacteristics>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep2ValidateCharacteristics>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep2ValidateCharacteristicsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–±–∏—Ä–∞—î —Å—Ç—É–ø—ñ–Ω—å –∑–Ω–æ—Å—É
 */
export const substep2SelectWearLevel = (
    sessionId: string,
    params: Substep2SelectWearLevelParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/substep2/select-wear-level/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep2SelectWearLevelMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2SelectWearLevel>>, TError,{sessionId: string;params: Substep2SelectWearLevelParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep2SelectWearLevel>>, TError,{sessionId: string;params: Substep2SelectWearLevelParams}, TContext> => {

const mutationKey = ['substep2SelectWearLevel'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep2SelectWearLevel>>, {sessionId: string;params: Substep2SelectWearLevelParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep2SelectWearLevel(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep2SelectWearLevelMutationResult = NonNullable<Awaited<ReturnType<typeof substep2SelectWearLevel>>>
    
    export type Substep2SelectWearLevelMutationError = ErrorResponse

    /**
 * @summary –í–∏–±–∏—Ä–∞—î —Å—Ç—É–ø—ñ–Ω—å –∑–Ω–æ—Å—É
 */
export const useSubstep2SelectWearLevel = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2SelectWearLevel>>, TError,{sessionId: string;params: Substep2SelectWearLevelParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep2SelectWearLevel>>,
        TError,
        {sessionId: string;params: Substep2SelectWearLevelParams},
        TContext
      > => {

      const mutationOptions = getSubstep2SelectWearLevelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–±–∏—Ä–∞—î –º–∞—Ç–µ—Ä—ñ–∞–ª –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const substep2SelectMaterial = (
    sessionId: string,
    params: Substep2SelectMaterialParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/substep2/select-material/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep2SelectMaterialMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2SelectMaterial>>, TError,{sessionId: string;params: Substep2SelectMaterialParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep2SelectMaterial>>, TError,{sessionId: string;params: Substep2SelectMaterialParams}, TContext> => {

const mutationKey = ['substep2SelectMaterial'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep2SelectMaterial>>, {sessionId: string;params: Substep2SelectMaterialParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep2SelectMaterial(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep2SelectMaterialMutationResult = NonNullable<Awaited<ReturnType<typeof substep2SelectMaterial>>>
    
    export type Substep2SelectMaterialMutationError = ErrorResponse

    /**
 * @summary –í–∏–±–∏—Ä–∞—î –º–∞—Ç–µ—Ä—ñ–∞–ª –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const useSubstep2SelectMaterial = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2SelectMaterial>>, TError,{sessionId: string;params: Substep2SelectMaterialParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep2SelectMaterial>>,
        TError,
        {sessionId: string;params: Substep2SelectMaterialParams},
        TContext
      > => {

      const mutationOptions = getSubstep2SelectMaterialMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–±–∏—Ä–∞—î –Ω–∞–ø–æ–≤–Ω—é–≤–∞—á
 */
export const substep2SelectFiller = (
    sessionId: string,
    params?: Substep2SelectFillerParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/substep2/select-filler/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep2SelectFillerMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2SelectFiller>>, TError,{sessionId: string;params?: Substep2SelectFillerParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep2SelectFiller>>, TError,{sessionId: string;params?: Substep2SelectFillerParams}, TContext> => {

const mutationKey = ['substep2SelectFiller'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep2SelectFiller>>, {sessionId: string;params?: Substep2SelectFillerParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep2SelectFiller(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep2SelectFillerMutationResult = NonNullable<Awaited<ReturnType<typeof substep2SelectFiller>>>
    
    export type Substep2SelectFillerMutationError = ErrorResponse

    /**
 * @summary –í–∏–±–∏—Ä–∞—î –Ω–∞–ø–æ–≤–Ω—é–≤–∞—á
 */
export const useSubstep2SelectFiller = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2SelectFiller>>, TError,{sessionId: string;params?: Substep2SelectFillerParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep2SelectFiller>>,
        TError,
        {sessionId: string;params?: Substep2SelectFillerParams},
        TContext
      > => {

      const mutationOptions = getSubstep2SelectFillerMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–±–∏—Ä–∞—î –∫–æ–ª—ñ—Ä –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const substep2SelectColor = (
    sessionId: string,
    params: Substep2SelectColorParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/substep2/select-color/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep2SelectColorMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2SelectColor>>, TError,{sessionId: string;params: Substep2SelectColorParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep2SelectColor>>, TError,{sessionId: string;params: Substep2SelectColorParams}, TContext> => {

const mutationKey = ['substep2SelectColor'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep2SelectColor>>, {sessionId: string;params: Substep2SelectColorParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep2SelectColor(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep2SelectColorMutationResult = NonNullable<Awaited<ReturnType<typeof substep2SelectColor>>>
    
    export type Substep2SelectColorMutationError = ErrorResponse

    /**
 * @summary –í–∏–±–∏—Ä–∞—î –∫–æ–ª—ñ—Ä –ø—Ä–µ–¥–º–µ—Ç–∞
 */
export const useSubstep2SelectColor = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2SelectColor>>, TError,{sessionId: string;params: Substep2SelectColorParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep2SelectColor>>,
        TError,
        {sessionId: string;params: Substep2SelectColorParams},
        TContext
      > => {

      const mutationOptions = getSubstep2SelectColorMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î –ø—ñ–¥–µ—Ç–∞–ø 2 - –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
 */
export const substep2InitializeSubstep = (
    sessionId: string,
    params: Substep2InitializeSubstepParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemCharacteristicsDTO>(
      {url: `/v1/order-wizard/stage2/substep2/initialize/${sessionId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep2InitializeSubstepMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2InitializeSubstep>>, TError,{sessionId: string;params: Substep2InitializeSubstepParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep2InitializeSubstep>>, TError,{sessionId: string;params: Substep2InitializeSubstepParams}, TContext> => {

const mutationKey = ['substep2InitializeSubstep'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep2InitializeSubstep>>, {sessionId: string;params: Substep2InitializeSubstepParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep2InitializeSubstep(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep2InitializeSubstepMutationResult = NonNullable<Awaited<ReturnType<typeof substep2InitializeSubstep>>>
    
    export type Substep2InitializeSubstepMutationError = ErrorResponse

    /**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î –ø—ñ–¥–µ—Ç–∞–ø 2 - –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
 */
export const useSubstep2InitializeSubstep = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2InitializeSubstep>>, TError,{sessionId: string;params: Substep2InitializeSubstepParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep2InitializeSubstep>>,
        TError,
        {sessionId: string;params: Substep2InitializeSubstepParams},
        TContext
      > => {

      const mutationOptions = getSubstep2InitializeSubstepMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–≤–µ—Ä—à—É—î –ø—ñ–¥–µ—Ç–∞–ø 2
 */
export const substep2CompleteSubstep = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Substep2CompleteSubstep200>(
      {url: `/v1/order-wizard/stage2/substep2/complete/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep2CompleteSubstepMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2CompleteSubstep>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep2CompleteSubstep>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep2CompleteSubstep'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep2CompleteSubstep>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep2CompleteSubstep(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep2CompleteSubstepMutationResult = NonNullable<Awaited<ReturnType<typeof substep2CompleteSubstep>>>
    
    export type Substep2CompleteSubstepMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–µ—Ä—à—É—î –ø—ñ–¥–µ—Ç–∞–ø 2
 */
export const useSubstep2CompleteSubstep = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2CompleteSubstep>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep2CompleteSubstep>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep2CompleteSubstepMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°–∫–∞—Å–æ–≤—É—î –ø—ñ–¥–µ—Ç–∞–ø 2
 */
export const substep2CancelSubstep = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/substep2/cancel/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep2CancelSubstepMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2CancelSubstep>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep2CancelSubstep>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep2CancelSubstep'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep2CancelSubstep>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep2CancelSubstep(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep2CancelSubstepMutationResult = NonNullable<Awaited<ReturnType<typeof substep2CancelSubstep>>>
    
    export type Substep2CancelSubstepMutationError = ErrorResponse

    /**
 * @summary –°–∫–∞—Å–æ–≤—É—î –ø—ñ–¥–µ—Ç–∞–ø 2
 */
export const useSubstep2CancelSubstep = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep2CancelSubstep>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep2CancelSubstep>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep2CancelSubstepMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∞–ª—ñ–¥—É—î —Ç–∞ –∑–∞–≤–µ—Ä—à—É—î –ø—ñ–¥–µ—Ç–∞–ø 1
 */
export const substep1ValidateAndComplete = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/validate-and-complete`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep1ValidateAndCompleteMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1ValidateAndComplete>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep1ValidateAndComplete>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep1ValidateAndComplete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep1ValidateAndComplete>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep1ValidateAndComplete(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep1ValidateAndCompleteMutationResult = NonNullable<Awaited<ReturnType<typeof substep1ValidateAndComplete>>>
    
    export type Substep1ValidateAndCompleteMutationError = ErrorResponse

    /**
 * @summary –í–∞–ª—ñ–¥—É—î —Ç–∞ –∑–∞–≤–µ—Ä—à—É—î –ø—ñ–¥–µ—Ç–∞–ø 1
 */
export const useSubstep1ValidateAndComplete = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1ValidateAndComplete>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep1ValidateAndComplete>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep1ValidateAndCompleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–±–∏—Ä–∞—î –ø—Ä–µ–¥–º–µ—Ç –∑ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞
 */
export const substep1SelectPriceListItem = (
    sessionId: string,
    params: Substep1SelectPriceListItemParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/select-item`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep1SelectPriceListItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1SelectPriceListItem>>, TError,{sessionId: string;params: Substep1SelectPriceListItemParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep1SelectPriceListItem>>, TError,{sessionId: string;params: Substep1SelectPriceListItemParams}, TContext> => {

const mutationKey = ['substep1SelectPriceListItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep1SelectPriceListItem>>, {sessionId: string;params: Substep1SelectPriceListItemParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep1SelectPriceListItem(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep1SelectPriceListItemMutationResult = NonNullable<Awaited<ReturnType<typeof substep1SelectPriceListItem>>>
    
    export type Substep1SelectPriceListItemMutationError = ErrorResponse

    /**
 * @summary –í–∏–±–∏—Ä–∞—î –ø—Ä–µ–¥–º–µ—Ç –∑ –ø—Ä–∞–π—Å-–ª–∏—Å—Ç–∞
 */
export const useSubstep1SelectPriceListItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1SelectPriceListItem>>, TError,{sessionId: string;params: Substep1SelectPriceListItemParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep1SelectPriceListItem>>,
        TError,
        {sessionId: string;params: Substep1SelectPriceListItemParams},
        TContext
      > => {

      const mutationOptions = getSubstep1SelectPriceListItemMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–±–∏—Ä–∞—î –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥–∏
 */
export const substep1SelectServiceCategory = (
    sessionId: string,
    params: Substep1SelectServiceCategoryParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/select-category`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep1SelectServiceCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1SelectServiceCategory>>, TError,{sessionId: string;params: Substep1SelectServiceCategoryParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep1SelectServiceCategory>>, TError,{sessionId: string;params: Substep1SelectServiceCategoryParams}, TContext> => {

const mutationKey = ['substep1SelectServiceCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep1SelectServiceCategory>>, {sessionId: string;params: Substep1SelectServiceCategoryParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep1SelectServiceCategory(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep1SelectServiceCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof substep1SelectServiceCategory>>>
    
    export type Substep1SelectServiceCategoryMutationError = ErrorResponse

    /**
 * @summary –í–∏–±–∏—Ä–∞—î –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –ø–æ—Å–ª—É–≥–∏
 */
export const useSubstep1SelectServiceCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1SelectServiceCategory>>, TError,{sessionId: string;params: Substep1SelectServiceCategoryParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep1SelectServiceCategory>>,
        TError,
        {sessionId: string;params: Substep1SelectServiceCategoryParams},
        TContext
      > => {

      const mutationOptions = getSubstep1SelectServiceCategoryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°–∫–∏–¥–∞—î –ø—ñ–¥–µ—Ç–∞–ø 1 –¥–æ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const substep1Reset = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/reset`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep1ResetMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1Reset>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep1Reset>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep1Reset'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep1Reset>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep1Reset(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep1ResetMutationResult = NonNullable<Awaited<ReturnType<typeof substep1Reset>>>
    
    export type Substep1ResetMutationError = ErrorResponse

    /**
 * @summary –°–∫–∏–¥–∞—î –ø—ñ–¥–µ—Ç–∞–ø 1 –¥–æ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const useSubstep1Reset = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1Reset>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep1Reset>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep1ResetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–≤–æ–¥–∏—Ç—å –∫—ñ–ª—å–∫—ñ—Å—Ç—å
 */
export const substep1EnterQuantity = (
    sessionId: string,
    params: Substep1EnterQuantityParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/enter-quantity`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSubstep1EnterQuantityMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1EnterQuantity>>, TError,{sessionId: string;params: Substep1EnterQuantityParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep1EnterQuantity>>, TError,{sessionId: string;params: Substep1EnterQuantityParams}, TContext> => {

const mutationKey = ['substep1EnterQuantity'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep1EnterQuantity>>, {sessionId: string;params: Substep1EnterQuantityParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  substep1EnterQuantity(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep1EnterQuantityMutationResult = NonNullable<Awaited<ReturnType<typeof substep1EnterQuantity>>>
    
    export type Substep1EnterQuantityMutationError = ErrorResponse

    /**
 * @summary –í–≤–æ–¥–∏—Ç—å –∫—ñ–ª—å–∫—ñ—Å—Ç—å
 */
export const useSubstep1EnterQuantity = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1EnterQuantity>>, TError,{sessionId: string;params: Substep1EnterQuantityParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep1EnterQuantity>>,
        TError,
        {sessionId: string;params: Substep1EnterQuantityParams},
        TContext
      > => {

      const mutationOptions = getSubstep1EnterQuantityMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ü–æ—á–∏–Ω–∞—î –Ω–æ–≤–∏–π –ø—ñ–¥–µ—Ç–∞–ø 1 - –û—Å–Ω–æ–≤–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è
 */
export const substep1StartSubstep = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemBasicInfoDTO>(
      {url: `/v1/order-wizard/stage2/substep1/start`, method: 'POST', signal
    },
      options);
    }
  


export const getSubstep1StartSubstepMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1StartSubstep>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep1StartSubstep>>, TError,void, TContext> => {

const mutationKey = ['substep1StartSubstep'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep1StartSubstep>>, void> = () => {
          

          return  substep1StartSubstep(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep1StartSubstepMutationResult = NonNullable<Awaited<ReturnType<typeof substep1StartSubstep>>>
    
    export type Substep1StartSubstepMutationError = ErrorResponse

    /**
 * @summary –ü–æ—á–∏–Ω–∞—î –Ω–æ–≤–∏–π –ø—ñ–¥–µ—Ç–∞–ø 1 - –û—Å–Ω–æ–≤–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è
 */
export const useSubstep1StartSubstep = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1StartSubstep>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep1StartSubstep>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSubstep1StartSubstepMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°–∫–∏–¥–∞—î —Å–µ—Å—ñ—é –¥–æ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const stage2ResetSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/reset/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getStage2ResetSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2ResetSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage2ResetSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage2ResetSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage2ResetSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage2ResetSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage2ResetSessionMutationResult = NonNullable<Awaited<ReturnType<typeof stage2ResetSession>>>
    
    export type Stage2ResetSessionMutationError = ErrorResponse

    /**
 * @summary –°–∫–∏–¥–∞—î —Å–µ—Å—ñ—é –¥–æ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const useStage2ResetSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2ResetSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage2ResetSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage2ResetSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –î–æ–¥–∞—î –Ω–æ–≤–∏–π –ø—Ä–µ–¥–º–µ—Ç –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è (–∑ –ø—ñ–¥–≤—ñ–∑–∞—Ä–¥–∞)
 */
export const stage2AddItemToOrder = (
    sessionId: string,
    orderItemDTO: OrderItemDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/items/${sessionId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderItemDTO, signal
    },
      options);
    }
  


export const getStage2AddItemToOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2AddItemToOrder>>, TError,{sessionId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage2AddItemToOrder>>, TError,{sessionId: string;data: OrderItemDTO}, TContext> => {

const mutationKey = ['stage2AddItemToOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage2AddItemToOrder>>, {sessionId: string;data: OrderItemDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage2AddItemToOrder(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage2AddItemToOrderMutationResult = NonNullable<Awaited<ReturnType<typeof stage2AddItemToOrder>>>
    export type Stage2AddItemToOrderMutationBody = OrderItemDTO
    export type Stage2AddItemToOrderMutationError = ErrorResponse

    /**
 * @summary –î–æ–¥–∞—î –Ω–æ–≤–∏–π –ø—Ä–µ–¥–º–µ—Ç –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è (–∑ –ø—ñ–¥–≤—ñ–∑–∞—Ä–¥–∞)
 */
export const useStage2AddItemToOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2AddItemToOrder>>, TError,{sessionId: string;data: OrderItemDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage2AddItemToOrder>>,
        TError,
        {sessionId: string;data: OrderItemDTO},
        TContext
      > => {

      const mutationOptions = getStage2AddItemToOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î –Ω–æ–≤–∏–π —Å–µ–∞–Ω—Å –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø—Ä–µ–¥–º–µ—Ç—ñ–≤ –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const stage2InitializeItemManager = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/initialize/${orderId}`, method: 'POST', signal
    },
      options);
    }
  


export const getStage2InitializeItemManagerMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2InitializeItemManager>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage2InitializeItemManager>>, TError,{orderId: string}, TContext> => {

const mutationKey = ['stage2InitializeItemManager'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage2InitializeItemManager>>, {orderId: string}> = (props) => {
          const {orderId} = props ?? {};

          return  stage2InitializeItemManager(orderId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage2InitializeItemManagerMutationResult = NonNullable<Awaited<ReturnType<typeof stage2InitializeItemManager>>>
    
    export type Stage2InitializeItemManagerMutationError = ErrorResponse

    /**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î –Ω–æ–≤–∏–π —Å–µ–∞–Ω—Å –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø—Ä–µ–¥–º–µ—Ç—ñ–≤ –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useStage2InitializeItemManager = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2InitializeItemManager>>, TError,{orderId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage2InitializeItemManager>>,
        TError,
        {orderId: string},
        TContext
      > => {

      const mutationOptions = getStage2InitializeItemManagerMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–≤–µ—Ä—à—É—î –µ—Ç–∞–ø 2 —Ç–∞ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –µ—Ç–∞–ø—É
 */
export const stage2CompleteStage = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/complete/${sessionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getStage2CompleteStageMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2CompleteStage>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage2CompleteStage>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage2CompleteStage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage2CompleteStage>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage2CompleteStage(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage2CompleteStageMutationResult = NonNullable<Awaited<ReturnType<typeof stage2CompleteStage>>>
    
    export type Stage2CompleteStageMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–µ—Ä—à—É—î –µ—Ç–∞–ø 2 —Ç–∞ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –µ—Ç–∞–ø—É
 */
export const useStage2CompleteStage = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2CompleteStage>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage2CompleteStage>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage2CompleteStageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∞–ª—ñ–¥—É—î —Ñ–æ—Ä–º—É –∫–ª—ñ—î–Ω—Ç–∞
 */
export const stage1ValidateClientForm = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage1ValidateClientForm200>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/validate`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1ValidateClientFormMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1ValidateClientForm>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1ValidateClientForm>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1ValidateClientForm'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1ValidateClientForm>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1ValidateClientForm(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1ValidateClientFormMutationResult = NonNullable<Awaited<ReturnType<typeof stage1ValidateClientForm>>>
    
    export type Stage1ValidateClientFormMutationError = ErrorResponse

    /**
 * @summary –í–∞–ª—ñ–¥—É—î —Ñ–æ—Ä–º—É –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useStage1ValidateClientForm = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1ValidateClientForm>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1ValidateClientForm>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1ValidateClientFormMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const stage1CreateClient = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/create`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1CreateClientMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CreateClient>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1CreateClient>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1CreateClient'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1CreateClient>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1CreateClient(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1CreateClientMutationResult = NonNullable<Awaited<ReturnType<typeof stage1CreateClient>>>
    
    export type Stage1CreateClientMutationError = ErrorResponse

    /**
 * @summary –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useStage1CreateClient = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CreateClient>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1CreateClient>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1CreateClientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–≤–µ—Ä—à—É—î —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–ª—ñ—î–Ω—Ç–∞
 */
export const stage1CompleteClientCreation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1CompleteClientCreationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CompleteClientCreation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1CompleteClientCreation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1CompleteClientCreation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1CompleteClientCreation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1CompleteClientCreation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1CompleteClientCreationMutationResult = NonNullable<Awaited<ReturnType<typeof stage1CompleteClientCreation>>>
    
    export type Stage1CompleteClientCreationMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–µ—Ä—à—É—î —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useStage1CompleteClientCreation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CompleteClientCreation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1CompleteClientCreation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1CompleteClientCreationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î —Ñ–æ—Ä–º—É —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const stage1InitializeNewClient = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage1/new-client/initialize`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1InitializeNewClientMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1InitializeNewClient>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1InitializeNewClient>>, TError,void, TContext> => {

const mutationKey = ['stage1InitializeNewClient'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1InitializeNewClient>>, void> = () => {
          

          return  stage1InitializeNewClient(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1InitializeNewClientMutationResult = NonNullable<Awaited<ReturnType<typeof stage1InitializeNewClient>>>
    
    export type Stage1InitializeNewClientMutationError = ErrorResponse

    /**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î —Ñ–æ—Ä–º—É —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useStage1InitializeNewClient = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1InitializeNewClient>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1InitializeNewClient>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getStage1InitializeNewClientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–±–∏—Ä–∞—î –∫–ª—ñ—î–Ω—Ç–∞ –∑—ñ —Å–ø–∏—Å–∫—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
 */
export const stage1SelectClient = (
    sessionId: string,
    params: Stage1SelectClientParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/select-client`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getStage1SelectClientMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1SelectClient>>, TError,{sessionId: string;params: Stage1SelectClientParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1SelectClient>>, TError,{sessionId: string;params: Stage1SelectClientParams}, TContext> => {

const mutationKey = ['stage1SelectClient'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1SelectClient>>, {sessionId: string;params: Stage1SelectClientParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  stage1SelectClient(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1SelectClientMutationResult = NonNullable<Awaited<ReturnType<typeof stage1SelectClient>>>
    
    export type Stage1SelectClientMutationError = ErrorResponse

    /**
 * @summary –í–∏–±–∏—Ä–∞—î –∫–ª—ñ—î–Ω—Ç–∞ –∑—ñ —Å–ø–∏—Å–∫—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
 */
export const useStage1SelectClient = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1SelectClient>>, TError,{sessionId: string;params: Stage1SelectClientParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1SelectClient>>,
        TError,
        {sessionId: string;params: Stage1SelectClientParams},
        TContext
      > => {

      const mutationOptions = getStage1SelectClientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–∫–æ–Ω—É—î –ø–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤ –∑ –∫—Ä–∏—Ç–µ—Ä—ñ—è–º–∏
 */
export const stage1SearchClients = (
    sessionId: string,
    clientSearchCriteriaDTO: ClientSearchCriteriaDTO,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientSearchResultDTO>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: clientSearchCriteriaDTO, signal
    },
      options);
    }
  


export const getStage1SearchClientsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1SearchClients>>, TError,{sessionId: string;data: ClientSearchCriteriaDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1SearchClients>>, TError,{sessionId: string;data: ClientSearchCriteriaDTO}, TContext> => {

const mutationKey = ['stage1SearchClients'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1SearchClients>>, {sessionId: string;data: ClientSearchCriteriaDTO}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  stage1SearchClients(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1SearchClientsMutationResult = NonNullable<Awaited<ReturnType<typeof stage1SearchClients>>>
    export type Stage1SearchClientsMutationBody = ClientSearchCriteriaDTO
    export type Stage1SearchClientsMutationError = ErrorResponse

    /**
 * @summary –í–∏–∫–æ–Ω—É—î –ø–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤ –∑ –∫—Ä–∏—Ç–µ—Ä—ñ—è–º–∏
 */
export const useStage1SearchClients = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1SearchClients>>, TError,{sessionId: string;data: ClientSearchCriteriaDTO}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1SearchClients>>,
        TError,
        {sessionId: string;data: ClientSearchCriteriaDTO},
        TContext
      > => {

      const mutationOptions = getStage1SearchClientsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ü–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤ –∑–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º
 */
export const stage1SearchClientsByPhone = (
    sessionId: string,
    params: Stage1SearchClientsByPhoneParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientSearchResultDTO>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/search-by-phone`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getStage1SearchClientsByPhoneMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1SearchClientsByPhone>>, TError,{sessionId: string;params: Stage1SearchClientsByPhoneParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1SearchClientsByPhone>>, TError,{sessionId: string;params: Stage1SearchClientsByPhoneParams}, TContext> => {

const mutationKey = ['stage1SearchClientsByPhone'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1SearchClientsByPhone>>, {sessionId: string;params: Stage1SearchClientsByPhoneParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  stage1SearchClientsByPhone(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1SearchClientsByPhoneMutationResult = NonNullable<Awaited<ReturnType<typeof stage1SearchClientsByPhone>>>
    
    export type Stage1SearchClientsByPhoneMutationError = ErrorResponse

    /**
 * @summary –ü–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤ –∑–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º
 */
export const useStage1SearchClientsByPhone = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1SearchClientsByPhone>>, TError,{sessionId: string;params: Stage1SearchClientsByPhoneParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1SearchClientsByPhone>>,
        TError,
        {sessionId: string;params: Stage1SearchClientsByPhoneParams},
        TContext
      > => {

      const mutationOptions = getStage1SearchClientsByPhoneMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–≤–µ—Ä—à—É—î –ø–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const stage1CompleteClientSearch = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1CompleteClientSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CompleteClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1CompleteClientSearch>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1CompleteClientSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1CompleteClientSearch>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1CompleteClientSearch(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1CompleteClientSearchMutationResult = NonNullable<Awaited<ReturnType<typeof stage1CompleteClientSearch>>>
    
    export type Stage1CompleteClientSearchMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–µ—Ä—à—É—î –ø–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useStage1CompleteClientSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CompleteClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1CompleteClientSearch>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1CompleteClientSearchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—á–∏—â—É—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –ø–æ—à—É–∫—É
 */
export const stage1ClearClientSearch = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/clear`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1ClearClientSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1ClearClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1ClearClientSearch>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1ClearClientSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1ClearClientSearch>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1ClearClientSearch(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1ClearClientSearchMutationResult = NonNullable<Awaited<ReturnType<typeof stage1ClearClientSearch>>>
    
    export type Stage1ClearClientSearchMutationError = ErrorResponse

    /**
 * @summary –û—á–∏—â—É—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –ø–æ—à—É–∫—É
 */
export const useStage1ClearClientSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1ClearClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1ClearClientSearch>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1ClearClientSearchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î –Ω–æ–≤–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ—à—É–∫—É –∫–ª—ñ—î–Ω—Ç—ñ–≤
 */
export const stage1InitializeClientSearch = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage1/client-search/initialize`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1InitializeClientSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1InitializeClientSearch>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1InitializeClientSearch>>, TError,void, TContext> => {

const mutationKey = ['stage1InitializeClientSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1InitializeClientSearch>>, void> = () => {
          

          return  stage1InitializeClientSearch(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1InitializeClientSearchMutationResult = NonNullable<Awaited<ReturnType<typeof stage1InitializeClientSearch>>>
    
    export type Stage1InitializeClientSearchMutationError = ErrorResponse

    /**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î –Ω–æ–≤–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ—à—É–∫—É –∫–ª—ñ—î–Ω—Ç—ñ–≤
 */
export const useStage1InitializeClientSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1InitializeClientSearch>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1InitializeClientSearch>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getStage1InitializeClientSearchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ü–æ—á–∏–Ω–∞—î workflow –±–∞–∑–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */
export const stage1StartBasicOrderWorkflow = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage1/basic-order/workflow/start`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1StartBasicOrderWorkflowMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1StartBasicOrderWorkflow>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1StartBasicOrderWorkflow>>, TError,void, TContext> => {

const mutationKey = ['stage1StartBasicOrderWorkflow'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1StartBasicOrderWorkflow>>, void> = () => {
          

          return  stage1StartBasicOrderWorkflow(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1StartBasicOrderWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof stage1StartBasicOrderWorkflow>>>
    
    export type Stage1StartBasicOrderWorkflowMutationError = ErrorResponse

    /**
 * @summary –ü–æ—á–∏–Ω–∞—î workflow –±–∞–∑–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */
export const useStage1StartBasicOrderWorkflow = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1StartBasicOrderWorkflow>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1StartBasicOrderWorkflow>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getStage1StartBasicOrderWorkflowMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∞–ª—ñ–¥—É—î –±–∞–∑–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
 */
export const stage1ValidateBasicOrder = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage1ValidateBasicOrder200>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/validate`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1ValidateBasicOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1ValidateBasicOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1ValidateBasicOrder>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1ValidateBasicOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1ValidateBasicOrder>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1ValidateBasicOrder(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1ValidateBasicOrderMutationResult = NonNullable<Awaited<ReturnType<typeof stage1ValidateBasicOrder>>>
    
    export type Stage1ValidateBasicOrderMutationError = ErrorResponse

    /**
 * @summary –í–∞–ª—ñ–¥—É—î –±–∞–∑–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
 */
export const useStage1ValidateBasicOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1ValidateBasicOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1ValidateBasicOrder>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1ValidateBasicOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í—Å—Ç–∞–Ω–æ–≤–ª—é—î —É–Ω—ñ–∫–∞–ª—å–Ω—É –º—ñ—Ç–∫—É
 */
export const stage1SetUniqueTag = (
    sessionId: string,
    params: Stage1SetUniqueTagParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/set-unique-tag`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getStage1SetUniqueTagMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1SetUniqueTag>>, TError,{sessionId: string;params: Stage1SetUniqueTagParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1SetUniqueTag>>, TError,{sessionId: string;params: Stage1SetUniqueTagParams}, TContext> => {

const mutationKey = ['stage1SetUniqueTag'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1SetUniqueTag>>, {sessionId: string;params: Stage1SetUniqueTagParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  stage1SetUniqueTag(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1SetUniqueTagMutationResult = NonNullable<Awaited<ReturnType<typeof stage1SetUniqueTag>>>
    
    export type Stage1SetUniqueTagMutationError = ErrorResponse

    /**
 * @summary –í—Å—Ç–∞–Ω–æ–≤–ª—é—î —É–Ω—ñ–∫–∞–ª—å–Ω—É –º—ñ—Ç–∫—É
 */
export const useStage1SetUniqueTag = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1SetUniqueTag>>, TError,{sessionId: string;params: Stage1SetUniqueTagParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1SetUniqueTag>>,
        TError,
        {sessionId: string;params: Stage1SetUniqueTagParams},
        TContext
      > => {

      const mutationOptions = getStage1SetUniqueTagMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–±–∏—Ä–∞—î —Ñ—ñ–ª—ñ—é –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const stage1SelectBranch = (
    sessionId: string,
    params: Stage1SelectBranchParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/select-branch`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getStage1SelectBranchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1SelectBranch>>, TError,{sessionId: string;params: Stage1SelectBranchParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1SelectBranch>>, TError,{sessionId: string;params: Stage1SelectBranchParams}, TContext> => {

const mutationKey = ['stage1SelectBranch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1SelectBranch>>, {sessionId: string;params: Stage1SelectBranchParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  stage1SelectBranch(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1SelectBranchMutationResult = NonNullable<Awaited<ReturnType<typeof stage1SelectBranch>>>
    
    export type Stage1SelectBranchMutationError = ErrorResponse

    /**
 * @summary –í–∏–±–∏—Ä–∞—î —Ñ—ñ–ª—ñ—é –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useStage1SelectBranch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1SelectBranch>>, TError,{sessionId: string;params: Stage1SelectBranchParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1SelectBranch>>,
        TError,
        {sessionId: string;params: Stage1SelectBranchParams},
        TContext
      > => {

      const mutationOptions = getStage1SelectBranchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°–∫–∏–¥–∞—î –±–∞–∑–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –¥–æ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const stage1ResetBasicOrder = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/reset`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1ResetBasicOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1ResetBasicOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1ResetBasicOrder>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1ResetBasicOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1ResetBasicOrder>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1ResetBasicOrder(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1ResetBasicOrderMutationResult = NonNullable<Awaited<ReturnType<typeof stage1ResetBasicOrder>>>
    
    export type Stage1ResetBasicOrderMutationError = ErrorResponse

    /**
 * @summary –°–∫–∏–¥–∞—î –±–∞–∑–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –¥–æ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const useStage1ResetBasicOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1ResetBasicOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1ResetBasicOrder>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1ResetBasicOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ì–µ–Ω–µ—Ä—É—î –Ω–æ–º–µ—Ä –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */
export const stage1GenerateReceiptNumber = (
    sessionId: string,
    params: Stage1GenerateReceiptNumberParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/generate-receipt-number`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getStage1GenerateReceiptNumberMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1GenerateReceiptNumber>>, TError,{sessionId: string;params: Stage1GenerateReceiptNumberParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1GenerateReceiptNumber>>, TError,{sessionId: string;params: Stage1GenerateReceiptNumberParams}, TContext> => {

const mutationKey = ['stage1GenerateReceiptNumber'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1GenerateReceiptNumber>>, {sessionId: string;params: Stage1GenerateReceiptNumberParams}> = (props) => {
          const {sessionId,params} = props ?? {};

          return  stage1GenerateReceiptNumber(sessionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1GenerateReceiptNumberMutationResult = NonNullable<Awaited<ReturnType<typeof stage1GenerateReceiptNumber>>>
    
    export type Stage1GenerateReceiptNumberMutationError = ErrorResponse

    /**
 * @summary –ì–µ–Ω–µ—Ä—É—î –Ω–æ–º–µ—Ä –∫–≤–∏—Ç–∞–Ω—Ü—ñ—ó
 */
export const useStage1GenerateReceiptNumber = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1GenerateReceiptNumber>>, TError,{sessionId: string;params: Stage1GenerateReceiptNumberParams}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1GenerateReceiptNumber>>,
        TError,
        {sessionId: string;params: Stage1GenerateReceiptNumberParams},
        TContext
      > => {

      const mutationOptions = getStage1GenerateReceiptNumberMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–≤–µ—Ä—à—É—î –∑–±—ñ—Ä –±–∞–∑–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */
export const stage1CompleteBasicOrder = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1CompleteBasicOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CompleteBasicOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1CompleteBasicOrder>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1CompleteBasicOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1CompleteBasicOrder>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1CompleteBasicOrder(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1CompleteBasicOrderMutationResult = NonNullable<Awaited<ReturnType<typeof stage1CompleteBasicOrder>>>
    
    export type Stage1CompleteBasicOrderMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–µ—Ä—à—É—î –∑–±—ñ—Ä –±–∞–∑–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */
export const useStage1CompleteBasicOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CompleteBasicOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1CompleteBasicOrder>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1CompleteBasicOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –û—á–∏—â—É—î –ø–æ–º–∏–ª–∫–∏ –¥–ª—è —Å–µ—Å—ñ—ó
 */
export const stage1ClearBasicOrderErrors = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/clear-errors`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1ClearBasicOrderErrorsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1ClearBasicOrderErrors>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1ClearBasicOrderErrors>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1ClearBasicOrderErrors'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1ClearBasicOrderErrors>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1ClearBasicOrderErrors(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1ClearBasicOrderErrorsMutationResult = NonNullable<Awaited<ReturnType<typeof stage1ClearBasicOrderErrors>>>
    
    export type Stage1ClearBasicOrderErrorsMutationError = ErrorResponse

    /**
 * @summary –û—á–∏—â—É—î –ø–æ–º–∏–ª–∫–∏ –¥–ª—è —Å–µ—Å—ñ—ó
 */
export const useStage1ClearBasicOrderErrors = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1ClearBasicOrderErrors>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1ClearBasicOrderErrors>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1ClearBasicOrderErrorsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î –∑–±—ñ—Ä –±–∞–∑–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const stage1InitializeBasicOrder = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string>(
      {url: `/v1/order-wizard/stage1/basic-order/initialize`, method: 'POST', signal
    },
      options);
    }
  


export const getStage1InitializeBasicOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1InitializeBasicOrder>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1InitializeBasicOrder>>, TError,void, TContext> => {

const mutationKey = ['stage1InitializeBasicOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1InitializeBasicOrder>>, void> = () => {
          

          return  stage1InitializeBasicOrder(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1InitializeBasicOrderMutationResult = NonNullable<Awaited<ReturnType<typeof stage1InitializeBasicOrder>>>
    
    export type Stage1InitializeBasicOrderMutationError = ErrorResponse

    /**
 * @summary –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î –∑–±—ñ—Ä –±–∞–∑–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const useStage1InitializeBasicOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1InitializeBasicOrder>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1InitializeBasicOrder>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getStage1InitializeBasicOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–ø—É—Å–∫–∞—î –Ω–æ–≤–∏–π Order Wizard
 */
export const orderWizardStart = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardResponseDTO>(
      {url: `/order-wizard/start`, method: 'POST', signal
    },
      options);
    }
  


export const getOrderWizardStartMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardStart>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof orderWizardStart>>, TError,void, TContext> => {

const mutationKey = ['orderWizardStart'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof orderWizardStart>>, void> = () => {
          

          return  orderWizardStart(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrderWizardStartMutationResult = NonNullable<Awaited<ReturnType<typeof orderWizardStart>>>
    
    export type OrderWizardStartMutationError = ErrorResponse

    /**
 * @summary –ó–∞–ø—É—Å–∫–∞—î –Ω–æ–≤–∏–π Order Wizard
 */
export const useOrderWizardStart = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardStart>>, TError,void, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof orderWizardStart>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getOrderWizardStartMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –Ω–∞ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –µ—Ç–∞–ø
 */
export const orderWizardGoBack = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardResponseDTO>(
      {url: `/order-wizard/session/${sessionId}/go-back`, method: 'POST', signal
    },
      options);
    }
  


export const getOrderWizardGoBackMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardGoBack>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof orderWizardGoBack>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['orderWizardGoBack'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof orderWizardGoBack>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  orderWizardGoBack(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrderWizardGoBackMutationResult = NonNullable<Awaited<ReturnType<typeof orderWizardGoBack>>>
    
    export type OrderWizardGoBackMutationError = ErrorResponse

    /**
 * @summary –ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –Ω–∞ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –µ—Ç–∞–ø
 */
export const useOrderWizardGoBack = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardGoBack>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof orderWizardGoBack>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getOrderWizardGoBackMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ü–µ—Ä–µ—Ö—ñ–¥ –¥–æ Stage4 –∑ Stage3
 */
export const orderWizardCompleteStage3 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardResponseDTO>(
      {url: `/order-wizard/session/${sessionId}/complete-stage3`, method: 'POST', signal
    },
      options);
    }
  


export const getOrderWizardCompleteStage3MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteStage3>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteStage3>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['orderWizardCompleteStage3'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof orderWizardCompleteStage3>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  orderWizardCompleteStage3(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrderWizardCompleteStage3MutationResult = NonNullable<Awaited<ReturnType<typeof orderWizardCompleteStage3>>>
    
    export type OrderWizardCompleteStage3MutationError = ErrorResponse

    /**
 * @summary –ü–µ—Ä–µ—Ö—ñ–¥ –¥–æ Stage4 –∑ Stage3
 */
export const useOrderWizardCompleteStage3 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteStage3>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof orderWizardCompleteStage3>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getOrderWizardCompleteStage3MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ü–µ—Ä–µ—Ö—ñ–¥ –¥–æ Stage3 –∑ Stage2
 */
export const orderWizardCompleteStage2 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardResponseDTO>(
      {url: `/order-wizard/session/${sessionId}/complete-stage2`, method: 'POST', signal
    },
      options);
    }
  


export const getOrderWizardCompleteStage2MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteStage2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteStage2>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['orderWizardCompleteStage2'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof orderWizardCompleteStage2>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  orderWizardCompleteStage2(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrderWizardCompleteStage2MutationResult = NonNullable<Awaited<ReturnType<typeof orderWizardCompleteStage2>>>
    
    export type OrderWizardCompleteStage2MutationError = ErrorResponse

    /**
 * @summary –ü–µ—Ä–µ—Ö—ñ–¥ –¥–æ Stage3 –∑ Stage2
 */
export const useOrderWizardCompleteStage2 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteStage2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof orderWizardCompleteStage2>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getOrderWizardCompleteStage2MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ü–µ—Ä–µ—Ö—ñ–¥ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –µ—Ç–∞–ø—É –∑ Stage1 –¥–æ Stage2
 */
export const orderWizardCompleteStage1 = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardResponseDTO>(
      {url: `/order-wizard/session/${sessionId}/complete-stage1`, method: 'POST', signal
    },
      options);
    }
  


export const getOrderWizardCompleteStage1MutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteStage1>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteStage1>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['orderWizardCompleteStage1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof orderWizardCompleteStage1>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  orderWizardCompleteStage1(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrderWizardCompleteStage1MutationResult = NonNullable<Awaited<ReturnType<typeof orderWizardCompleteStage1>>>
    
    export type OrderWizardCompleteStage1MutationError = ErrorResponse

    /**
 * @summary –ü–µ—Ä–µ—Ö—ñ–¥ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –µ—Ç–∞–ø—É –∑ Stage1 –¥–æ Stage2
 */
export const useOrderWizardCompleteStage1 = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteStage1>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof orderWizardCompleteStage1>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getOrderWizardCompleteStage1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è Order Wizard
 */
export const orderWizardCompleteOrder = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardResponseDTO>(
      {url: `/order-wizard/session/${sessionId}/complete-order`, method: 'POST', signal
    },
      options);
    }
  


export const getOrderWizardCompleteOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteOrder>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['orderWizardCompleteOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof orderWizardCompleteOrder>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  orderWizardCompleteOrder(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrderWizardCompleteOrderMutationResult = NonNullable<Awaited<ReturnType<typeof orderWizardCompleteOrder>>>
    
    export type OrderWizardCompleteOrderMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è Order Wizard
 */
export const useOrderWizardCompleteOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardCompleteOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof orderWizardCompleteOrder>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getOrderWizardCompleteOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°–∫–∞—Å—É–≤–∞–Ω–Ω—è Order Wizard
 */
export const orderWizardCancelOrder = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardResponseDTO>(
      {url: `/order-wizard/session/${sessionId}/cancel`, method: 'POST', signal
    },
      options);
    }
  


export const getOrderWizardCancelOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardCancelOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof orderWizardCancelOrder>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['orderWizardCancelOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof orderWizardCancelOrder>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  orderWizardCancelOrder(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrderWizardCancelOrderMutationResult = NonNullable<Awaited<ReturnType<typeof orderWizardCancelOrder>>>
    
    export type OrderWizardCancelOrderMutationError = ErrorResponse

    /**
 * @summary –°–∫–∞—Å—É–≤–∞–Ω–Ω—è Order Wizard
 */
export const useOrderWizardCancelOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof orderWizardCancelOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof orderWizardCancelOrder>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getOrderWizardCancelOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ü–æ–≤–Ω–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è Stage4
 */
export const stage4ValidateComplete = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4ValidateComplete200>(
      {url: `/v1/order-wizard/stage4/validate/complete/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getStage4ValidateCompleteQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage4/validate/complete/${sessionId}`] as const;
    }

    
export const getStage4ValidateCompleteInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage4ValidateComplete>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage4ValidateCompleteQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage4ValidateComplete>>> = ({ signal }) => stage4ValidateComplete(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage4ValidateCompleteInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage4ValidateComplete>>>
export type Stage4ValidateCompleteInfiniteQueryError = ErrorResponse


export function useStage4ValidateCompleteInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4ValidateComplete>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4ValidateComplete>>,
          TError,
          Awaited<ReturnType<typeof stage4ValidateComplete>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4ValidateCompleteInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4ValidateComplete>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4ValidateComplete>>,
          TError,
          Awaited<ReturnType<typeof stage4ValidateComplete>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4ValidateCompleteInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4ValidateComplete>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–æ–≤–Ω–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è Stage4
 */

export function useStage4ValidateCompleteInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4ValidateComplete>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage4ValidateCompleteInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage4ValidateCompleteQueryOptions = <TData = Awaited<ReturnType<typeof stage4ValidateComplete>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage4ValidateCompleteQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage4ValidateComplete>>> = ({ signal }) => stage4ValidateComplete(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage4ValidateCompleteQueryResult = NonNullable<Awaited<ReturnType<typeof stage4ValidateComplete>>>
export type Stage4ValidateCompleteQueryError = ErrorResponse


export function useStage4ValidateComplete<TData = Awaited<ReturnType<typeof stage4ValidateComplete>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4ValidateComplete>>,
          TError,
          Awaited<ReturnType<typeof stage4ValidateComplete>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4ValidateComplete<TData = Awaited<ReturnType<typeof stage4ValidateComplete>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4ValidateComplete>>,
          TError,
          Awaited<ReturnType<typeof stage4ValidateComplete>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4ValidateComplete<TData = Awaited<ReturnType<typeof stage4ValidateComplete>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–æ–≤–Ω–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è Stage4
 */

export function useStage4ValidateComplete<TData = Awaited<ReturnType<typeof stage4ValidateComplete>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4ValidateComplete>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage4ValidateCompleteQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É —Å–µ—Å—ñ—ó
 */
export const stage4GetSessionContext = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4GetSessionContext200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getStage4GetSessionContextQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage4/session/${sessionId}`] as const;
    }

    
export const getStage4GetSessionContextInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage4GetSessionContext>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage4GetSessionContextQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage4GetSessionContext>>> = ({ signal }) => stage4GetSessionContext(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage4GetSessionContextInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage4GetSessionContext>>>
export type Stage4GetSessionContextInfiniteQueryError = ErrorResponse


export function useStage4GetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetSessionContext>>,
          TError,
          Awaited<ReturnType<typeof stage4GetSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetSessionContext>>,
          TError,
          Awaited<ReturnType<typeof stage4GetSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É —Å–µ—Å—ñ—ó
 */

export function useStage4GetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage4GetSessionContextInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage4GetSessionContextQueryOptions = <TData = Awaited<ReturnType<typeof stage4GetSessionContext>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage4GetSessionContextQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage4GetSessionContext>>> = ({ signal }) => stage4GetSessionContext(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage4GetSessionContextQueryResult = NonNullable<Awaited<ReturnType<typeof stage4GetSessionContext>>>
export type Stage4GetSessionContextQueryError = ErrorResponse


export function useStage4GetSessionContext<TData = Awaited<ReturnType<typeof stage4GetSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetSessionContext>>,
          TError,
          Awaited<ReturnType<typeof stage4GetSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetSessionContext<TData = Awaited<ReturnType<typeof stage4GetSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetSessionContext>>,
          TError,
          Awaited<ReturnType<typeof stage4GetSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetSessionContext<TData = Awaited<ReturnType<typeof stage4GetSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É —Å–µ—Å—ñ—ó
 */

export function useStage4GetSessionContext<TData = Awaited<ReturnType<typeof stage4GetSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage4GetSessionContextQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É Stage4
 */
export const stage4GetCurrentState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4GetCurrentState200>(
      {url: `/v1/order-wizard/stage4/session/${sessionId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getStage4GetCurrentStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage4/session/${sessionId}/state`] as const;
    }

    
export const getStage4GetCurrentStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage4GetCurrentState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage4GetCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage4GetCurrentState>>> = ({ signal }) => stage4GetCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage4GetCurrentStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage4GetCurrentState>>>
export type Stage4GetCurrentStateInfiniteQueryError = ErrorResponse


export function useStage4GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage4GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage4GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É Stage4
 */

export function useStage4GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage4GetCurrentStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage4GetCurrentStateQueryOptions = <TData = Awaited<ReturnType<typeof stage4GetCurrentState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage4GetCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage4GetCurrentState>>> = ({ signal }) => stage4GetCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage4GetCurrentStateQueryResult = NonNullable<Awaited<ReturnType<typeof stage4GetCurrentState>>>
export type Stage4GetCurrentStateQueryError = ErrorResponse


export function useStage4GetCurrentState<TData = Awaited<ReturnType<typeof stage4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage4GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetCurrentState<TData = Awaited<ReturnType<typeof stage4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage4GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetCurrentState<TData = Awaited<ReturnType<typeof stage4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É Stage4
 */

export function useStage4GetCurrentState<TData = Awaited<ReturnType<typeof stage4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage4GetCurrentStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –ø—ñ–¥—Å—É–º–∫—É –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */
export const stage4GetOrderSummary = (
    orderId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage4GetOrderSummary200>(
      {url: `/v1/order-wizard/stage4/order/${orderId}/summary`, method: 'GET', signal
    },
      options);
    }
  

export const getStage4GetOrderSummaryQueryKey = (orderId: string,) => {
    return [`/v1/order-wizard/stage4/order/${orderId}/summary`] as const;
    }

    
export const getStage4GetOrderSummaryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage4GetOrderSummary>>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage4GetOrderSummaryQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage4GetOrderSummary>>> = ({ signal }) => stage4GetOrderSummary(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage4GetOrderSummaryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage4GetOrderSummary>>>
export type Stage4GetOrderSummaryInfiniteQueryError = ErrorResponse


export function useStage4GetOrderSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetOrderSummary>>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetOrderSummary>>,
          TError,
          Awaited<ReturnType<typeof stage4GetOrderSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetOrderSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetOrderSummary>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetOrderSummary>>,
          TError,
          Awaited<ReturnType<typeof stage4GetOrderSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetOrderSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetOrderSummary>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –ø—ñ–¥—Å—É–º–∫—É –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useStage4GetOrderSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage4GetOrderSummary>>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage4GetOrderSummaryInfiniteQueryOptions(orderId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage4GetOrderSummaryQueryOptions = <TData = Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError = ErrorResponse>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage4GetOrderSummaryQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage4GetOrderSummary>>> = ({ signal }) => stage4GetOrderSummary(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage4GetOrderSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof stage4GetOrderSummary>>>
export type Stage4GetOrderSummaryQueryError = ErrorResponse


export function useStage4GetOrderSummary<TData = Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError = ErrorResponse>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetOrderSummary>>,
          TError,
          Awaited<ReturnType<typeof stage4GetOrderSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetOrderSummary<TData = Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage4GetOrderSummary>>,
          TError,
          Awaited<ReturnType<typeof stage4GetOrderSummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage4GetOrderSummary<TData = Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –ø—ñ–¥—Å—É–º–∫—É –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è
 */

export function useStage4GetOrderSummary<TData = Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError = ErrorResponse>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage4GetOrderSummary>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage4GetOrderSummaryQueryOptions(orderId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –í–∞–ª—ñ–¥—É–≤–∞—Ç–∏ –≤—Å—ñ –ø—ñ–¥–µ—Ç–∞–ø–∏
 */
export const stage3ValidateAllSubsteps = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/validate-all`, method: 'GET', signal
    },
      options);
    }
  

export const getStage3ValidateAllSubstepsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/validate-all`] as const;
    }

    
export const getStage3ValidateAllSubstepsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3ValidateAllSubstepsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>> = ({ signal }) => stage3ValidateAllSubsteps(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3ValidateAllSubstepsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>>
export type Stage3ValidateAllSubstepsInfiniteQueryError = ErrorResponse


export function useStage3ValidateAllSubstepsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>,
          TError,
          Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3ValidateAllSubstepsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>,
          TError,
          Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3ValidateAllSubstepsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –í–∞–ª—ñ–¥—É–≤–∞—Ç–∏ –≤—Å—ñ –ø—ñ–¥–µ—Ç–∞–ø–∏
 */

export function useStage3ValidateAllSubstepsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3ValidateAllSubstepsInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage3ValidateAllSubstepsQueryOptions = <TData = Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3ValidateAllSubstepsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>> = ({ signal }) => stage3ValidateAllSubsteps(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3ValidateAllSubstepsQueryResult = NonNullable<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>>
export type Stage3ValidateAllSubstepsQueryError = ErrorResponse


export function useStage3ValidateAllSubsteps<TData = Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>,
          TError,
          Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3ValidateAllSubsteps<TData = Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>,
          TError,
          Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3ValidateAllSubsteps<TData = Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –í–∞–ª—ñ–¥—É–≤–∞—Ç–∏ –≤—Å—ñ –ø—ñ–¥–µ—Ç–∞–ø–∏
 */

export function useStage3ValidateAllSubsteps<TData = Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3ValidateAllSubsteps>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3ValidateAllSubstepsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç–∞–Ω —Å–µ—Å—ñ—ó
 */
export const stage3GetSessionState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage3GetSessionState200>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getStage3GetSessionStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/state`] as const;
    }

    
export const getStage3GetSessionStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3GetSessionStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3GetSessionState>>> = ({ signal }) => stage3GetSessionState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3GetSessionStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage3GetSessionState>>>
export type Stage3GetSessionStateInfiniteQueryError = ErrorResponse


export function useStage3GetSessionStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionState>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionState>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç–∞–Ω —Å–µ—Å—ñ—ó
 */

export function useStage3GetSessionStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3GetSessionStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage3GetSessionStateQueryOptions = <TData = Awaited<ReturnType<typeof stage3GetSessionState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3GetSessionStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3GetSessionState>>> = ({ signal }) => stage3GetSessionState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3GetSessionStateQueryResult = NonNullable<Awaited<ReturnType<typeof stage3GetSessionState>>>
export type Stage3GetSessionStateQueryError = ErrorResponse


export function useStage3GetSessionState<TData = Awaited<ReturnType<typeof stage3GetSessionState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionState>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionState<TData = Awaited<ReturnType<typeof stage3GetSessionState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionState>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionState<TData = Awaited<ReturnType<typeof stage3GetSessionState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç–∞–Ω —Å–µ—Å—ñ—ó
 */

export function useStage3GetSessionState<TData = Awaited<ReturnType<typeof stage3GetSessionState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3GetSessionStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å Stage3
 */
export const stage3IsStageReady = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/ready`, method: 'GET', signal
    },
      options);
    }
  

export const getStage3IsStageReadyQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/ready`] as const;
    }

    
export const getStage3IsStageReadyInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage3IsStageReady>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3IsStageReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3IsStageReady>>> = ({ signal }) => stage3IsStageReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3IsStageReadyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage3IsStageReady>>>
export type Stage3IsStageReadyInfiniteQueryError = ErrorResponse


export function useStage3IsStageReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsStageReady>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsStageReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsStageReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsStageReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsStageReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsStageReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsStageReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsStageReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsStageReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å Stage3
 */

export function useStage3IsStageReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsStageReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3IsStageReadyInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage3IsStageReadyQueryOptions = <TData = Awaited<ReturnType<typeof stage3IsStageReady>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3IsStageReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3IsStageReady>>> = ({ signal }) => stage3IsStageReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3IsStageReadyQueryResult = NonNullable<Awaited<ReturnType<typeof stage3IsStageReady>>>
export type Stage3IsStageReadyQueryError = ErrorResponse


export function useStage3IsStageReady<TData = Awaited<ReturnType<typeof stage3IsStageReady>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsStageReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsStageReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsStageReady<TData = Awaited<ReturnType<typeof stage3IsStageReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsStageReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsStageReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsStageReady<TData = Awaited<ReturnType<typeof stage3IsStageReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å Stage3
 */

export function useStage3IsStageReady<TData = Awaited<ReturnType<typeof stage3IsStageReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsStageReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3IsStageReadyQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å —Å–µ—Å—ñ—ó
 */
export const stage3GetSessionProgress = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<number>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/progress`, method: 'GET', signal
    },
      options);
    }
  

export const getStage3GetSessionProgressQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/progress`] as const;
    }

    
export const getStage3GetSessionProgressInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionProgress>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3GetSessionProgressQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3GetSessionProgress>>> = ({ signal }) => stage3GetSessionProgress(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3GetSessionProgressInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage3GetSessionProgress>>>
export type Stage3GetSessionProgressInfiniteQueryError = ErrorResponse


export function useStage3GetSessionProgressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionProgress>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionProgress>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionProgressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionProgress>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionProgress>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionProgressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionProgress>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å —Å–µ—Å—ñ—ó
 */

export function useStage3GetSessionProgressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionProgress>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3GetSessionProgressInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage3GetSessionProgressQueryOptions = <TData = Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3GetSessionProgressQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3GetSessionProgress>>> = ({ signal }) => stage3GetSessionProgress(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3GetSessionProgressQueryResult = NonNullable<Awaited<ReturnType<typeof stage3GetSessionProgress>>>
export type Stage3GetSessionProgressQueryError = ErrorResponse


export function useStage3GetSessionProgress<TData = Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionProgress>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionProgress<TData = Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionProgress>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionProgress<TData = Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å —Å–µ—Å—ñ—ó
 */

export function useStage3GetSessionProgress<TData = Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionProgress>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3GetSessionProgressQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –æ–ø–ª–∞—Ç–∏
 */
export const stage3IsPaymentConfigReady = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/payment-config/ready`, method: 'GET', signal
    },
      options);
    }
  

export const getStage3IsPaymentConfigReadyQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/payment-config/ready`] as const;
    }

    
export const getStage3IsPaymentConfigReadyInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3IsPaymentConfigReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>> = ({ signal }) => stage3IsPaymentConfigReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3IsPaymentConfigReadyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>>
export type Stage3IsPaymentConfigReadyInfiniteQueryError = ErrorResponse


export function useStage3IsPaymentConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsPaymentConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsPaymentConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –æ–ø–ª–∞—Ç–∏
 */

export function useStage3IsPaymentConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3IsPaymentConfigReadyInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage3IsPaymentConfigReadyQueryOptions = <TData = Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3IsPaymentConfigReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>> = ({ signal }) => stage3IsPaymentConfigReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3IsPaymentConfigReadyQueryResult = NonNullable<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>>
export type Stage3IsPaymentConfigReadyQueryError = ErrorResponse


export function useStage3IsPaymentConfigReady<TData = Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsPaymentConfigReady<TData = Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsPaymentConfigReady<TData = Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –æ–ø–ª–∞—Ç–∏
 */

export function useStage3IsPaymentConfigReady<TData = Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsPaymentConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3IsPaymentConfigReadyQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –ø—ñ–¥–µ—Ç–∞–ø
 */
export const stage3GetNextSubstep = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage3GetNextSubstep200>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/next-substep`, method: 'GET', signal
    },
      options);
    }
  

export const getStage3GetNextSubstepQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/next-substep`] as const;
    }

    
export const getStage3GetNextSubstepInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage3GetNextSubstep>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3GetNextSubstepQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3GetNextSubstep>>> = ({ signal }) => stage3GetNextSubstep(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3GetNextSubstepInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage3GetNextSubstep>>>
export type Stage3GetNextSubstepInfiniteQueryError = ErrorResponse


export function useStage3GetNextSubstepInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetNextSubstep>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetNextSubstep>>,
          TError,
          Awaited<ReturnType<typeof stage3GetNextSubstep>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetNextSubstepInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetNextSubstep>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetNextSubstep>>,
          TError,
          Awaited<ReturnType<typeof stage3GetNextSubstep>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetNextSubstepInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetNextSubstep>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –ø—ñ–¥–µ—Ç–∞–ø
 */

export function useStage3GetNextSubstepInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetNextSubstep>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3GetNextSubstepInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage3GetNextSubstepQueryOptions = <TData = Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3GetNextSubstepQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3GetNextSubstep>>> = ({ signal }) => stage3GetNextSubstep(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3GetNextSubstepQueryResult = NonNullable<Awaited<ReturnType<typeof stage3GetNextSubstep>>>
export type Stage3GetNextSubstepQueryError = ErrorResponse


export function useStage3GetNextSubstep<TData = Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetNextSubstep>>,
          TError,
          Awaited<ReturnType<typeof stage3GetNextSubstep>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetNextSubstep<TData = Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetNextSubstep>>,
          TError,
          Awaited<ReturnType<typeof stage3GetNextSubstep>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetNextSubstep<TData = Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –ø—ñ–¥–µ—Ç–∞–ø
 */

export function useStage3GetNextSubstep<TData = Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetNextSubstep>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3GetNextSubstepQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è
 */
export const stage3IsExecutionParamsReady = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/execution-params/ready`, method: 'GET', signal
    },
      options);
    }
  

export const getStage3IsExecutionParamsReadyQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/execution-params/ready`] as const;
    }

    
export const getStage3IsExecutionParamsReadyInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3IsExecutionParamsReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>> = ({ signal }) => stage3IsExecutionParamsReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3IsExecutionParamsReadyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>>
export type Stage3IsExecutionParamsReadyInfiniteQueryError = ErrorResponse


export function useStage3IsExecutionParamsReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsExecutionParamsReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsExecutionParamsReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è
 */

export function useStage3IsExecutionParamsReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3IsExecutionParamsReadyInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage3IsExecutionParamsReadyQueryOptions = <TData = Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3IsExecutionParamsReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>> = ({ signal }) => stage3IsExecutionParamsReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3IsExecutionParamsReadyQueryResult = NonNullable<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>>
export type Stage3IsExecutionParamsReadyQueryError = ErrorResponse


export function useStage3IsExecutionParamsReady<TData = Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsExecutionParamsReady<TData = Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsExecutionParamsReady<TData = Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è
 */

export function useStage3IsExecutionParamsReady<TData = Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsExecutionParamsReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3IsExecutionParamsReadyQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –∑–Ω–∏–∂–æ–∫
 */
export const stage3IsDiscountConfigReady = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/discount-config/ready`, method: 'GET', signal
    },
      options);
    }
  

export const getStage3IsDiscountConfigReadyQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/discount-config/ready`] as const;
    }

    
export const getStage3IsDiscountConfigReadyInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3IsDiscountConfigReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>> = ({ signal }) => stage3IsDiscountConfigReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3IsDiscountConfigReadyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>>
export type Stage3IsDiscountConfigReadyInfiniteQueryError = ErrorResponse


export function useStage3IsDiscountConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsDiscountConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsDiscountConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –∑–Ω–∏–∂–æ–∫
 */

export function useStage3IsDiscountConfigReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3IsDiscountConfigReadyInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage3IsDiscountConfigReadyQueryOptions = <TData = Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3IsDiscountConfigReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>> = ({ signal }) => stage3IsDiscountConfigReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3IsDiscountConfigReadyQueryResult = NonNullable<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>>
export type Stage3IsDiscountConfigReadyQueryError = ErrorResponse


export function useStage3IsDiscountConfigReady<TData = Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsDiscountConfigReady<TData = Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsDiscountConfigReady<TData = Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –∑–Ω–∏–∂–æ–∫
 */

export function useStage3IsDiscountConfigReady<TData = Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsDiscountConfigReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3IsDiscountConfigReadyQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–µ—Å—ñ—ó
 */
export const stage3GetSessionContext = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage3Context>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/context`, method: 'GET', signal
    },
      options);
    }
  

export const getStage3GetSessionContextQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/context`] as const;
    }

    
export const getStage3GetSessionContextInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionContext>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3GetSessionContextQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3GetSessionContext>>> = ({ signal }) => stage3GetSessionContext(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3GetSessionContextInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage3GetSessionContext>>>
export type Stage3GetSessionContextInfiniteQueryError = ErrorResponse


export function useStage3GetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionContext>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionContext>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–µ—Å—ñ—ó
 */

export function useStage3GetSessionContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3GetSessionContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3GetSessionContextInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage3GetSessionContextQueryOptions = <TData = Awaited<ReturnType<typeof stage3GetSessionContext>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3GetSessionContextQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3GetSessionContext>>> = ({ signal }) => stage3GetSessionContext(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3GetSessionContextQueryResult = NonNullable<Awaited<ReturnType<typeof stage3GetSessionContext>>>
export type Stage3GetSessionContextQueryError = ErrorResponse


export function useStage3GetSessionContext<TData = Awaited<ReturnType<typeof stage3GetSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionContext>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionContext<TData = Awaited<ReturnType<typeof stage3GetSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3GetSessionContext>>,
          TError,
          Awaited<ReturnType<typeof stage3GetSessionContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3GetSessionContext<TData = Awaited<ReturnType<typeof stage3GetSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞—Ç–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–µ—Å—ñ—ó
 */

export function useStage3GetSessionContext<TData = Awaited<ReturnType<typeof stage3GetSessionContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3GetSessionContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3GetSessionContextQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –¥–æ–¥–∞—Ç–∫–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */
export const stage3IsAdditionalInfoReady = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage3/sessions/${sessionId}/additional-info/ready`, method: 'GET', signal
    },
      options);
    }
  

export const getStage3IsAdditionalInfoReadyQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage3/sessions/${sessionId}/additional-info/ready`] as const;
    }

    
export const getStage3IsAdditionalInfoReadyInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3IsAdditionalInfoReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>> = ({ signal }) => stage3IsAdditionalInfoReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3IsAdditionalInfoReadyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>>
export type Stage3IsAdditionalInfoReadyInfiniteQueryError = ErrorResponse


export function useStage3IsAdditionalInfoReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsAdditionalInfoReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsAdditionalInfoReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –¥–æ–¥–∞—Ç–∫–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */

export function useStage3IsAdditionalInfoReadyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3IsAdditionalInfoReadyInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage3IsAdditionalInfoReadyQueryOptions = <TData = Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage3IsAdditionalInfoReadyQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>> = ({ signal }) => stage3IsAdditionalInfoReady(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage3IsAdditionalInfoReadyQueryResult = NonNullable<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>>
export type Stage3IsAdditionalInfoReadyQueryError = ErrorResponse


export function useStage3IsAdditionalInfoReady<TData = Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsAdditionalInfoReady<TData = Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>,
          TError,
          Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage3IsAdditionalInfoReady<TData = Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –¥–æ–¥–∞—Ç–∫–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */

export function useStage3IsAdditionalInfoReady<TData = Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage3IsAdditionalInfoReady>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage3IsAdditionalInfoReadyQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –í–∞–ª—ñ–¥—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –º–µ–Ω–µ–¥–∂–µ—Ä–∞
 */
export const stage2ValidateCurrentState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ValidationResult>(
      {url: `/v1/order-wizard/stage2/validate/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getStage2ValidateCurrentStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/validate/${sessionId}`] as const;
    }

    
export const getStage2ValidateCurrentStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage2ValidateCurrentState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage2ValidateCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage2ValidateCurrentState>>> = ({ signal }) => stage2ValidateCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage2ValidateCurrentStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage2ValidateCurrentState>>>
export type Stage2ValidateCurrentStateInfiniteQueryError = ErrorResponse


export function useStage2ValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2ValidateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2ValidateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage2ValidateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2ValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2ValidateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2ValidateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage2ValidateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2ValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2ValidateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –í–∞–ª—ñ–¥—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –º–µ–Ω–µ–¥–∂–µ—Ä–∞
 */

export function useStage2ValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2ValidateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage2ValidateCurrentStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage2ValidateCurrentStateQueryOptions = <TData = Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage2ValidateCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage2ValidateCurrentState>>> = ({ signal }) => stage2ValidateCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage2ValidateCurrentStateQueryResult = NonNullable<Awaited<ReturnType<typeof stage2ValidateCurrentState>>>
export type Stage2ValidateCurrentStateQueryError = ErrorResponse


export function useStage2ValidateCurrentState<TData = Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2ValidateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage2ValidateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2ValidateCurrentState<TData = Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2ValidateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage2ValidateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2ValidateCurrentState<TData = Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –í–∞–ª—ñ–¥—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –º–µ–Ω–µ–¥–∂–µ—Ä–∞
 */

export function useStage2ValidateCurrentState<TData = Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage2ValidateCurrentStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å—Ç–∞—Ç—É—Å—É —Ñ–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
 */
export const substep5GetDocumentationStatus = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}/status`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep5GetDocumentationStatusQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep5/${sessionId}/status`] as const;
    }

    
export const getSubstep5GetDocumentationStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep5GetDocumentationStatusQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>> = ({ signal }) => substep5GetDocumentationStatus(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep5GetDocumentationStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>>
export type Substep5GetDocumentationStatusInfiniteQueryError = ErrorResponse


export function useSubstep5GetDocumentationStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep5GetDocumentationStatus>>,
          TError,
          Awaited<ReturnType<typeof substep5GetDocumentationStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep5GetDocumentationStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep5GetDocumentationStatus>>,
          TError,
          Awaited<ReturnType<typeof substep5GetDocumentationStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep5GetDocumentationStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å—Ç–∞—Ç—É—Å—É —Ñ–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
 */

export function useSubstep5GetDocumentationStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep5GetDocumentationStatusInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep5GetDocumentationStatusQueryOptions = <TData = Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep5GetDocumentationStatusQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>> = ({ signal }) => substep5GetDocumentationStatus(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep5GetDocumentationStatusQueryResult = NonNullable<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>>
export type Substep5GetDocumentationStatusQueryError = ErrorResponse


export function useSubstep5GetDocumentationStatus<TData = Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep5GetDocumentationStatus>>,
          TError,
          Awaited<ReturnType<typeof substep5GetDocumentationStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep5GetDocumentationStatus<TData = Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep5GetDocumentationStatus>>,
          TError,
          Awaited<ReturnType<typeof substep5GetDocumentationStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep5GetDocumentationStatus<TData = Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å—Ç–∞—Ç—É—Å—É —Ñ–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
 */

export function useSubstep5GetDocumentationStatus<TData = Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep5GetDocumentationStatusQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö —Ñ–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
 */
export const substep5GetDocumentationData = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PhotoDocumentationDTO>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}/data`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep5GetDocumentationDataQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep5/${sessionId}/data`] as const;
    }

    
export const getSubstep5GetDocumentationDataInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep5GetDocumentationData>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep5GetDocumentationDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep5GetDocumentationData>>> = ({ signal }) => substep5GetDocumentationData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep5GetDocumentationDataInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep5GetDocumentationData>>>
export type Substep5GetDocumentationDataInfiniteQueryError = ErrorResponse


export function useSubstep5GetDocumentationDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep5GetDocumentationData>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep5GetDocumentationData>>,
          TError,
          Awaited<ReturnType<typeof substep5GetDocumentationData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep5GetDocumentationDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep5GetDocumentationData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep5GetDocumentationData>>,
          TError,
          Awaited<ReturnType<typeof substep5GetDocumentationData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep5GetDocumentationDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep5GetDocumentationData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö —Ñ–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
 */

export function useSubstep5GetDocumentationDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep5GetDocumentationData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep5GetDocumentationDataInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep5GetDocumentationDataQueryOptions = <TData = Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep5GetDocumentationDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep5GetDocumentationData>>> = ({ signal }) => substep5GetDocumentationData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep5GetDocumentationDataQueryResult = NonNullable<Awaited<ReturnType<typeof substep5GetDocumentationData>>>
export type Substep5GetDocumentationDataQueryError = ErrorResponse


export function useSubstep5GetDocumentationData<TData = Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep5GetDocumentationData>>,
          TError,
          Awaited<ReturnType<typeof substep5GetDocumentationData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep5GetDocumentationData<TData = Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep5GetDocumentationData>>,
          TError,
          Awaited<ReturnType<typeof substep5GetDocumentationData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep5GetDocumentationData<TData = Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö —Ñ–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
 */

export function useSubstep5GetDocumentationData<TData = Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep5GetDocumentationData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep5GetDocumentationDataQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const substep4ValidateCurrentState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage2/substep4/validate/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4ValidateCurrentStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/validate/${sessionId}`] as const;
    }

    
export const getSubstep4ValidateCurrentStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep4ValidateCurrentState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4ValidateCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4ValidateCurrentState>>> = ({ signal }) => substep4ValidateCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4ValidateCurrentStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep4ValidateCurrentState>>>
export type Substep4ValidateCurrentStateInfiniteQueryError = ErrorResponse


export function useSubstep4ValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4ValidateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4ValidateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4ValidateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */

export function useSubstep4ValidateCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4ValidateCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4ValidateCurrentStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep4ValidateCurrentStateQueryOptions = <TData = Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4ValidateCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4ValidateCurrentState>>> = ({ signal }) => substep4ValidateCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4ValidateCurrentStateQueryResult = NonNullable<Awaited<ReturnType<typeof substep4ValidateCurrentState>>>
export type Substep4ValidateCurrentStateQueryError = ErrorResponse


export function useSubstep4ValidateCurrentState<TData = Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateCurrentState<TData = Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateCurrentState<TData = Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –í–∞–ª—ñ–¥–∞—Ü—ñ—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */

export function useSubstep4ValidateCurrentState<TData = Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4ValidateCurrentStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –î–µ—Ç–∞–ª—å–Ω–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º
 */
export const substep4ValidateDetailed = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/validate-detailed/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4ValidateDetailedQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/validate-detailed/${sessionId}`] as const;
    }

    
export const getSubstep4ValidateDetailedInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep4ValidateDetailed>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4ValidateDetailedQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4ValidateDetailed>>> = ({ signal }) => substep4ValidateDetailed(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4ValidateDetailedInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep4ValidateDetailed>>>
export type Substep4ValidateDetailedInfiniteQueryError = ErrorResponse


export function useSubstep4ValidateDetailedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4ValidateDetailed>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateDetailed>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateDetailed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateDetailedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4ValidateDetailed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateDetailed>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateDetailed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateDetailedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4ValidateDetailed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –î–µ—Ç–∞–ª—å–Ω–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º
 */

export function useSubstep4ValidateDetailedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4ValidateDetailed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4ValidateDetailedInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep4ValidateDetailedQueryOptions = <TData = Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4ValidateDetailedQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4ValidateDetailed>>> = ({ signal }) => substep4ValidateDetailed(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4ValidateDetailedQueryResult = NonNullable<Awaited<ReturnType<typeof substep4ValidateDetailed>>>
export type Substep4ValidateDetailedQueryError = ErrorResponse


export function useSubstep4ValidateDetailed<TData = Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateDetailed>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateDetailed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateDetailed<TData = Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4ValidateDetailed>>,
          TError,
          Awaited<ReturnType<typeof substep4ValidateDetailed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4ValidateDetailed<TData = Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –î–µ—Ç–∞–ª—å–Ω–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º
 */

export function useSubstep4ValidateDetailed<TData = Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4ValidateDetailed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4ValidateDetailedQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É –ø—ñ–¥–µ—Ç–∞–ø—É
 */
export const substep4GetCurrentState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/state/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4GetCurrentStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/state/${sessionId}`] as const;
    }

    
export const getSubstep4GetCurrentStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep4GetCurrentState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetCurrentState>>> = ({ signal }) => substep4GetCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetCurrentStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetCurrentState>>>
export type Substep4GetCurrentStateInfiniteQueryError = ErrorResponse


export function useSubstep4GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É –ø—ñ–¥–µ—Ç–∞–ø—É
 */

export function useSubstep4GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetCurrentStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep4GetCurrentStateQueryOptions = <TData = Awaited<ReturnType<typeof substep4GetCurrentState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetCurrentState>>> = ({ signal }) => substep4GetCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetCurrentStateQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetCurrentState>>>
export type Substep4GetCurrentStateQueryError = ErrorResponse


export function useSubstep4GetCurrentState<TData = Awaited<ReturnType<typeof substep4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentState<TData = Awaited<ReturnType<typeof substep4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentState<TData = Awaited<ReturnType<typeof substep4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É –ø—ñ–¥–µ—Ç–∞–ø—É
 */

export function useSubstep4GetCurrentState<TData = Awaited<ReturnType<typeof substep4GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetCurrentStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —ñ—Å–Ω—É–≤–∞–Ω–Ω—è —Å–µ—Å—ñ—ó
 */
export const substep4SessionExists = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage2/substep4/session/${sessionId}/exists`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4SessionExistsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/session/${sessionId}/exists`] as const;
    }

    
export const getSubstep4SessionExistsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep4SessionExists>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4SessionExistsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4SessionExists>>> = ({ signal }) => substep4SessionExists(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4SessionExistsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep4SessionExists>>>
export type Substep4SessionExistsInfiniteQueryError = ErrorResponse


export function useSubstep4SessionExistsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4SessionExists>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4SessionExists>>,
          TError,
          Awaited<ReturnType<typeof substep4SessionExists>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4SessionExistsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4SessionExists>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4SessionExists>>,
          TError,
          Awaited<ReturnType<typeof substep4SessionExists>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4SessionExistsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4SessionExists>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —ñ—Å–Ω—É–≤–∞–Ω–Ω—è —Å–µ—Å—ñ—ó
 */

export function useSubstep4SessionExistsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4SessionExists>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4SessionExistsInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep4SessionExistsQueryOptions = <TData = Awaited<ReturnType<typeof substep4SessionExists>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4SessionExistsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4SessionExists>>> = ({ signal }) => substep4SessionExists(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4SessionExistsQueryResult = NonNullable<Awaited<ReturnType<typeof substep4SessionExists>>>
export type Substep4SessionExistsQueryError = ErrorResponse


export function useSubstep4SessionExists<TData = Awaited<ReturnType<typeof substep4SessionExists>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4SessionExists>>,
          TError,
          Awaited<ReturnType<typeof substep4SessionExists>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4SessionExists<TData = Awaited<ReturnType<typeof substep4SessionExists>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4SessionExists>>,
          TError,
          Awaited<ReturnType<typeof substep4SessionExists>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4SessionExists<TData = Awaited<ReturnType<typeof substep4SessionExists>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —ñ—Å–Ω—É–≤–∞–Ω–Ω—è —Å–µ—Å—ñ—ó
 */

export function useSubstep4SessionExists<TData = Awaited<ReturnType<typeof substep4SessionExists>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4SessionExists>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4SessionExistsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const substep4GetAvailableModifiers = (
    params: Substep4GetAvailableModifiersParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceModifierDTO[]>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSubstep4GetAvailableModifiersQueryKey = (params: Substep4GetAvailableModifiersParams,) => {
    return [`/v1/order-wizard/stage2/substep4/modifiers`, ...(params ? [params]: [])] as const;
    }

    
export const getSubstep4GetAvailableModifiersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>>, TError = ErrorResponse>(params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetAvailableModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>> = ({ signal }) => substep4GetAvailableModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetAvailableModifiersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>>
export type Substep4GetAvailableModifiersInfiniteQueryError = ErrorResponse


export function useSubstep4GetAvailableModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useSubstep4GetAvailableModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetAvailableModifiersInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep4GetAvailableModifiersQueryOptions = <TData = Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError = ErrorResponse>(params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetAvailableModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>> = ({ signal }) => substep4GetAvailableModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetAvailableModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>>
export type Substep4GetAvailableModifiersQueryError = ErrorResponse


export function useSubstep4GetAvailableModifiers<TData = Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableModifiers<TData = Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableModifiers<TData = Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useSubstep4GetAvailableModifiers<TData = Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError = ErrorResponse>(
 params: Substep4GetAvailableModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetAvailableModifiersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤
 */
export const substep4GetRecommendedModifiers = (
    params: Substep4GetRecommendedModifiersParams,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceModifierDTO[]>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers/recommended`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSubstep4GetRecommendedModifiersQueryKey = (params: Substep4GetRecommendedModifiersParams,) => {
    return [`/v1/order-wizard/stage2/substep4/modifiers/recommended`, ...(params ? [params]: [])] as const;
    }

    
export const getSubstep4GetRecommendedModifiersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>>, TError = ErrorResponse>(params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetRecommendedModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>> = ({ signal }) => substep4GetRecommendedModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetRecommendedModifiersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>>
export type Substep4GetRecommendedModifiersInfiniteQueryError = ErrorResponse


export function useSubstep4GetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤
 */

export function useSubstep4GetRecommendedModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetRecommendedModifiersInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep4GetRecommendedModifiersQueryOptions = <TData = Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError = ErrorResponse>(params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetRecommendedModifiersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>> = ({ signal }) => substep4GetRecommendedModifiers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetRecommendedModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>>
export type Substep4GetRecommendedModifiersQueryError = ErrorResponse


export function useSubstep4GetRecommendedModifiers<TData = Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetRecommendedModifiers<TData = Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>,
          TError,
          Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetRecommendedModifiers<TData = Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏—Ö –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤
 */

export function useSubstep4GetRecommendedModifiers<TData = Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError = ErrorResponse>(
 params: Substep4GetRecommendedModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetRecommendedModifiers>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetRecommendedModifiersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –ø–æ–¥—ñ–π –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const substep4GetAvailableEvents = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Substep4GetAvailableEvents200Item[]>(
      {url: `/v1/order-wizard/stage2/substep4/events/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4GetAvailableEventsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/events/${sessionId}`] as const;
    }

    
export const getSubstep4GetAvailableEventsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep4GetAvailableEvents>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetAvailableEventsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetAvailableEvents>>> = ({ signal }) => substep4GetAvailableEvents(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetAvailableEventsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetAvailableEvents>>>
export type Substep4GetAvailableEventsInfiniteQueryError = ErrorResponse


export function useSubstep4GetAvailableEventsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetAvailableEvents>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableEventsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetAvailableEvents>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableEventsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetAvailableEvents>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –ø–æ–¥—ñ–π –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */

export function useSubstep4GetAvailableEventsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetAvailableEvents>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetAvailableEventsInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep4GetAvailableEventsQueryOptions = <TData = Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetAvailableEventsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetAvailableEvents>>> = ({ signal }) => substep4GetAvailableEvents(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetAvailableEventsQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetAvailableEvents>>>
export type Substep4GetAvailableEventsQueryError = ErrorResponse


export function useSubstep4GetAvailableEvents<TData = Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableEvents<TData = Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>,
          TError,
          Awaited<ReturnType<typeof substep4GetAvailableEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetAvailableEvents<TData = Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –ø–æ–¥—ñ–π –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */

export function useSubstep4GetAvailableEvents<TData = Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetAvailableEvents>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetAvailableEventsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–∏—Ö –¥–∞–Ω–∏—Ö —Å–µ—Å—ñ—ó
 */
export const substep4GetCurrentData = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceDiscountDTO>(
      {url: `/v1/order-wizard/stage2/substep4/data/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep4GetCurrentDataQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep4/data/${sessionId}`] as const;
    }

    
export const getSubstep4GetCurrentDataInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep4GetCurrentData>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetCurrentDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetCurrentData>>> = ({ signal }) => substep4GetCurrentData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetCurrentDataInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetCurrentData>>>
export type Substep4GetCurrentDataInfiniteQueryError = ErrorResponse


export function useSubstep4GetCurrentDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetCurrentData>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentData>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetCurrentData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentData>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetCurrentData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–∏—Ö –¥–∞–Ω–∏—Ö —Å–µ—Å—ñ—ó
 */

export function useSubstep4GetCurrentDataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep4GetCurrentData>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetCurrentDataInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep4GetCurrentDataQueryOptions = <TData = Awaited<ReturnType<typeof substep4GetCurrentData>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep4GetCurrentDataQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep4GetCurrentData>>> = ({ signal }) => substep4GetCurrentData(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep4GetCurrentDataQueryResult = NonNullable<Awaited<ReturnType<typeof substep4GetCurrentData>>>
export type Substep4GetCurrentDataQueryError = ErrorResponse


export function useSubstep4GetCurrentData<TData = Awaited<ReturnType<typeof substep4GetCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentData>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentData<TData = Awaited<ReturnType<typeof substep4GetCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep4GetCurrentData>>,
          TError,
          Awaited<ReturnType<typeof substep4GetCurrentData>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep4GetCurrentData<TData = Awaited<ReturnType<typeof substep4GetCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–∏—Ö –¥–∞–Ω–∏—Ö —Å–µ—Å—ñ—ó
 */

export function useSubstep4GetCurrentData<TData = Awaited<ReturnType<typeof substep4GetCurrentData>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep4GetCurrentData>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep4GetCurrentDataQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –ø–ª—è–º
 */
export const substep3GetAvailableStainTypes = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/v1/order-wizard/stage2/substep3/stain-types`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep3GetAvailableStainTypesQueryKey = () => {
    return [`/v1/order-wizard/stage2/substep3/stain-types`] as const;
    }

    
export const getSubstep3GetAvailableStainTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep3GetAvailableStainTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>> = ({ signal }) => substep3GetAvailableStainTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep3GetAvailableStainTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>>
export type Substep3GetAvailableStainTypesInfiniteQueryError = ErrorResponse


export function useSubstep3GetAvailableStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>,
          TError,
          Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetAvailableStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>,
          TError,
          Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetAvailableStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –ø–ª—è–º
 */

export function useSubstep3GetAvailableStainTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep3GetAvailableStainTypesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep3GetAvailableStainTypesQueryOptions = <TData = Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep3GetAvailableStainTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>> = ({ signal }) => substep3GetAvailableStainTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep3GetAvailableStainTypesQueryResult = NonNullable<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>>
export type Substep3GetAvailableStainTypesQueryError = ErrorResponse


export function useSubstep3GetAvailableStainTypes<TData = Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>,
          TError,
          Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetAvailableStainTypes<TData = Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>,
          TError,
          Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetAvailableStainTypes<TData = Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –ø–ª—è–º
 */

export function useSubstep3GetAvailableStainTypes<TData = Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableStainTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep3GetAvailableStainTypesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */
export const substep3GetAvailableDefectTypes = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/v1/order-wizard/stage2/substep3/defect-types`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep3GetAvailableDefectTypesQueryKey = () => {
    return [`/v1/order-wizard/stage2/substep3/defect-types`] as const;
    }

    
export const getSubstep3GetAvailableDefectTypesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep3GetAvailableDefectTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>> = ({ signal }) => substep3GetAvailableDefectTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep3GetAvailableDefectTypesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>>
export type Substep3GetAvailableDefectTypesInfiniteQueryError = ErrorResponse


export function useSubstep3GetAvailableDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetAvailableDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetAvailableDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useSubstep3GetAvailableDefectTypesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep3GetAvailableDefectTypesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep3GetAvailableDefectTypesQueryOptions = <TData = Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep3GetAvailableDefectTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>> = ({ signal }) => substep3GetAvailableDefectTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep3GetAvailableDefectTypesQueryResult = NonNullable<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>>
export type Substep3GetAvailableDefectTypesQueryError = ErrorResponse


export function useSubstep3GetAvailableDefectTypes<TData = Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetAvailableDefectTypes<TData = Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>,
          TError,
          Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetAvailableDefectTypes<TData = Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –¥–µ—Ñ–µ–∫—Ç—ñ–≤
 */

export function useSubstep3GetAvailableDefectTypes<TData = Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetAvailableDefectTypes>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep3GetAvailableDefectTypesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
 */
export const substep3GetContext = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StainsDefectsContext>(
      {url: `/v1/order-wizard/stage2/substep3/context/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep3GetContextQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep3/context/${sessionId}`] as const;
    }

    
export const getSubstep3GetContextInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep3GetContext>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep3GetContextQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep3GetContext>>> = ({ signal }) => substep3GetContext(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep3GetContextInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep3GetContext>>>
export type Substep3GetContextInfiniteQueryError = ErrorResponse


export function useSubstep3GetContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetContext>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetContext>>,
          TError,
          Awaited<ReturnType<typeof substep3GetContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetContext>>,
          TError,
          Awaited<ReturnType<typeof substep3GetContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
 */

export function useSubstep3GetContextInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep3GetContext>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep3GetContextInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep3GetContextQueryOptions = <TData = Awaited<ReturnType<typeof substep3GetContext>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep3GetContextQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep3GetContext>>> = ({ signal }) => substep3GetContext(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep3GetContextQueryResult = NonNullable<Awaited<ReturnType<typeof substep3GetContext>>>
export type Substep3GetContextQueryError = ErrorResponse


export function useSubstep3GetContext<TData = Awaited<ReturnType<typeof substep3GetContext>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetContext>>,
          TError,
          Awaited<ReturnType<typeof substep3GetContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetContext<TData = Awaited<ReturnType<typeof substep3GetContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep3GetContext>>,
          TError,
          Awaited<ReturnType<typeof substep3GetContext>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep3GetContext<TData = Awaited<ReturnType<typeof substep3GetContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
 */

export function useSubstep3GetContext<TData = Awaited<ReturnType<typeof substep3GetContext>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep3GetContext>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep3GetContextQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –º–∞—Ç–µ—Ä—ñ–∞–ª—ñ–≤
 */
export const substep2GetAvailableMaterials = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<string[]>(
      {url: `/v1/order-wizard/stage2/substep2/materials/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep2GetAvailableMaterialsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep2/materials/${sessionId}`] as const;
    }

    
export const getSubstep2GetAvailableMaterialsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep2GetAvailableMaterialsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>> = ({ signal }) => substep2GetAvailableMaterials(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep2GetAvailableMaterialsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>>
export type Substep2GetAvailableMaterialsInfiniteQueryError = ErrorResponse


export function useSubstep2GetAvailableMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep2GetAvailableMaterials>>,
          TError,
          Awaited<ReturnType<typeof substep2GetAvailableMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep2GetAvailableMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep2GetAvailableMaterials>>,
          TError,
          Awaited<ReturnType<typeof substep2GetAvailableMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep2GetAvailableMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –º–∞—Ç–µ—Ä—ñ–∞–ª—ñ–≤
 */

export function useSubstep2GetAvailableMaterialsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep2GetAvailableMaterialsInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep2GetAvailableMaterialsQueryOptions = <TData = Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep2GetAvailableMaterialsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>> = ({ signal }) => substep2GetAvailableMaterials(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep2GetAvailableMaterialsQueryResult = NonNullable<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>>
export type Substep2GetAvailableMaterialsQueryError = ErrorResponse


export function useSubstep2GetAvailableMaterials<TData = Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep2GetAvailableMaterials>>,
          TError,
          Awaited<ReturnType<typeof substep2GetAvailableMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep2GetAvailableMaterials<TData = Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep2GetAvailableMaterials>>,
          TError,
          Awaited<ReturnType<typeof substep2GetAvailableMaterials>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep2GetAvailableMaterials<TData = Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –º–∞—Ç–µ—Ä—ñ–∞–ª—ñ–≤
 */

export function useSubstep2GetAvailableMaterials<TData = Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep2GetAvailableMaterials>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep2GetAvailableMaterialsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø—ñ–¥–µ—Ç–∞–ø—É 2
 */
export const substep2GetCurrentCharacteristics = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemCharacteristicsDTO>(
      {url: `/v1/order-wizard/stage2/substep2/current-state/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep2GetCurrentCharacteristicsQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep2/current-state/${sessionId}`] as const;
    }

    
export const getSubstep2GetCurrentCharacteristicsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep2GetCurrentCharacteristicsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>> = ({ signal }) => substep2GetCurrentCharacteristics(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep2GetCurrentCharacteristicsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>>
export type Substep2GetCurrentCharacteristicsInfiniteQueryError = ErrorResponse


export function useSubstep2GetCurrentCharacteristicsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>,
          TError,
          Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep2GetCurrentCharacteristicsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>,
          TError,
          Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep2GetCurrentCharacteristicsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø—ñ–¥–µ—Ç–∞–ø—É 2
 */

export function useSubstep2GetCurrentCharacteristicsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep2GetCurrentCharacteristicsInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep2GetCurrentCharacteristicsQueryOptions = <TData = Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep2GetCurrentCharacteristicsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>> = ({ signal }) => substep2GetCurrentCharacteristics(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep2GetCurrentCharacteristicsQueryResult = NonNullable<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>>
export type Substep2GetCurrentCharacteristicsQueryError = ErrorResponse


export function useSubstep2GetCurrentCharacteristics<TData = Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>,
          TError,
          Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep2GetCurrentCharacteristics<TData = Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>,
          TError,
          Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep2GetCurrentCharacteristics<TData = Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø—ñ–¥–µ—Ç–∞–ø—É 2
 */

export function useSubstep2GetCurrentCharacteristics<TData = Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep2GetCurrentCharacteristics>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep2GetCurrentCharacteristicsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø—ñ–¥–µ—Ç–∞–ø—É 1
 */
export const substep1GetStatus = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}/status`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep1GetStatusQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/substep1/${sessionId}/status`] as const;
    }

    
export const getSubstep1GetStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep1GetStatus>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep1GetStatusQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep1GetStatus>>> = ({ signal }) => substep1GetStatus(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep1GetStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep1GetStatus>>>
export type Substep1GetStatusInfiniteQueryError = ErrorResponse


export function useSubstep1GetStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetStatus>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetStatus>>,
          TError,
          Awaited<ReturnType<typeof substep1GetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetStatus>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetStatus>>,
          TError,
          Awaited<ReturnType<typeof substep1GetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetStatus>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø—ñ–¥–µ—Ç–∞–ø—É 1
 */

export function useSubstep1GetStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetStatus>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep1GetStatusInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep1GetStatusQueryOptions = <TData = Awaited<ReturnType<typeof substep1GetStatus>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep1GetStatusQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep1GetStatus>>> = ({ signal }) => substep1GetStatus(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep1GetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof substep1GetStatus>>>
export type Substep1GetStatusQueryError = ErrorResponse


export function useSubstep1GetStatus<TData = Awaited<ReturnType<typeof substep1GetStatus>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetStatus>>,
          TError,
          Awaited<ReturnType<typeof substep1GetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetStatus<TData = Awaited<ReturnType<typeof substep1GetStatus>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetStatus>>,
          TError,
          Awaited<ReturnType<typeof substep1GetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetStatus<TData = Awaited<ReturnType<typeof substep1GetStatus>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø—ñ–¥–µ—Ç–∞–ø—É 1
 */

export function useSubstep1GetStatus<TData = Awaited<ReturnType<typeof substep1GetStatus>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep1GetStatusQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –ø–æ—Å–ª—É–≥
 */
export const substep1GetServiceCategories = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ServiceCategoryDTO[]>(
      {url: `/v1/order-wizard/stage2/substep1/service-categories`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep1GetServiceCategoriesQueryKey = () => {
    return [`/v1/order-wizard/stage2/substep1/service-categories`] as const;
    }

    
export const getSubstep1GetServiceCategoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep1GetServiceCategories>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep1GetServiceCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep1GetServiceCategories>>> = ({ signal }) => substep1GetServiceCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep1GetServiceCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep1GetServiceCategories>>>
export type Substep1GetServiceCategoriesInfiniteQueryError = ErrorResponse


export function useSubstep1GetServiceCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetServiceCategories>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetServiceCategories>>,
          TError,
          Awaited<ReturnType<typeof substep1GetServiceCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetServiceCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetServiceCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetServiceCategories>>,
          TError,
          Awaited<ReturnType<typeof substep1GetServiceCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetServiceCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetServiceCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –ø–æ—Å–ª—É–≥
 */

export function useSubstep1GetServiceCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetServiceCategories>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep1GetServiceCategoriesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep1GetServiceCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep1GetServiceCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep1GetServiceCategories>>> = ({ signal }) => substep1GetServiceCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep1GetServiceCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof substep1GetServiceCategories>>>
export type Substep1GetServiceCategoriesQueryError = ErrorResponse


export function useSubstep1GetServiceCategories<TData = Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetServiceCategories>>,
          TError,
          Awaited<ReturnType<typeof substep1GetServiceCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetServiceCategories<TData = Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetServiceCategories>>,
          TError,
          Awaited<ReturnType<typeof substep1GetServiceCategories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetServiceCategories<TData = Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –ø–æ—Å–ª—É–≥
 */

export function useSubstep1GetServiceCategories<TData = Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetServiceCategories>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep1GetServiceCategoriesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î —Å–ø–∏—Å–æ–∫ –ø—Ä–µ–¥–º–µ—Ç—ñ–≤ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */
export const substep1GetItemsForCategory = (
    categoryId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<PriceListItemDTO[]>(
      {url: `/v1/order-wizard/stage2/substep1/categories/${categoryId}/items`, method: 'GET', signal
    },
      options);
    }
  

export const getSubstep1GetItemsForCategoryQueryKey = (categoryId: string,) => {
    return [`/v1/order-wizard/stage2/substep1/categories/${categoryId}/items`] as const;
    }

    
export const getSubstep1GetItemsForCategoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof substep1GetItemsForCategory>>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep1GetItemsForCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep1GetItemsForCategory>>> = ({ signal }) => substep1GetItemsForCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep1GetItemsForCategoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof substep1GetItemsForCategory>>>
export type Substep1GetItemsForCategoryInfiniteQueryError = ErrorResponse


export function useSubstep1GetItemsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetItemsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetItemsForCategory>>,
          TError,
          Awaited<ReturnType<typeof substep1GetItemsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetItemsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetItemsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetItemsForCategory>>,
          TError,
          Awaited<ReturnType<typeof substep1GetItemsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetItemsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetItemsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î —Å–ø–∏—Å–æ–∫ –ø—Ä–µ–¥–º–µ—Ç—ñ–≤ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useSubstep1GetItemsForCategoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof substep1GetItemsForCategory>>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep1GetItemsForCategoryInfiniteQueryOptions(categoryId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSubstep1GetItemsForCategoryQueryOptions = <TData = Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError = ErrorResponse>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubstep1GetItemsForCategoryQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof substep1GetItemsForCategory>>> = ({ signal }) => substep1GetItemsForCategory(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Substep1GetItemsForCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof substep1GetItemsForCategory>>>
export type Substep1GetItemsForCategoryQueryError = ErrorResponse


export function useSubstep1GetItemsForCategory<TData = Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetItemsForCategory>>,
          TError,
          Awaited<ReturnType<typeof substep1GetItemsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetItemsForCategory<TData = Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof substep1GetItemsForCategory>>,
          TError,
          Awaited<ReturnType<typeof substep1GetItemsForCategory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubstep1GetItemsForCategory<TData = Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î —Å–ø–∏—Å–æ–∫ –ø—Ä–µ–¥–º–µ—Ç—ñ–≤ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
 */

export function useSubstep1GetItemsForCategory<TData = Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError = ErrorResponse>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof substep1GetItemsForCategory>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubstep1GetItemsForCategoryQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω —Å–µ—Å—ñ—ó
 */
export const stage2GetCurrentState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage2GetCurrentState200>(
      {url: `/v1/order-wizard/stage2/state/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getStage2GetCurrentStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/state/${sessionId}`] as const;
    }

    
export const getStage2GetCurrentStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage2GetCurrentState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage2GetCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage2GetCurrentState>>> = ({ signal }) => stage2GetCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage2GetCurrentStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage2GetCurrentState>>>
export type Stage2GetCurrentStateInfiniteQueryError = ErrorResponse


export function useStage2GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage2GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage2GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω —Å–µ—Å—ñ—ó
 */

export function useStage2GetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage2GetCurrentStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage2GetCurrentStateQueryOptions = <TData = Awaited<ReturnType<typeof stage2GetCurrentState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage2GetCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage2GetCurrentState>>> = ({ signal }) => stage2GetCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage2GetCurrentStateQueryResult = NonNullable<Awaited<ReturnType<typeof stage2GetCurrentState>>>
export type Stage2GetCurrentStateQueryError = ErrorResponse


export function useStage2GetCurrentState<TData = Awaited<ReturnType<typeof stage2GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage2GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetCurrentState<TData = Awaited<ReturnType<typeof stage2GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof stage2GetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetCurrentState<TData = Awaited<ReturnType<typeof stage2GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω —Å–µ—Å—ñ—ó
 */

export function useStage2GetCurrentState<TData = Awaited<ReturnType<typeof stage2GetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage2GetCurrentStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∏—Ö —Å–µ—Å—ñ–π
 */
export const stage2GetActiveSessionCount = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<number>(
      {url: `/v1/order-wizard/stage2/sessions/count`, method: 'GET', signal
    },
      options);
    }
  

export const getStage2GetActiveSessionCountQueryKey = () => {
    return [`/v1/order-wizard/stage2/sessions/count`] as const;
    }

    
export const getStage2GetActiveSessionCountInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage2GetActiveSessionCountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>> = ({ signal }) => stage2GetActiveSessionCount(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage2GetActiveSessionCountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>>
export type Stage2GetActiveSessionCountInfiniteQueryError = ErrorResponse


export function useStage2GetActiveSessionCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetActiveSessionCount>>,
          TError,
          Awaited<ReturnType<typeof stage2GetActiveSessionCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetActiveSessionCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetActiveSessionCount>>,
          TError,
          Awaited<ReturnType<typeof stage2GetActiveSessionCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetActiveSessionCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∏—Ö —Å–µ—Å—ñ–π
 */

export function useStage2GetActiveSessionCountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage2GetActiveSessionCountInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage2GetActiveSessionCountQueryOptions = <TData = Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage2GetActiveSessionCountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>> = ({ signal }) => stage2GetActiveSessionCount(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage2GetActiveSessionCountQueryResult = NonNullable<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>>
export type Stage2GetActiveSessionCountQueryError = ErrorResponse


export function useStage2GetActiveSessionCount<TData = Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetActiveSessionCount>>,
          TError,
          Awaited<ReturnType<typeof stage2GetActiveSessionCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetActiveSessionCount<TData = Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetActiveSessionCount>>,
          TError,
          Awaited<ReturnType<typeof stage2GetActiveSessionCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetActiveSessionCount<TData = Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∏—Ö —Å–µ—Å—ñ–π
 */

export function useStage2GetActiveSessionCount<TData = Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetActiveSessionCount>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage2GetActiveSessionCountQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä—è—î –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –¥–æ –ø–µ—Ä–µ—Ö–æ–¥—É –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –µ—Ç–∞–ø
 */
export const stage2CheckReadinessToProceed = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage2/ready/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getStage2CheckReadinessToProceedQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/ready/${sessionId}`] as const;
    }

    
export const getStage2CheckReadinessToProceedInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage2CheckReadinessToProceedQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>> = ({ signal }) => stage2CheckReadinessToProceed(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage2CheckReadinessToProceedInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>>
export type Stage2CheckReadinessToProceedInfiniteQueryError = ErrorResponse


export function useStage2CheckReadinessToProceedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>,
          TError,
          Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2CheckReadinessToProceedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>,
          TError,
          Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2CheckReadinessToProceedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä—è—î –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –¥–æ –ø–µ—Ä–µ—Ö–æ–¥—É –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –µ—Ç–∞–ø
 */

export function useStage2CheckReadinessToProceedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage2CheckReadinessToProceedInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage2CheckReadinessToProceedQueryOptions = <TData = Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage2CheckReadinessToProceedQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>> = ({ signal }) => stage2CheckReadinessToProceed(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage2CheckReadinessToProceedQueryResult = NonNullable<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>>
export type Stage2CheckReadinessToProceedQueryError = ErrorResponse


export function useStage2CheckReadinessToProceed<TData = Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>,
          TError,
          Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2CheckReadinessToProceed<TData = Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>,
          TError,
          Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2CheckReadinessToProceed<TData = Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä—è—î –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –¥–æ –ø–µ—Ä–µ—Ö–æ–¥—É –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –µ—Ç–∞–ø
 */

export function useStage2CheckReadinessToProceed<TData = Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2CheckReadinessToProceed>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage2CheckReadinessToProceedQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */
export const stage2GetCurrentManager = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ItemManagerDTO>(
      {url: `/v1/order-wizard/stage2/manager/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getStage2GetCurrentManagerQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage2/manager/${sessionId}`] as const;
    }

    
export const getStage2GetCurrentManagerInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage2GetCurrentManager>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage2GetCurrentManagerQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage2GetCurrentManager>>> = ({ signal }) => stage2GetCurrentManager(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage2GetCurrentManagerInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage2GetCurrentManager>>>
export type Stage2GetCurrentManagerInfiniteQueryError = ErrorResponse


export function useStage2GetCurrentManagerInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetCurrentManager>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetCurrentManager>>,
          TError,
          Awaited<ReturnType<typeof stage2GetCurrentManager>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetCurrentManagerInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetCurrentManager>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetCurrentManager>>,
          TError,
          Awaited<ReturnType<typeof stage2GetCurrentManager>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetCurrentManagerInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetCurrentManager>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useStage2GetCurrentManagerInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage2GetCurrentManager>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage2GetCurrentManagerInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage2GetCurrentManagerQueryOptions = <TData = Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage2GetCurrentManagerQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage2GetCurrentManager>>> = ({ signal }) => stage2GetCurrentManager(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage2GetCurrentManagerQueryResult = NonNullable<Awaited<ReturnType<typeof stage2GetCurrentManager>>>
export type Stage2GetCurrentManagerQueryError = ErrorResponse


export function useStage2GetCurrentManager<TData = Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetCurrentManager>>,
          TError,
          Awaited<ReturnType<typeof stage2GetCurrentManager>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetCurrentManager<TData = Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage2GetCurrentManager>>,
          TError,
          Awaited<ReturnType<typeof stage2GetCurrentManager>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage2GetCurrentManager<TData = Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
 */

export function useStage2GetCurrentManager<TData = Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage2GetCurrentManager>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage2GetCurrentManagerQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω —Ñ–æ—Ä–º–∏
 */
export const stage1GetClientFormState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage1GetClientFormState200>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getStage1GetClientFormStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/new-client/session/${sessionId}/state`] as const;
    }

    
export const getStage1GetClientFormStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientFormState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetClientFormStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetClientFormState>>> = ({ signal }) => stage1GetClientFormState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetClientFormStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetClientFormState>>>
export type Stage1GetClientFormStateInfiniteQueryError = ErrorResponse


export function useStage1GetClientFormStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientFormState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientFormState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientFormState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientFormStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientFormState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientFormState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientFormState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientFormStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientFormState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω —Ñ–æ—Ä–º–∏
 */

export function useStage1GetClientFormStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientFormState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetClientFormStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage1GetClientFormStateQueryOptions = <TData = Awaited<ReturnType<typeof stage1GetClientFormState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetClientFormStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetClientFormState>>> = ({ signal }) => stage1GetClientFormState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetClientFormStateQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetClientFormState>>>
export type Stage1GetClientFormStateQueryError = ErrorResponse


export function useStage1GetClientFormState<TData = Awaited<ReturnType<typeof stage1GetClientFormState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientFormState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientFormState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientFormState<TData = Awaited<ReturnType<typeof stage1GetClientFormState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientFormState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientFormState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientFormState<TData = Awaited<ReturnType<typeof stage1GetClientFormState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω —Ñ–æ—Ä–º–∏
 */

export function useStage1GetClientFormState<TData = Awaited<ReturnType<typeof stage1GetClientFormState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientFormState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetClientFormStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø–æ—à—É–∫—É
 */
export const stage1GetClientSearchState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage1GetClientSearchState200>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getStage1GetClientSearchStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/client-search/session/${sessionId}/state`] as const;
    }

    
export const getStage1GetClientSearchStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientSearchState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetClientSearchStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetClientSearchState>>> = ({ signal }) => stage1GetClientSearchState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetClientSearchStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetClientSearchState>>>
export type Stage1GetClientSearchStateInfiniteQueryError = ErrorResponse


export function useStage1GetClientSearchStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientSearchState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientSearchState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientSearchState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientSearchStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientSearchState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientSearchState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientSearchState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientSearchStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientSearchState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø–æ—à—É–∫—É
 */

export function useStage1GetClientSearchStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetClientSearchState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetClientSearchStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage1GetClientSearchStateQueryOptions = <TData = Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetClientSearchStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetClientSearchState>>> = ({ signal }) => stage1GetClientSearchState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetClientSearchStateQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetClientSearchState>>>
export type Stage1GetClientSearchStateQueryError = ErrorResponse


export function useStage1GetClientSearchState<TData = Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientSearchState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientSearchState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientSearchState<TData = Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetClientSearchState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetClientSearchState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetClientSearchState<TData = Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø–æ—à—É–∫—É
 */

export function useStage1GetClientSearchState<TData = Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetClientSearchState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetClientSearchStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î –æ–±—Ä–∞–Ω–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const stage1GetSelectedClient = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<ClientResponse>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}/selected-client`, method: 'GET', signal
    },
      options);
    }
  

export const getStage1GetSelectedClientQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/client-search/session/${sessionId}/selected-client`] as const;
    }

    
export const getStage1GetSelectedClientInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage1GetSelectedClient>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetSelectedClientQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetSelectedClient>>> = ({ signal }) => stage1GetSelectedClient(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetSelectedClientInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetSelectedClient>>>
export type Stage1GetSelectedClientInfiniteQueryError = ErrorResponse


export function useStage1GetSelectedClientInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetSelectedClient>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetSelectedClient>>,
          TError,
          Awaited<ReturnType<typeof stage1GetSelectedClient>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetSelectedClientInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetSelectedClient>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetSelectedClient>>,
          TError,
          Awaited<ReturnType<typeof stage1GetSelectedClient>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetSelectedClientInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetSelectedClient>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –æ–±—Ä–∞–Ω–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞
 */

export function useStage1GetSelectedClientInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetSelectedClient>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetSelectedClientInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage1GetSelectedClientQueryOptions = <TData = Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetSelectedClientQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetSelectedClient>>> = ({ signal }) => stage1GetSelectedClient(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetSelectedClientQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetSelectedClient>>>
export type Stage1GetSelectedClientQueryError = ErrorResponse


export function useStage1GetSelectedClient<TData = Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetSelectedClient>>,
          TError,
          Awaited<ReturnType<typeof stage1GetSelectedClient>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetSelectedClient<TData = Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetSelectedClient>>,
          TError,
          Awaited<ReturnType<typeof stage1GetSelectedClient>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetSelectedClient<TData = Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –æ–±—Ä–∞–Ω–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞
 */

export function useStage1GetSelectedClient<TData = Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetSelectedClient>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetSelectedClientQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –±–∞–∑–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */
export const stage1GetBasicOrderState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<Stage1GetBasicOrderState200>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getStage1GetBasicOrderStateQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/basic-order/session/${sessionId}/state`] as const;
    }

    
export const getStage1GetBasicOrderStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBasicOrderState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetBasicOrderStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetBasicOrderState>>> = ({ signal }) => stage1GetBasicOrderState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetBasicOrderStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetBasicOrderState>>>
export type Stage1GetBasicOrderStateInfiniteQueryError = ErrorResponse


export function useStage1GetBasicOrderStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBasicOrderState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBasicOrderState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBasicOrderState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBasicOrderStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBasicOrderState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBasicOrderState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBasicOrderState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBasicOrderStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBasicOrderState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –±–∞–∑–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */

export function useStage1GetBasicOrderStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBasicOrderState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetBasicOrderStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage1GetBasicOrderStateQueryOptions = <TData = Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetBasicOrderStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetBasicOrderState>>> = ({ signal }) => stage1GetBasicOrderState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetBasicOrderStateQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetBasicOrderState>>>
export type Stage1GetBasicOrderStateQueryError = ErrorResponse


export function useStage1GetBasicOrderState<TData = Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBasicOrderState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBasicOrderState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBasicOrderState<TData = Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBasicOrderState>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBasicOrderState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBasicOrderState<TData = Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –±–∞–∑–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */

export function useStage1GetBasicOrderState<TData = Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBasicOrderState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetBasicOrderStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î —Ñ—ñ–ª—ñ—ó –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—ó —Å–µ—Å—ñ—ó
 */
export const stage1GetBranchesForSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<BranchLocationDTO[]>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/branches`, method: 'GET', signal
    },
      options);
    }
  

export const getStage1GetBranchesForSessionQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/basic-order/session/${sessionId}/branches`] as const;
    }

    
export const getStage1GetBranchesForSessionInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBranchesForSession>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetBranchesForSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetBranchesForSession>>> = ({ signal }) => stage1GetBranchesForSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetBranchesForSessionInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetBranchesForSession>>>
export type Stage1GetBranchesForSessionInfiniteQueryError = ErrorResponse


export function useStage1GetBranchesForSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBranchesForSession>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBranchesForSession>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBranchesForSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBranchesForSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBranchesForSession>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBranchesForSession>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBranchesForSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBranchesForSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBranchesForSession>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î —Ñ—ñ–ª—ñ—ó –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—ó —Å–µ—Å—ñ—ó
 */

export function useStage1GetBranchesForSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1GetBranchesForSession>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetBranchesForSessionInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage1GetBranchesForSessionQueryOptions = <TData = Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1GetBranchesForSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1GetBranchesForSession>>> = ({ signal }) => stage1GetBranchesForSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1GetBranchesForSessionQueryResult = NonNullable<Awaited<ReturnType<typeof stage1GetBranchesForSession>>>
export type Stage1GetBranchesForSessionQueryError = ErrorResponse


export function useStage1GetBranchesForSession<TData = Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBranchesForSession>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBranchesForSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBranchesForSession<TData = Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1GetBranchesForSession>>,
          TError,
          Awaited<ReturnType<typeof stage1GetBranchesForSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1GetBranchesForSession<TData = Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î —Ñ—ñ–ª—ñ—ó –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—ó —Å–µ—Å—ñ—ó
 */

export function useStage1GetBranchesForSession<TData = Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1GetBranchesForSession>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1GetBranchesForSessionQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä—è—î —á–∏ —Ñ—ñ–ª—ñ—ó –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω—ñ –¥–ª—è —Å–µ—Å—ñ—ó
 */
export const stage1AreBranchesLoaded = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<boolean>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}/branches/loaded`, method: 'GET', signal
    },
      options);
    }
  

export const getStage1AreBranchesLoadedQueryKey = (sessionId: string,) => {
    return [`/v1/order-wizard/stage1/basic-order/session/${sessionId}/branches/loaded`] as const;
    }

    
export const getStage1AreBranchesLoadedInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1AreBranchesLoadedQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>> = ({ signal }) => stage1AreBranchesLoaded(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1AreBranchesLoadedInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>>
export type Stage1AreBranchesLoadedInfiniteQueryError = ErrorResponse


export function useStage1AreBranchesLoadedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1AreBranchesLoaded>>,
          TError,
          Awaited<ReturnType<typeof stage1AreBranchesLoaded>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1AreBranchesLoadedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1AreBranchesLoaded>>,
          TError,
          Awaited<ReturnType<typeof stage1AreBranchesLoaded>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1AreBranchesLoadedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä—è—î —á–∏ —Ñ—ñ–ª—ñ—ó –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω—ñ –¥–ª—è —Å–µ—Å—ñ—ó
 */

export function useStage1AreBranchesLoadedInfinite<TData = InfiniteData<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1AreBranchesLoadedInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStage1AreBranchesLoadedQueryOptions = <TData = Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStage1AreBranchesLoadedQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>> = ({ signal }) => stage1AreBranchesLoaded(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type Stage1AreBranchesLoadedQueryResult = NonNullable<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>>
export type Stage1AreBranchesLoadedQueryError = ErrorResponse


export function useStage1AreBranchesLoaded<TData = Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1AreBranchesLoaded>>,
          TError,
          Awaited<ReturnType<typeof stage1AreBranchesLoaded>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1AreBranchesLoaded<TData = Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stage1AreBranchesLoaded>>,
          TError,
          Awaited<ReturnType<typeof stage1AreBranchesLoaded>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStage1AreBranchesLoaded<TData = Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä—è—î —á–∏ —Ñ—ñ–ª—ñ—ó –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω—ñ –¥–ª—è —Å–µ—Å—ñ—ó
 */

export function useStage1AreBranchesLoaded<TData = Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stage1AreBranchesLoaded>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStage1AreBranchesLoadedQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –§–ª–æ—É-–∫–∞—Ä—Ç–∞ Order Wizard –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥—É
 */
export const orderWizardGetWorkflow = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<WorkflowMap>(
      {url: `/order-wizard/workflow`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardGetWorkflowQueryKey = () => {
    return [`/order-wizard/workflow`] as const;
    }

    
export const getOrderWizardGetWorkflowInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetWorkflow>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetWorkflowQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetWorkflow>>> = ({ signal }) => orderWizardGetWorkflow(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetWorkflowInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetWorkflow>>>
export type OrderWizardGetWorkflowInfiniteQueryError = ErrorResponse


export function useOrderWizardGetWorkflowInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetWorkflow>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetWorkflow>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetWorkflow>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetWorkflowInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetWorkflow>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetWorkflow>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetWorkflow>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetWorkflowInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetWorkflow>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –§–ª–æ—É-–∫–∞—Ä—Ç–∞ Order Wizard –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥—É
 */

export function useOrderWizardGetWorkflowInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetWorkflow>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetWorkflowInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardGetWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetWorkflowQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetWorkflow>>> = ({ signal }) => orderWizardGetWorkflow(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetWorkflow>>>
export type OrderWizardGetWorkflowQueryError = ErrorResponse


export function useOrderWizardGetWorkflow<TData = Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetWorkflow>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetWorkflow>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetWorkflow<TData = Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetWorkflow>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetWorkflow>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetWorkflow<TData = Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –§–ª–æ—É-–∫–∞—Ä—Ç–∞ Order Wizard –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥—É
 */

export function useOrderWizardGetWorkflow<TData = Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetWorkflow>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetWorkflowQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–∏—Å—Ç–µ–º–∏
 */
export const orderWizardGetSystemStats = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<SystemStats>(
      {url: `/order-wizard/stats`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardGetSystemStatsQueryKey = () => {
    return [`/order-wizard/stats`] as const;
    }

    
export const getOrderWizardGetSystemStatsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetSystemStats>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetSystemStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetSystemStats>>> = ({ signal }) => orderWizardGetSystemStats(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetSystemStatsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetSystemStats>>>
export type OrderWizardGetSystemStatsInfiniteQueryError = ErrorResponse


export function useOrderWizardGetSystemStatsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetSystemStats>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetSystemStats>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetSystemStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetSystemStatsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetSystemStats>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetSystemStats>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetSystemStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetSystemStatsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetSystemStats>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–∏—Å—Ç–µ–º–∏
 */

export function useOrderWizardGetSystemStatsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetSystemStats>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetSystemStatsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardGetSystemStatsQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetSystemStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetSystemStats>>> = ({ signal }) => orderWizardGetSystemStats(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetSystemStatsQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetSystemStats>>>
export type OrderWizardGetSystemStatsQueryError = ErrorResponse


export function useOrderWizardGetSystemStats<TData = Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetSystemStats>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetSystemStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetSystemStats<TData = Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetSystemStats>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetSystemStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetSystemStats<TData = Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–∏—Å—Ç–µ–º–∏
 */

export function useOrderWizardGetSystemStats<TData = Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSystemStats>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetSystemStatsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –î–µ—Ç–∞–ª—å–Ω–∏–π —Å—Ç–∞—Ç—É—Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –µ—Ç–∞–ø—É
 */
export const orderWizardGetStageStatus = (
    stageNumber: number,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StageStatus>(
      {url: `/order-wizard/stages/${stageNumber}/status`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardGetStageStatusQueryKey = (stageNumber: number,) => {
    return [`/order-wizard/stages/${stageNumber}/status`] as const;
    }

    
export const getOrderWizardGetStageStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageStatus>>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetStageStatusQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetStageStatus>>> = ({ signal }) => orderWizardGetStageStatus(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetStageStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetStageStatus>>>
export type OrderWizardGetStageStatusInfiniteQueryError = ErrorResponse


export function useOrderWizardGetStageStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageStatus>>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageStatus>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageStatus>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageStatus>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageStatus>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –î–µ—Ç–∞–ª—å–Ω–∏–π —Å—Ç–∞—Ç—É—Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –µ—Ç–∞–ø—É
 */

export function useOrderWizardGetStageStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageStatus>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetStageStatusInfiniteQueryOptions(stageNumber,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardGetStageStatusQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetStageStatusQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetStageStatus>>> = ({ signal }) => orderWizardGetStageStatus(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetStageStatusQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetStageStatus>>>
export type OrderWizardGetStageStatusQueryError = ErrorResponse


export function useOrderWizardGetStageStatus<TData = Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageStatus>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageStatus<TData = Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageStatus>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageStatus<TData = Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –î–µ—Ç–∞–ª—å–Ω–∏–π —Å—Ç–∞—Ç—É—Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –µ—Ç–∞–ø—É
 */

export function useOrderWizardGetStageStatus<TData = Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetStageStatusQueryOptions(stageNumber,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è –ø–æ –º–µ—Ç–æ–¥–∞—Ö –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –µ—Ç–∞–ø—É
 */
export const orderWizardGetStageMethods = (
    stageNumber: number,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StageMethods>(
      {url: `/order-wizard/stages/${stageNumber}/methods`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardGetStageMethodsQueryKey = (stageNumber: number,) => {
    return [`/order-wizard/stages/${stageNumber}/methods`] as const;
    }

    
export const getOrderWizardGetStageMethodsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageMethods>>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetStageMethodsQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetStageMethods>>> = ({ signal }) => orderWizardGetStageMethods(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetStageMethodsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetStageMethods>>>
export type OrderWizardGetStageMethodsInfiniteQueryError = ErrorResponse


export function useOrderWizardGetStageMethodsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageMethods>>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageMethods>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageMethods>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageMethodsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageMethods>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageMethods>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageMethods>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageMethodsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageMethods>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è –ø–æ –º–µ—Ç–æ–¥–∞—Ö –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –µ—Ç–∞–ø—É
 */

export function useOrderWizardGetStageMethodsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageMethods>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetStageMethodsInfiniteQueryOptions(stageNumber,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardGetStageMethodsQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetStageMethodsQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetStageMethods>>> = ({ signal }) => orderWizardGetStageMethods(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetStageMethodsQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetStageMethods>>>
export type OrderWizardGetStageMethodsQueryError = ErrorResponse


export function useOrderWizardGetStageMethods<TData = Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageMethods>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageMethods>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageMethods<TData = Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageMethods>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageMethods>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageMethods<TData = Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è –ø–æ –º–µ—Ç–æ–¥–∞—Ö –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –µ—Ç–∞–ø—É
 */

export function useOrderWizardGetStageMethods<TData = Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageMethods>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetStageMethodsQueryOptions(stageNumber,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –î–µ—Ç–∞–ª—å–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π –µ—Ç–∞–ø
 */
export const orderWizardGetStageInfo = (
    stageNumber: number,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StageInfo>(
      {url: `/order-wizard/stages/${stageNumber}/info`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardGetStageInfoQueryKey = (stageNumber: number,) => {
    return [`/order-wizard/stages/${stageNumber}/info`] as const;
    }

    
export const getOrderWizardGetStageInfoInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageInfo>>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetStageInfoQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetStageInfo>>> = ({ signal }) => orderWizardGetStageInfo(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetStageInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetStageInfo>>>
export type OrderWizardGetStageInfoInfiniteQueryError = ErrorResponse


export function useOrderWizardGetStageInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageInfo>>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageInfo>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageInfo>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –î–µ—Ç–∞–ª—å–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π –µ—Ç–∞–ø
 */

export function useOrderWizardGetStageInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStageInfo>>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetStageInfoInfiniteQueryOptions(stageNumber,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardGetStageInfoQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError = ErrorResponse>(stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetStageInfoQueryKey(stageNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetStageInfo>>> = ({ signal }) => orderWizardGetStageInfo(stageNumber, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(stageNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetStageInfoQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetStageInfo>>>
export type OrderWizardGetStageInfoQueryError = ErrorResponse


export function useOrderWizardGetStageInfo<TData = Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError = ErrorResponse>(
 stageNumber: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageInfo<TData = Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStageInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStageInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStageInfo<TData = Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –î–µ—Ç–∞–ª—å–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π –µ—Ç–∞–ø
 */

export function useOrderWizardGetStageInfo<TData = Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError = ErrorResponse>(
 stageNumber: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStageInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetStageInfoQueryOptions(stageNumber,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –°—Ç–∞—Ç—É—Å–∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ –≤—Å—ñ—Ö –µ—Ç–∞–ø—ñ–≤
 */
export const orderWizardGetStagesStatus = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<StagesStatus>(
      {url: `/order-wizard/stages/status`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardGetStagesStatusQueryKey = () => {
    return [`/order-wizard/stages/status`] as const;
    }

    
export const getOrderWizardGetStagesStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetStagesStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>> = ({ signal }) => orderWizardGetStagesStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetStagesStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>>
export type OrderWizardGetStagesStatusInfiniteQueryError = ErrorResponse


export function useOrderWizardGetStagesStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStagesStatus>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStagesStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStagesStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStagesStatus>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStagesStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStagesStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –°—Ç–∞—Ç—É—Å–∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ –≤—Å—ñ—Ö –µ—Ç–∞–ø—ñ–≤
 */

export function useOrderWizardGetStagesStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetStagesStatusInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardGetStagesStatusQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetStagesStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>> = ({ signal }) => orderWizardGetStagesStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetStagesStatusQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>>
export type OrderWizardGetStagesStatusQueryError = ErrorResponse


export function useOrderWizardGetStagesStatus<TData = Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStagesStatus>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStagesStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStagesStatus<TData = Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetStagesStatus>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetStagesStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetStagesStatus<TData = Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –°—Ç–∞—Ç—É—Å–∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ –≤—Å—ñ—Ö –µ—Ç–∞–ø—ñ–≤
 */

export function useOrderWizardGetStagesStatus<TData = Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetStagesStatus>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetStagesStatusQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω Order Wizard
 */
export const orderWizardGetCurrentState = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardResponseDTO>(
      {url: `/order-wizard/session/${sessionId}/state`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardGetCurrentStateQueryKey = (sessionId: string,) => {
    return [`/order-wizard/session/${sessionId}/state`] as const;
    }

    
export const getOrderWizardGetCurrentStateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetCurrentState>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetCurrentState>>> = ({ signal }) => orderWizardGetCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetCurrentStateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetCurrentState>>>
export type OrderWizardGetCurrentStateInfiniteQueryError = ErrorResponse


export function useOrderWizardGetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω Order Wizard
 */

export function useOrderWizardGetCurrentStateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetCurrentState>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetCurrentStateInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardGetCurrentStateQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetCurrentStateQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetCurrentState>>> = ({ signal }) => orderWizardGetCurrentState(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetCurrentStateQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetCurrentState>>>
export type OrderWizardGetCurrentStateQueryError = ErrorResponse


export function useOrderWizardGetCurrentState<TData = Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetCurrentState<TData = Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetCurrentState>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetCurrentState>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetCurrentState<TData = Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω Order Wizard
 */

export function useOrderWizardGetCurrentState<TData = Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCurrentState>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetCurrentStateQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–µ—Ç–∞–ª—å–Ω–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ –ø–æ—Ç–æ—á–Ω—É —Å–µ—Å—ñ—é
 */
export const orderWizardGetSessionInfo = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardGetSessionInfo200>(
      {url: `/order-wizard/session/${sessionId}/info`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardGetSessionInfoQueryKey = (sessionId: string,) => {
    return [`/order-wizard/session/${sessionId}/info`] as const;
    }

    
export const getOrderWizardGetSessionInfoInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetSessionInfoQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>> = ({ signal }) => orderWizardGetSessionInfo(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetSessionInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>>
export type OrderWizardGetSessionInfoInfiniteQueryError = ErrorResponse


export function useOrderWizardGetSessionInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetSessionInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetSessionInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetSessionInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetSessionInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetSessionInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetSessionInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–µ—Ç–∞–ª—å–Ω–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ –ø–æ—Ç–æ—á–Ω—É —Å–µ—Å—ñ—é
 */

export function useOrderWizardGetSessionInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetSessionInfoInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardGetSessionInfoQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetSessionInfoQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>> = ({ signal }) => orderWizardGetSessionInfo(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetSessionInfoQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>>
export type OrderWizardGetSessionInfoQueryError = ErrorResponse


export function useOrderWizardGetSessionInfo<TData = Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetSessionInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetSessionInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetSessionInfo<TData = Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetSessionInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetSessionInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetSessionInfo<TData = Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–µ—Ç–∞–ª—å–Ω–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ –ø–æ—Ç–æ—á–Ω—É —Å–µ—Å—ñ—é
 */

export function useOrderWizardGetSessionInfo<TData = Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetSessionInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetSessionInfoQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –û—Ç—Ä–∏–º—É—î –≤—Å—ñ –º–æ–∂–ª–∏–≤—ñ –ø–µ—Ä–µ—Ö–æ–¥–∏ –∑ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */
export const orderWizardGetAvailableTransitions = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<OrderWizardGetAvailableTransitions200>(
      {url: `/order-wizard/session/${sessionId}/available-transitions`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardGetAvailableTransitionsQueryKey = (sessionId: string,) => {
    return [`/order-wizard/session/${sessionId}/available-transitions`] as const;
    }

    
export const getOrderWizardGetAvailableTransitionsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetAvailableTransitionsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>> = ({ signal }) => orderWizardGetAvailableTransitions(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetAvailableTransitionsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>>
export type OrderWizardGetAvailableTransitionsInfiniteQueryError = ErrorResponse


export function useOrderWizardGetAvailableTransitionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetAvailableTransitionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetAvailableTransitionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –≤—Å—ñ –º–æ–∂–ª–∏–≤—ñ –ø–µ—Ä–µ—Ö–æ–¥–∏ –∑ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */

export function useOrderWizardGetAvailableTransitionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetAvailableTransitionsInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardGetAvailableTransitionsQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError = ErrorResponse>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetAvailableTransitionsQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>> = ({ signal }) => orderWizardGetAvailableTransitions(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetAvailableTransitionsQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>>
export type OrderWizardGetAvailableTransitionsQueryError = ErrorResponse


export function useOrderWizardGetAvailableTransitions<TData = Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError = ErrorResponse>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetAvailableTransitions<TData = Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetAvailableTransitions<TData = Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –û—Ç—Ä–∏–º—É—î –≤—Å—ñ –º–æ–∂–ª–∏–≤—ñ –ø–µ—Ä–µ—Ö–æ–¥–∏ –∑ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
 */

export function useOrderWizardGetAvailableTransitions<TData = Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError = ErrorResponse>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAvailableTransitions>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetAvailableTransitionsQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ Order Wizard API
 */
export const orderWizardHealth = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<HealthStatus>(
      {url: `/order-wizard/health`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardHealthQueryKey = () => {
    return [`/order-wizard/health`] as const;
    }

    
export const getOrderWizardHealthInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardHealth>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardHealth>>> = ({ signal }) => orderWizardHealth(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardHealthInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardHealth>>>
export type OrderWizardHealthInfiniteQueryError = ErrorResponse


export function useOrderWizardHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardHealth>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardHealth>>,
          TError,
          Awaited<ReturnType<typeof orderWizardHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardHealth>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardHealth>>,
          TError,
          Awaited<ReturnType<typeof orderWizardHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardHealth>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ Order Wizard API
 */

export function useOrderWizardHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardHealth>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardHealthInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardHealthQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardHealth>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardHealth>>> = ({ signal }) => orderWizardHealth(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardHealthQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardHealth>>>
export type OrderWizardHealthQueryError = ErrorResponse


export function useOrderWizardHealth<TData = Awaited<ReturnType<typeof orderWizardHealth>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardHealth>>,
          TError,
          Awaited<ReturnType<typeof orderWizardHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardHealth<TData = Awaited<ReturnType<typeof orderWizardHealth>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardHealth>>,
          TError,
          Awaited<ReturnType<typeof orderWizardHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardHealth<TData = Awaited<ReturnType<typeof orderWizardHealth>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ Order Wizard API
 */

export function useOrderWizardHealth<TData = Awaited<ReturnType<typeof orderWizardHealth>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardHealth>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardHealthQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–æ–≤–Ω–∞ –º–∞–ø–∞ –≤—Å—ñ—Ö –¥–æ—Å—Ç—É–ø–Ω–∏—Ö API endpoints
 */
export const orderWizardGetCompleteApiMap = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<CompleteApiMap>(
      {url: `/order-wizard/api-map`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardGetCompleteApiMapQueryKey = () => {
    return [`/order-wizard/api-map`] as const;
    }

    
export const getOrderWizardGetCompleteApiMapInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetCompleteApiMapQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>> = ({ signal }) => orderWizardGetCompleteApiMap(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetCompleteApiMapInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>>
export type OrderWizardGetCompleteApiMapInfiniteQueryError = ErrorResponse


export function useOrderWizardGetCompleteApiMapInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetCompleteApiMapInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetCompleteApiMapInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–æ–≤–Ω–∞ –º–∞–ø–∞ –≤—Å—ñ—Ö –¥–æ—Å—Ç—É–ø–Ω–∏—Ö API endpoints
 */

export function useOrderWizardGetCompleteApiMapInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetCompleteApiMapInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardGetCompleteApiMapQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetCompleteApiMapQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>> = ({ signal }) => orderWizardGetCompleteApiMap(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetCompleteApiMapQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>>
export type OrderWizardGetCompleteApiMapQueryError = ErrorResponse


export function useOrderWizardGetCompleteApiMap<TData = Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetCompleteApiMap<TData = Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetCompleteApiMap<TData = Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–æ–≤–Ω–∞ –º–∞–ø–∞ –≤—Å—ñ—Ö –¥–æ—Å—Ç—É–ø–Ω–∏—Ö API endpoints
 */

export function useOrderWizardGetCompleteApiMap<TData = Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetCompleteApiMap>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetCompleteApiMapQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ü–æ–≤–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –≤—Å—ñ –∞–¥–∞–ø—Ç–µ—Ä–∏
 */
export const orderWizardGetAdaptersInfo = (
    
 options?: SecondParameter<typeof orvalFetcher>,signal?: AbortSignal
) => {
      
      
      return orvalFetcher<AdaptersInfo>(
      {url: `/order-wizard/adapters`, method: 'GET', signal
    },
      options);
    }
  

export const getOrderWizardGetAdaptersInfoQueryKey = () => {
    return [`/order-wizard/adapters`] as const;
    }

    
export const getOrderWizardGetAdaptersInfoInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>>, TError = ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetAdaptersInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>> = ({ signal }) => orderWizardGetAdaptersInfo(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetAdaptersInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>>
export type OrderWizardGetAdaptersInfoInfiniteQueryError = ErrorResponse


export function useOrderWizardGetAdaptersInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>>, TError = ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetAdaptersInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetAdaptersInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–æ–≤–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –≤—Å—ñ –∞–¥–∞–ø—Ç–µ—Ä–∏
 */

export function useOrderWizardGetAdaptersInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetAdaptersInfoInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOrderWizardGetAdaptersInfoQueryOptions = <TData = Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOrderWizardGetAdaptersInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>> = ({ signal }) => orderWizardGetAdaptersInfo(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OrderWizardGetAdaptersInfoQueryResult = NonNullable<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>>
export type OrderWizardGetAdaptersInfoQueryError = ErrorResponse


export function useOrderWizardGetAdaptersInfo<TData = Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetAdaptersInfo<TData = Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>,
          TError,
          Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOrderWizardGetAdaptersInfo<TData = Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–æ–≤–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –≤—Å—ñ –∞–¥–∞–ø—Ç–µ—Ä–∏
 */

export function useOrderWizardGetAdaptersInfo<TData = Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof orderWizardGetAdaptersInfo>>, TError, TData>>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOrderWizardGetAdaptersInfoQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary –ó–∞–∫—Ä–∏—Ç—Ç—è —Å–µ—Å—ñ—ó —Ñ–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
 */
export const substep5CloseSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getSubstep5CloseSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep5CloseSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep5CloseSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep5CloseSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep5CloseSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep5CloseSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep5CloseSessionMutationResult = NonNullable<Awaited<ReturnType<typeof substep5CloseSession>>>
    
    export type Substep5CloseSessionMutationError = ErrorResponse

    /**
 * @summary –ó–∞–∫—Ä–∏—Ç—Ç—è —Å–µ—Å—ñ—ó —Ñ–æ—Ç–æ–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
 */
export const useSubstep5CloseSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep5CloseSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep5CloseSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep5CloseSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–¥–∞–ª–µ–Ω–Ω—è —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—ó
 */
export const substep5RemovePhoto = (
    sessionId: string,
    photoId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep5/${sessionId}/photos/${photoId}`, method: 'DELETE'
    },
      options);
    }
  


export const getSubstep5RemovePhotoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep5RemovePhoto>>, TError,{sessionId: string;photoId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep5RemovePhoto>>, TError,{sessionId: string;photoId: string}, TContext> => {

const mutationKey = ['substep5RemovePhoto'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep5RemovePhoto>>, {sessionId: string;photoId: string}> = (props) => {
          const {sessionId,photoId} = props ?? {};

          return  substep5RemovePhoto(sessionId,photoId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep5RemovePhotoMutationResult = NonNullable<Awaited<ReturnType<typeof substep5RemovePhoto>>>
    
    export type Substep5RemovePhotoMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–µ–Ω–Ω—è —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—ó
 */
export const useSubstep5RemovePhoto = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep5RemovePhoto>>, TError,{sessionId: string;photoId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep5RemovePhoto>>,
        TError,
        {sessionId: string;photoId: string},
        TContext
      > => {

      const mutationOptions = getSubstep5RemovePhotoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–¥–∞–ª–µ–Ω–Ω—è —Å–µ—Å—ñ—ó
 */
export const substep4RemoveSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/substep4/session/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getSubstep4RemoveSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep4RemoveSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4RemoveSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep4RemoveSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4RemoveSessionMutationResult = NonNullable<Awaited<ReturnType<typeof substep4RemoveSession>>>
    
    export type Substep4RemoveSessionMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–µ–Ω–Ω—è —Å–µ—Å—ñ—ó
 */
export const useSubstep4RemoveSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4RemoveSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4RemoveSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –í–∏–¥–∞–ª–µ–Ω–Ω—è –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –∑ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const substep4RemoveModifier = (
    sessionId: string,
    modifierId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<SubstepResultDTO>(
      {url: `/v1/order-wizard/stage2/substep4/modifiers/${sessionId}/${modifierId}`, method: 'DELETE'
    },
      options);
    }
  


export const getSubstep4RemoveModifierMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveModifier>>, TError,{sessionId: string;modifierId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveModifier>>, TError,{sessionId: string;modifierId: string}, TContext> => {

const mutationKey = ['substep4RemoveModifier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep4RemoveModifier>>, {sessionId: string;modifierId: string}> = (props) => {
          const {sessionId,modifierId} = props ?? {};

          return  substep4RemoveModifier(sessionId,modifierId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep4RemoveModifierMutationResult = NonNullable<Awaited<ReturnType<typeof substep4RemoveModifier>>>
    
    export type Substep4RemoveModifierMutationError = ErrorResponse

    /**
 * @summary –í–∏–¥–∞–ª–µ–Ω–Ω—è –º–æ–¥–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞ –∑ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É
 */
export const useSubstep4RemoveModifier = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep4RemoveModifier>>, TError,{sessionId: string;modifierId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep4RemoveModifier>>,
        TError,
        {sessionId: string;modifierId: string},
        TContext
      > => {

      const mutationOptions = getSubstep4RemoveModifierMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–≤–µ—Ä—à—É—î —Å–µ—Å—ñ—é –ø—ñ–¥–µ—Ç–∞–ø—É 1
 */
export const substep1FinalizeSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/substep1/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getSubstep1FinalizeSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1FinalizeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof substep1FinalizeSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['substep1FinalizeSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof substep1FinalizeSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  substep1FinalizeSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Substep1FinalizeSessionMutationResult = NonNullable<Awaited<ReturnType<typeof substep1FinalizeSession>>>
    
    export type Substep1FinalizeSessionMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–µ—Ä—à—É—î —Å–µ—Å—ñ—é –ø—ñ–¥–µ—Ç–∞–ø—É 1
 */
export const useSubstep1FinalizeSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof substep1FinalizeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof substep1FinalizeSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getSubstep1FinalizeSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –ó–∞–≤–µ—Ä—à—É—î —Å–µ—Å—ñ—é —Ç–∞ –∑–≤—ñ–ª—å–Ω—è—î —Ä–µ—Å—É—Ä—Å–∏
 */
export const stage2TerminateSession = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage2/session/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getStage2TerminateSessionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2TerminateSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage2TerminateSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage2TerminateSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage2TerminateSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage2TerminateSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage2TerminateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof stage2TerminateSession>>>
    
    export type Stage2TerminateSessionMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≤–µ—Ä—à—É—î —Å–µ—Å—ñ—é —Ç–∞ –∑–≤—ñ–ª—å–Ω—è—î —Ä–µ—Å—É—Ä—Å–∏
 */
export const useStage2TerminateSession = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage2TerminateSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage2TerminateSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage2TerminateSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°–∫–∞—Å–æ–≤—É—î —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–ª—ñ—î–Ω—Ç–∞
 */
export const stage1CancelClientCreation = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/new-client/session/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getStage1CancelClientCreationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CancelClientCreation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1CancelClientCreation>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1CancelClientCreation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1CancelClientCreation>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1CancelClientCreation(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1CancelClientCreationMutationResult = NonNullable<Awaited<ReturnType<typeof stage1CancelClientCreation>>>
    
    export type Stage1CancelClientCreationMutationError = ErrorResponse

    /**
 * @summary –°–∫–∞—Å–æ–≤—É—î —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useStage1CancelClientCreation = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CancelClientCreation>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1CancelClientCreation>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1CancelClientCreationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°–∫–∞—Å–æ–≤—É—î –ø–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const stage1CancelClientSearch = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/client-search/session/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getStage1CancelClientSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CancelClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1CancelClientSearch>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1CancelClientSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1CancelClientSearch>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1CancelClientSearch(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1CancelClientSearchMutationResult = NonNullable<Awaited<ReturnType<typeof stage1CancelClientSearch>>>
    
    export type Stage1CancelClientSearchMutationError = ErrorResponse

    /**
 * @summary –°–∫–∞—Å–æ–≤—É—î –ø–æ—à—É–∫ –∫–ª—ñ—î–Ω—Ç–∞
 */
export const useStage1CancelClientSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CancelClientSearch>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1CancelClientSearch>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1CancelClientSearchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary –°–∫–∞—Å–æ–≤—É—î –∑–±—ñ—Ä –±–∞–∑–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */
export const stage1CancelBasicOrder = (
    sessionId: string,
 options?: SecondParameter<typeof orvalFetcher>,) => {
      
      
      return orvalFetcher<void>(
      {url: `/v1/order-wizard/stage1/basic-order/session/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getStage1CancelBasicOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CancelBasicOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof stage1CancelBasicOrder>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['stage1CancelBasicOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stage1CancelBasicOrder>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  stage1CancelBasicOrder(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Stage1CancelBasicOrderMutationResult = NonNullable<Awaited<ReturnType<typeof stage1CancelBasicOrder>>>
    
    export type Stage1CancelBasicOrderMutationError = ErrorResponse

    /**
 * @summary –°–∫–∞—Å–æ–≤—É—î –∑–±—ñ—Ä –±–∞–∑–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó
 */
export const useStage1CancelBasicOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stage1CancelBasicOrder>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof orvalFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stage1CancelBasicOrder>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getStage1CancelBasicOrderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
